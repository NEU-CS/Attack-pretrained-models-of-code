Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,Greedy No. Changed Names,Greedy No. Changed Tokens,Replaced Names,GA No. Changed Names,GA No. Changed Tokens,Attack Type,Query Times,Time Cost,Suc Type,Insert Words,orig prob,current prob
0," 
  def is_sym( number ):
  	num_str = str( number )
  	num_len = len( num_str )
  	half_len = int( num_len / 2 )
  	end = num_str[-half_len:]
  	rev_end = end[::-1]
  	start = num_str[:half_len]
  	equal = rev_end == start 
  	return equal
  
  f = open( 'palindromes.out' )
  
  numbers = [ int(x) for x in f.read().split() ]
  
  numCases = input()
  for case in range( 1, numCases + 1 ):
  	min, max = [ int(x) for x in raw_input().split() ]
  	count = 0
  	for number in numbers:
  		if min <= number and max >= number:
  			count += 1
  
  	print 'Case #' + str( case ) + ': ' + str( count )
",154," 
  def is_sym( multiple ):
  	num_str = str( multiple )
  	num__size = len( num_str )
  	quarter_val = int( num__size / 2 )
  	END = num_str[-quarter_val:]
  	re_start = END[::-1]
  	name = num_str[:quarter_val]
  	id = re_start == name 
  	return id
  
  f = open( 'palindromes.out' )
  
  neums = [ int(input) for input in f.read().split() ]
  
  numPases = input()
  for case in range( 1, numPases + 1 ):
  	default, final = [ int(input) for input in raw_input().split() ]
  	call = 0
  	for multiple in neums:
  		if default <= multiple and final >= multiple:
  			call += 1
  
  	print 'Case #' + str( case ) + ': ' + str( call )
",LABEL_0,LABEL_0,LABEL_35,1,"number,num_str,num_len,half_len,end,rev_end,start,equal,f,numbers,x,numCases,case,min,max,count","number:0.7726972177624702,num_str:0.7272513210773468,num_len:0.7596590369939804,half_len:0.768678829073906,end:0.7367451190948486,rev_end:0.753857895731926,start:0.7515145987272263,equal:0.7690474614501,f:0.6364074051380157,numbers:0.7790150791406631,x:0.7742270305752754,numCases:0.734844908118248,case:0.7124977111816406,min:0.7493600994348526,max:0.7485632002353668,count:0.7760801762342453,",1,2,"numbers:neums,count:call,x:input,number:multiple,equal:id,half_len:quarter_val,num_len:num__size,rev_end:re_start,start:name,min:default,max:final,end:END,",0,0,Greedy,269,0.10035050312678019,replace,[],0.8926618695259094,0.3066280782222748
1,"def build_table():
  	table = []
  	for i in range( 0, 31 ):
  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )
  
  	return table
  
  
  def get_max_score( i ):
  	return max( 0, min( 10, ( i + 2 ) / 3 ) )
  
  def get_max_surprise_score( i ):
  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )
  
  def get_max( x, scores, score_needed, num_surprises ):
  	scores = sorted( scores, reverse=True )
  	numPass = 0
  	i = 0;
  	while ( i < len(scores) ):
  		if ( x[scores[i]][0] >= score_needed ):
  			numPass += 1
  		else:
  			break
  		i += 1
  
  	while ( i < len(scores) and num_surprises > 0 ):
  		if ( x[scores[i]][1] >= score_needed ):
  			numPass += 1
  			num_surprises -= 1
  			
  		i += 1
  
  	return numPass
  
  x = build_table()
  
  num_cases = input()
  
  for i in range( 1, num_cases + 1 ):
  	line = raw_input().split()
  	num_surprises = int(line[1])
  	score_needed = int(line[2])
  	scores_raw = line[3:]
  
  	scores = [ int(y) for y in scores_raw ]
  
  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )
",286,"def build_table():
  	table = []
  	for i in range( 0, 31 ):
  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )
  
  	return table
  
  
  def get_max_score( i ):
  	return max( 0, min( 10, ( i + 2 ) / 3 ) )
  
  def get_max_surprise_score( i ):
  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )
  
  def get_max( x, scores, score_needed, num_surprises ):
  	scores = sorted( scores, reverse=True )
  	numPass = 0
  	i = 0;
  	while ( i < len(scores) ):
  		if ( x[scores[i]][0] >= score_needed ):
  			numPass += 1
  		else:
  			break
  		i += 1
  
  	while ( i < len(scores) and num_surprises > 0 ):
  		if ( x[scores[i]][1] >= score_needed ):
  			numPass += 1
  			num_surprises -= 1
  			
  		i += 1
  
  	return numPass
  
  x = build_table()
  
  numfcells = input()
  
  for i in range( 1, numfcells + 1 ):
  	line = raw_input().split()
  	num_surprises = int(line[1])
  	score_needed = int(line[2])
  	scores_raw = line[3:]
  
  	scores = [ int(y) for y in scores_raw ]
  
  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )
",LABEL_0,LABEL_0,LABEL_61,1,"table,i,x,scores,score_needed,num_surprises,numPass,num_cases,line,scores_raw,y","table:0.7047325819730759,i:0.6779554635286331,x:0.7117789834737778,scores:0.7170985043048859,score_needed:0.7003005295991898,num_surprises:0.7079873234033585,numPass:0.7253780961036682,num_cases:0.7678563520312309,line:0.7065805643796921,scores_raw:0.7136243879795074,y:0.6891579926013947,",1,2,,0,0,Greedy,32,0.012658460934956869,replace,[],0.8820862174034119,0.8820862174034119
2," 
  
  def is_palindrome(num):
      s = str(num)
      end_idx = len(s)-1
      for i in range(len(s)//2):
          if s[i] != s[end_idx-i]:
              return False
      return True
  
  def is_valid_base(base):
      return is_palindrome(base) and is_palindrome(base*base)
  
  def process_case(lo, hi):
      cnt = 0
      base_lo = math.ceil(math.sqrt(lo))
      base_hi = math.floor(math.sqrt(hi))
      for base in range(base_lo, base_hi+1):
          if is_valid_base(base):
              cnt += 1
      return cnt
  
  def result_gen(lines):
      ncases = int(next(lines))
      for ci in range(1,ncases+1):
          lo,hi = line_of_numbers(next(lines))
          result = process_case(lo, hi)
          yield 'Case #{0}: {1}
'.format(ci, result)
      
  def line_of_numbers(s):
      return [int(sub) for sub in s.split()]
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(basename):
      infile = basename + '.in'
      outfile = basename + '.out'
      f_in = open(infile, 'r')
      f_out = open(outfile, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('C-small-attempt0')
",293," 
  
  def is_palindrome(text):
      comments = str(text)
      end_partxs = len(comments)-1
      for  ii in range(len(comments)//2):
          if comments[ ii] != comments[end_partxs- ii]:
              return False
      return True
  
  def is_valid_base(uri):
      return is_palindrome(uri) and is_palindrome(uri*uri)
  
  def process_case(elo, range):
      ucounters = 0
       base_low = math.ceil(math.sqrt(elo))
      root_hy = math.floor(math.sqrt(range))
      for uri in range( base_low, root_hy+1):
          if is_valid_base(uri):
              ucounters += 1
      return ucounters
  
  def result_gen(frames):
      encats = int(next(frames))
      for chain in range(1,encats+1):
          elo,range = line_of_numbers(next(frames))
          case = process_case(elo, range)
          yield 'Case #{0}: {1}
'.format(chain, case)
      
  def line_of_numbers(comments):
      return [int(slice) for slice in comments.split()]
  
  def input_gen( f_inner):
      for cl in  f_inner:
          if cl.endswith('
'):
              cl = cl[:-1]
          yield cl
  
  def start(binename):
      infile = binename + '.in'
       outfilename = binename + '.out'
       f_inner = open(infile, 'r')
       f_line = open( outfilename, 'w')
       f_line.writelines(result_gen(input_gen( f_inner)))
       f_inner.close()
       f_line.close()
  
  start('C-small-attempt0')
",LABEL_1,LABEL_1,,-1,"num,s,end_idx,i,base,lo,hi,cnt,base_lo,base_hi,lines,ncases,ci,result,sub,f_in,line,basename,infile,outfile,f_out","num:0.6141069233417511,s:0.7554890960454941,end_idx:0.5440984666347504,i:0.5189664959907532,base:0.618169754743576,lo:0.6091156899929047,hi:0.5761971771717072,cnt:0.5830695331096649,base_lo:0.5576920807361603,base_hi:0.5541701316833496,lines:0.5603256225585938,ncases:0.5551335215568542,ci:0.5177620351314545,result:0.646005243062973,sub:0.500058114528656,f_in:0.5358881056308746,line:0.4943546950817108,basename:0.5344087481498718,infile:0.5048363208770752,outfile:0.5222307443618774,f_out:0.4329220652580261,",0,0,"s:comments,result:case,base:uri,num:text,lo:elo,cnt:ucounters,hi:range,lines:frames,base_lo: base_low,ncases:encats,base_hi:root_hy,end_idx:end_partxs,f_in: f_inner,basename:binename,outfile: outfilename,i: ii,ci:ic,sub:sam,line:cl,f_out: f_line,",0,0,Greedy,425,0.1526269833246867,failed,[],0.9657654762268066,0.31073564291000366
3," 
  def threshold(p, maxdiff):
      minval = max(p - maxdiff, 0)
      return p + minval + minval
  
  def process_case(numdata):
      N,S,p = numdata[0:3]
      scores = numdata[3:]
      thre_normal = threshold(p, 1)
      thre_surprise = threshold(p, 2)
      result = 0
      for tot in scores:
          if tot >= thre_normal:
              result += 1
          elif S > 0 and tot >= thre_surprise:
              result += 1
              S -= 1
      return result
  
  def result_gen(lines):
      ncases = int(next(lines))
      for ci in range(1,ncases+1):
          result = process_case(line_of_numbers(next(lines)))
          yield 'Case #{0}: {1}
'.format(ci, result)
      
  def line_of_numbers(s):
      return [int(sub) for sub in s.split()]
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(basename):
      infile = basename + '.in'
      outfile = basename + '.out'
      f_in = open(infile, 'r')
      f_out = open(outfile, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('B-small-attempt0')
",256," 
  def threshold(point, maxchange):
       minmin = max(point - maxchange, 0)
      return point +  minmin +  minmin
  
  def process_case(multipos):
      PI,Case,point = multipos[0:3]
       score = multipos[3:]
      thre2common = threshold(point, 1)
      thre_purce = threshold(point, 2)
      case = 0
      for tot in  score:
          if tot >= thre2common:
              case += 1
          elif Case > 0 and tot >= thre_purce:
              case += 1
              Case -= 1
      return case
  
  def result_gen(zip):
      NCakes = int(next(zip))
      for uc in range(1,NCakes+1):
          case = process_case(line_of_numbers(next(zip)))
          yield 'Case #{0}: {1}
'.format(uc, case)
      
  def line_of_numbers(sf):
      return [int(division) for division in sf.split()]
  
  def input_gen(f_inn):
      for c in f_inn:
          if c.endswith('
'):
              c = c[:-1]
          yield c
  
  def start(basename):
      inputfile = basename + '.in'
      outfilename = basename + '.out'
      f_inn = open(inputfile, 'r')
      f_write = open(outfilename, 'w')
      f_write.writelines(result_gen(input_gen(f_inn)))
      f_inn.close()
      f_write.close()
  
  start('B-small-attempt0')
",LABEL_1,LABEL_1,,-1,"p,maxdiff,minval,numdata,N,S,scores,thre_normal,thre_surprise,result,tot,lines,ncases,ci,s,sub,f_in,line,basename,infile,outfile,f_out","p:0.36619091033935547,maxdiff:0.2651664614677429,minval:0.25749456882476807,numdata:0.24214577674865723,N:0.25808507204055786,S:0.32390904426574707,scores:0.27788710594177246,thre_normal:0.2540628910064697,thre_surprise:0.2720280885696411,result:0.36858415603637695,tot:0.27639782428741455,lines:0.3392857313156128,ncases:0.22306591272354126,ci:0.2724061608314514,s:0.24251699447631836,sub:0.2502652406692505,f_in:0.24363809823989868,line:0.20327353477478027,basename:0.27733105421066284,infile:0.231883704662323,outfile:0.2347506284713745,f_out:0.19389772415161133,",0,0,"result:case,p:point,lines:zip,S:Case,scores: score,ci:inf,thre_surprise:thre_purce,maxdiff:maxchange,N:PI,minval: minmin,thre_normal:thre2common,sub:division,f_in:f_inn,s:sf,numdata:multipos,outfile:outfilename,infile:inputile,ncases:NCakes,line:c,f_out:f_write,",0,0,Greedy,448,0.16100041468938192,failed,[],0.9864764213562012,0.6628612279891968
4," 
  '''
  Limits
  
  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.
  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.
  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.
  
  Sample
  *** Input 
  3
  1 4
  10 120
  100 1000
   	
  *** Output 
  Case #1: 2
  Case #2: 0
  Case #3: 2
  
  
  '''
  
  
  
  inf = open(sys.argv[1])
  def input(): return inf.readline().strip()
  
  pal_sqr_roots = '''1 
  2 
  3 
  11 
  22 
  26 
  101 
  111 
  121 
  202 
  212 
  264 
  307 
  836 
  1001 
  1111 
  2002 
  2285 
  2636 
  10001 
  10101 
  10201 
  11011 
  11111 
  11211 
  20002 
  20102 
  22865 
  24846 
  30693 
  100001 
  101101 
  110011 
  111111 
  200002 
  798644 
  1000001 
  1001001 
  1002001 
  1010101 
  1011101 
  1012101 
  1042151 
  1100011 
  1101011 
  1102011 
  1109111 
  1110111 
  1111111 
  1270869 
  2000002 
  2001002 
  2012748 
  2294675 
  3069307 
  10000001 
  10011001 
  10100101 
  10111101 
  11000011 
  11011011 
  11100111 
  11111111 
  11129361 
  12028229 
  12866669 
  20000002 
  30001253 
  64030648 
  100000001 
  100010001 
  100020001 
  100101001 
  100111001 
  100121001 
  101000101 
  101010101 
  101020101 
  101101101 
  101111101 
  110000011 
  110010011 
  110020011 
  110091011 
  110101011 
  110111011 
  111000111 
  111010111 
  111091111 
  111101111 
  111111111 
  200000002 
  200010002 
  306930693 
  1000000001 
  1000110001 
  1001001001 
  1001111001 
  1010000101 
  1010110101 
  1011001101 
  1011111101 
  1100000011 
  1100110011 
  1101001011 
  1101111011 
  1110000111 
  1110110111 
  1111001111 
  2000000002 
  2062386218 
  2481623254 
  10000000001 
  10000100001 
  10000200001 
  10001010001 
  10001110001 
  10001210001 
  10010001001 
  10010101001 
  10010201001 
  10011011001 
  10011111001 
  10100000101 
  10100100101 
  10100200101 
  10101010101 
  10101110101 
  10106064399 
  10109901101 
  10110001101 
  10110101101 
  10110911101 
  10111011101 
  10111111101 
  10207355549 
  11000000011 
  11000100011 
  11000200011 
  11000910011 
  11001010011 
  11001110011 
  11010001011 
  11010101011 
  11010911011 
  11011011011 
  11011111011 
  11100000111 
  11100100111 
  11100910111 
  11101010111 
  11101110111 
  11110001111 
  11110101111 
  13579355059 
  20000000002 
  20000100002 
  22865150135 
  30101273647 
  30693069307 
  83163115486 
  100000000001 
  100001100001 
  100010010001 
  100011110001 
  100100001001 
  100101101001 
  100110011001 
  100111111001 
  101000000101 
  101001100101 
  101010010101 
  101011110101 
  101100001101 
  101101101101 
  101110011101 
  101116809851 
  110000000011 
  110001100011 
  110010010011 
  110011110011 
  110100001011 
  110101101011 
  110110011011 
  111000000111 
  111001100111 
  111010010111 
  111100001111 
  111283619361 
  112247658961 
  128817084669 
  200000000002 
  1000000000001 
  1000001000001 
  1000002000001 
  1000010100001 
  1000011100001 
  1000012100001 
  1000100010001 
  1000101010001 
  1000102010001 
  1000110110001 
  1000111110001 
  1001000001001 
  1001001001001 
  1001002001001 
  1001010101001 
  1001011101001 
  1001100011001 
  1001101011001 
  1001110111001 
  1001111111001 
  1010000000101 
  1010001000101 
  1010002000101 
  1010010100101 
  1010011100101 
  1010099010101 
  1010100010101 
  1010101010101 
  1010109110101 
  1010110110101 
  1010111110101 
  1011000001101 
  1011001001101 
  1011010101101 
  1011011101101 
  1011099011101 
  1011100011101 
  1011101011101 
  1100000000011 
  1100001000011 
  1100002000011 
  1100009100011 
  1100010100011 
  1100011100011 
  1100100010011 
  1100101010011 
  1100110110011 
  1100111110011 
  1101000001011 
  1101001001011 
  1101009101011 
  1101010101011 
  1101011101011 
  1101100011011 
  1101101011011 
  1110000000111 
  1110001000111 
  1110009100111 
  1110010100111 
  1110011100111 
  1110100010111 
  1110101010111 
  1111000001111 
  1111001001111 
  1349465117841 
  2000000000002 
  2000001000002 
  2149099165358 
  2634812417864 
  3069306930693 
  6360832925898 
  10000000000001 
  10000011000001 
  10000100100001 
  10000111100001 
  10001000010001 
  10001011010001 
  10001100110001 
  10001111110001 
  10010000001001 
  10010011001001 
  10010100101001 
  10010111101001 
  10011000011001 
  10011011011001 
  10011100111001 
  10100000000101 
  10100011000101 
  10100100100101 
  10100111100101 
  10101000010101 
  10101011010101 
  10101100110101 
  10110000001101 
  10110011001101 
  10110100101101 
  10111000011101 
  11000000000011 
  11000011000011 
  11000100100011 
  11000111100011 
  11001000010011 
  11001011010011 
  11001100110011 
  11010000001011 
  11010011001011 
  11010100101011 
  11011000011011 
  11100000000111 
  11100011000111 
  11100100100111 
  11101000010111 
  11110000001111 
  20000000000002 
  30395080190573 
  69800670077028 
  98275825201587 
  100000000000001 
  100000010000001 
  100000020000001 
  100000101000001 
  100000111000001 
  100000121000001 
  100001000100001 
  100001010100001 
  100001020100001 
  100001101100001 
  100001111100001 
  100010000010001 
  100010010010001 
  100010020010001 
  100010101010001 
  100010111010001 
  100011000110001 
  100011010110001 
  100011101110001 
  100011111110001 
  100100000001001 
  100100010001001 
  100100020001001 
  100100101001001 
  100100111001001 
  100101000101001 
  100101010101001 
  100101101101001 
  100101111101001 
  100109990011001 
  100110000011001 
  100110010011001 
  100110091011001 
  100110101011001 
  100110111011001 
  100110990111001 
  100111000111001 
  100111010111001 
  101000000000101 
  101000010000101 
  101000020000101 
  101000101000101 
  101000111000101 
  101000990100101 
  101001000100101 
  101001010100101 
  101001091100101 
  101001101100101 
  101001111100101 
  101010000010101 
  101010010010101 
  101010101010101 
  101010111010101 
  101010990110101 
  101011000110101 
  101011010110101 
  101100000001101 
  101100010001101 
  101100101001101 
  101100111001101 
  101101000101101 
  101101010101101 
  101110000011101 
  101110010011101 
  110000000000011 
  110000010000011 
  110000020000011 
  110000091000011 
  110000101000011 
  110000111000011 
  110001000100011 
  110001010100011 
  110001101100011 
  110001111100011 
  110010000010011 
  110010010010011 
  110010091010011 
  110010101010011 
  110010111010011 
  110011000110011 
  110011010110011 
  110100000001011 
  110100010001011 
  110100101001011 
  110100111001011 
  110101000101011 
  110101010101011 
  110110000011011 
  110110010011011 
  111000000000111 
  111000010000111 
  111000091000111 
  111000101000111 
  111000111000111 
  111001000100111 
  111001010100111 
  111010000010111 
  111010010010111 
  111100000001111 
  111100010001111 
  129610990752569 
  200000000000002 
  200000010000002 
  210786628549538 
  314155324482867 
  1000000000000000 
  1000000110000000 
  1000001001000000 
  1000001111000000 
  1000010000100000 
  1000010110100000 
  1000011001100000 
  1000011111100000 
  1000100000010000 
  1000100110010000 
  1000101001010000 
  1000101111010000 
  1000110000110000 
  1000110110110000 
  1000111001110000 
  1001000000001000 
  1001000110001000 
  1001001001001000 
  1001001111001000 
  1001010000101000 
  1001010110101000 
  1001011001101000 
  1001100000011000 
  1001100110011000 
  1001101001011000 
  1001110000111000 
  1010000000000100 
  1010000110000100 
  1010001001000100 
  1010001111000100 
  1010010000100100 
  1010010110100100 
  1010011001100100 
  1010100000010100 
  1010100110010100 
  1010101001010100 
  1010110000110100 
  1011000000001100 
  1011000110001100 
  1011001001001100 
  1011010000101100 
  1011100000011100 
  1100000000000010 
  1100000110000010 
  1100001001000010 
  1100001111000010 
  1100010000100010 
  1100010110100010 
  1100011001100010 
  1100100000010010 
  1100100110010010 
  1100101001010010 
  1100110000110010 
  1101000000001010 
  1101000110001010 
  1101001001001010 
  1101010000101010 
  1101100000011010 
  1110000000000110 
  1110000110000110 
  1110001001000110 
  1110010000100110 
  1110100000010110 
  1111000000001110 
  2000000000000000 
  2201019508986470 
  2564053868197730 
  3066446727654240 
  3107974295870660 
  3138199296186060'''
  pal_sqr_roots = map(int, pal_sqr_roots.split())
  
  
  
  def is_palindrome(n):
      return str(n)[::-1] == str(n)
  
  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]
  
  fair_and_square = [x*x for x in palindromic_roots]
  
  
  def get_num_fair_and_square(a, b):
      return len([x for x in fair_and_square if a <= x <= b])
  
  for caseNo in range(1, int(input())+1):
      a,b = map(int, input().split())
      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)
  
",157," 
  '''
  Limits
  
  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.
  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.
  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.
  
  Sample
  *** Input 
  3
  1 4
  10 120
  100 1000
   	
  *** Output 
  Case #1: 2
  Case #2: 0
  Case #3: 2
  
  
  '''
  
  
  
  feed = open(sys.argv[1])
  def input(): return feed.readline().strip()
  
   sys_sqr1root = '''1 
  2 
  3 
  11 
  22 
  26 
  101 
  111 
  121 
  202 
  212 
  264 
  307 
  836 
  1001 
  1111 
  2002 
  2285 
  2636 
  10001 
  10101 
  10201 
  11011 
  11111 
  11211 
  20002 
  20102 
  22865 
  24846 
  30693 
  100001 
  101101 
  110011 
  111111 
  200002 
  798644 
  1000001 
  1001001 
  1002001 
  1010101 
  1011101 
  1012101 
  1042151 
  1100011 
  1101011 
  1102011 
  1109111 
  1110111 
  1111111 
  1270869 
  2000002 
  2001002 
  2012748 
  2294675 
  3069307 
  10000001 
  10011001 
  10100101 
  10111101 
  11000011 
  11011011 
  11100111 
  11111111 
  11129361 
  12028229 
  12866669 
  20000002 
  30001253 
  64030648 
  100000001 
  100010001 
  100020001 
  100101001 
  100111001 
  100121001 
  101000101 
  101010101 
  101020101 
  101101101 
  101111101 
  110000011 
  110010011 
  110020011 
  110091011 
  110101011 
  110111011 
  111000111 
  111010111 
  111091111 
  111101111 
  111111111 
  200000002 
  200010002 
  306930693 
  1000000001 
  1000110001 
  1001001001 
  1001111001 
  1010000101 
  1010110101 
  1011001101 
  1011111101 
  1100000011 
  1100110011 
  1101001011 
  1101111011 
  1110000111 
  1110110111 
  1111001111 
  2000000002 
  2062386218 
  2481623254 
  10000000001 
  10000100001 
  10000200001 
  10001010001 
  10001110001 
  10001210001 
  10010001001 
  10010101001 
  10010201001 
  10011011001 
  10011111001 
  10100000101 
  10100100101 
  10100200101 
  10101010101 
  10101110101 
  10106064399 
  10109901101 
  10110001101 
  10110101101 
  10110911101 
  10111011101 
  10111111101 
  10207355549 
  11000000011 
  11000100011 
  11000200011 
  11000910011 
  11001010011 
  11001110011 
  11010001011 
  11010101011 
  11010911011 
  11011011011 
  11011111011 
  11100000111 
  11100100111 
  11100910111 
  11101010111 
  11101110111 
  11110001111 
  11110101111 
  13579355059 
  20000000002 
  20000100002 
  22865150135 
  30101273647 
  30693069307 
  83163115486 
  100000000001 
  100001100001 
  100010010001 
  100011110001 
  100100001001 
  100101101001 
  100110011001 
  100111111001 
  101000000101 
  101001100101 
  101010010101 
  101011110101 
  101100001101 
  101101101101 
  101110011101 
  101116809851 
  110000000011 
  110001100011 
  110010010011 
  110011110011 
  110100001011 
  110101101011 
  110110011011 
  111000000111 
  111001100111 
  111010010111 
  111100001111 
  111283619361 
  112247658961 
  128817084669 
  200000000002 
  1000000000001 
  1000001000001 
  1000002000001 
  1000010100001 
  1000011100001 
  1000012100001 
  1000100010001 
  1000101010001 
  1000102010001 
  1000110110001 
  1000111110001 
  1001000001001 
  1001001001001 
  1001002001001 
  1001010101001 
  1001011101001 
  1001100011001 
  1001101011001 
  1001110111001 
  1001111111001 
  1010000000101 
  1010001000101 
  1010002000101 
  1010010100101 
  1010011100101 
  1010099010101 
  1010100010101 
  1010101010101 
  1010109110101 
  1010110110101 
  1010111110101 
  1011000001101 
  1011001001101 
  1011010101101 
  1011011101101 
  1011099011101 
  1011100011101 
  1011101011101 
  1100000000011 
  1100001000011 
  1100002000011 
  1100009100011 
  1100010100011 
  1100011100011 
  1100100010011 
  1100101010011 
  1100110110011 
  1100111110011 
  1101000001011 
  1101001001011 
  1101009101011 
  1101010101011 
  1101011101011 
  1101100011011 
  1101101011011 
  1110000000111 
  1110001000111 
  1110009100111 
  1110010100111 
  1110011100111 
  1110100010111 
  1110101010111 
  1111000001111 
  1111001001111 
  1349465117841 
  2000000000002 
  2000001000002 
  2149099165358 
  2634812417864 
  3069306930693 
  6360832925898 
  10000000000001 
  10000011000001 
  10000100100001 
  10000111100001 
  10001000010001 
  10001011010001 
  10001100110001 
  10001111110001 
  10010000001001 
  10010011001001 
  10010100101001 
  10010111101001 
  10011000011001 
  10011011011001 
  10011100111001 
  10100000000101 
  10100011000101 
  10100100100101 
  10100111100101 
  10101000010101 
  10101011010101 
  10101100110101 
  10110000001101 
  10110011001101 
  10110100101101 
  10111000011101 
  11000000000011 
  11000011000011 
  11000100100011 
  11000111100011 
  11001000010011 
  11001011010011 
  11001100110011 
  11010000001011 
  11010011001011 
  11010100101011 
  11011000011011 
  11100000000111 
  11100011000111 
  11100100100111 
  11101000010111 
  11110000001111 
  20000000000002 
  30395080190573 
  69800670077028 
  98275825201587 
  100000000000001 
  100000010000001 
  100000020000001 
  100000101000001 
  100000111000001 
  100000121000001 
  100001000100001 
  100001010100001 
  100001020100001 
  100001101100001 
  100001111100001 
  100010000010001 
  100010010010001 
  100010020010001 
  100010101010001 
  100010111010001 
  100011000110001 
  100011010110001 
  100011101110001 
  100011111110001 
  100100000001001 
  100100010001001 
  100100020001001 
  100100101001001 
  100100111001001 
  100101000101001 
  100101010101001 
  100101101101001 
  100101111101001 
  100109990011001 
  100110000011001 
  100110010011001 
  100110091011001 
  100110101011001 
  100110111011001 
  100110990111001 
  100111000111001 
  100111010111001 
  101000000000101 
  101000010000101 
  101000020000101 
  101000101000101 
  101000111000101 
  101000990100101 
  101001000100101 
  101001010100101 
  101001091100101 
  101001101100101 
  101001111100101 
  101010000010101 
  101010010010101 
  101010101010101 
  101010111010101 
  101010990110101 
  101011000110101 
  101011010110101 
  101100000001101 
  101100010001101 
  101100101001101 
  101100111001101 
  101101000101101 
  101101010101101 
  101110000011101 
  101110010011101 
  110000000000011 
  110000010000011 
  110000020000011 
  110000091000011 
  110000101000011 
  110000111000011 
  110001000100011 
  110001010100011 
  110001101100011 
  110001111100011 
  110010000010011 
  110010010010011 
  110010091010011 
  110010101010011 
  110010111010011 
  110011000110011 
  110011010110011 
  110100000001011 
  110100010001011 
  110100101001011 
  110100111001011 
  110101000101011 
  110101010101011 
  110110000011011 
  110110010011011 
  111000000000111 
  111000010000111 
  111000091000111 
  111000101000111 
  111000111000111 
  111001000100111 
  111001010100111 
  111010000010111 
  111010010010111 
  111100000001111 
  111100010001111 
  129610990752569 
  200000000000002 
  200000010000002 
  210786628549538 
  314155324482867 
  1000000000000000 
  1000000110000000 
  1000001001000000 
  1000001111000000 
  1000010000100000 
  1000010110100000 
  1000011001100000 
  1000011111100000 
  1000100000010000 
  1000100110010000 
  1000101001010000 
  1000101111010000 
  1000110000110000 
  1000110110110000 
  1000111001110000 
  1001000000001000 
  1001000110001000 
  1001001001001000 
  1001001111001000 
  1001010000101000 
  1001010110101000 
  1001011001101000 
  1001100000011000 
  1001100110011000 
  1001101001011000 
  1001110000111000 
  1010000000000100 
  1010000110000100 
  1010001001000100 
  1010001111000100 
  1010010000100100 
  1010010110100100 
  1010011001100100 
  1010100000010100 
  1010100110010100 
  1010101001010100 
  1010110000110100 
  1011000000001100 
  1011000110001100 
  1011001001001100 
  1011010000101100 
  1011100000011100 
  1100000000000010 
  1100000110000010 
  1100001001000010 
  1100001111000010 
  1100010000100010 
  1100010110100010 
  1100011001100010 
  1100100000010010 
  1100100110010010 
  1100101001010010 
  1100110000110010 
  1101000000001010 
  1101000110001010 
  1101001001001010 
  1101010000101010 
  1101100000011010 
  1110000000000110 
  1110000110000110 
  1110001001000110 
  1110010000100110 
  1110100000010110 
  1111000000001110 
  2000000000000000 
  2201019508986470 
  2564053868197730 
  3066446727654240 
  3107974295870660 
  3138199296186060'''
   sys_sqr1root = map(int,  sys_sqr1root.split())
  
  
  
  def is_palindrome(n):
      return str(n)[::-1] == str(n)
  
  palindromic_roots = [x for x in  sys_sqr1root if is_palindrome(x)]
  
  fair_and_square = [x*x for x in palindromic_roots]
  
  
  def get_num_fair_and_square(a, b):
      return len([x for x in fair_and_square if a <= x <= b])
  
  for caseNo in range(1, int(input())+1):
      a,b = map(int, input().split())
      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)
  
",LABEL_2,LABEL_2,,-1,"inf,pal_sqr_roots","inf:0.7458916753530502,pal_sqr_roots:0.8021832406520844,",0,0,"pal_sqr_roots: sys_sqr1root,inf:feed,",0,0,Greedy,43,0.016612287362416586,failed,[],0.9067215919494629,0.6180453896522522
5," 
  '''
  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]
  At least S of the ti values will be between 2 and 28, inclusive.
  
  Small dataset 1 = N = 3.
  Large dataset 1 = N = 100.
  
  Sample Input 
  4
  3 1 5 15 13 11
  3 0 8 23 22 21
  2 1 1 8 0
  6 2 8 29 20 8 18 18 21
  
  Output 
  Case #1: 3
  Case #2: 2
  Case #3: 1
  Case #4: 3
  '''
  
  
  
  inf = open(sys.argv[1])
  def input(): return inf.readline().strip()
  
  def maxBestDancers(N, S, p, *Ti):
      cnt = 0
      for score in Ti:
          mx = (score + 2) // 3
          if mx >= p:
              cnt += 1
          elif mx >= p-1 > 0 and S>0:
              S -= 1
              cnt += 1
      return cnt
  
  for caseNo in range(1, int(input())+1):
      print 'Case #%d:' % caseNo,
      lst = map(int, input().split())
      print maxBestDancers(*lst)
  
",127," 
  '''
  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]
  At least S of the ti values will be between 2 and 28, inclusive.
  
  Small dataset 1 = N = 3.
  Large dataset 1 = N = 100.
  
  Sample Input 
  4
  3 1 5 15 13 11
  3 0 8 23 22 21
  2 1 1 8 0
  6 2 8 29 20 8 18 18 21
  
  Output 
  Case #1: 3
  Case #2: 2
  Case #3: 1
  Case #4: 3
  '''
  
  
  
  feed = open(sys.argv[1])
  def input(): return feed.readline().strip()
  
  def maxBestDancers(NA, size, t, *Ti):
       cno = 0
      for score in Ti:
          cycle = (score + 2) // 3
          if cycle >= t:
               cno += 1
          elif cycle >= t-1 > 0 and size>0:
              size -= 1
               cno += 1
      return  cno
  
  for caseNumber in range(1, int(input())+1):
      print 'Case #%d:' % caseNumber,
      elst = map(int, input().split())
      print maxBestDancers(*elst)
  
",LABEL_2,LABEL_2,,-1,"inf,N,S,p,cnt,score,mx,caseNo,lst","inf:0.8884772136807442,N:0.8654679730534554,S:0.892131932079792,p:0.8913212418556213,cnt:0.8874516934156418,score:0.8738501369953156,mx:0.8701686039566994,caseNo:0.8993502408266068,lst:0.9032839760184288,",0,0,"lst:elst,caseNo:caseNumber,S:size,p:t,inf:feed,cnt: cno,mx:cycle,N:NA,",0,0,Greedy,189,0.06735987265904744,failed,[],0.9694219827651978,0.9316019415855408
6," 
  def generateTable(N):
      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]
      nums = revnums = [1, 2]
  
      digsums = [1, 4]
  
      for i in xrange(2, N+1):
          a, b, d = [], [], []
          p = 10**(i-1)
          for j in xrange(len(nums)):
              for k in xrange(3):
                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k
                  if ds < 5:
                      a.append(n)
                      b.append(rn)
                      d.append(ds)
                      msq.append(10*p*n + rn) # even length
                      if i == N:
                          continue
                      for l in xrange(3): # odd length
                          if 2*ds + l*l < 10:
                              msq.append(100*p*n + 10*p*l + rn)
          nums, revnums, digsums = a, b, d
  
      msq.sort()
      return msq
  
  def getNum(A, B):
      return bisect_right(tab2, B) - bisect_right(tab2, A-1)
  
  N = 10
  tab = generateTable(N)
  tab2 = map(lambda n: n**2, tab)
  
  T = int(raw_input())
  for z in xrange(T):
      A, B = map(int, raw_input().split())
      print ""Case #%d: %d"" % (z+1, getNum(A, B))
",323," 
  def generateTable(N):
      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]
      nums = revnums = [1, 2]
  
      dimensumes = [1, 4]
  
      for i in xrange(2, N+1):
          aw, emb, d = [], [], []
          p = 10**(i-1)
          for uj in xrange(len(nums)):
              for k in xrange(3):
                  name, ron, ds = 10*nums[uj] + k, revnums[uj] + k*p, dimensumes[uj] + k*k
                  if ds < 5:
                      aw.append(name)
                      emb.append(ron)
                      d.append(ds)
                      msq.append(10*p*name + ron) # even length
                      if i == N:
                          continue
                      for l in xrange(3): # odd length
                          if 2*ds + l*l < 10:
                              msq.append(100*p*name + 10*p*l + ron)
          nums, revnums, dimensumes = aw, emb, d
  
      msq.sort()
      return msq
  
  def getNum(A, B):
      return bisect_right(tab2, B) - bisect_right(tab2, A-1)
  
  N = 10
  case = generateTable(N)
  tab2 = map(lambda name: name**2, case)
  
  Ti = int(raw_input())
  for zone in xrange(Ti):
      A, B = map(int, raw_input().split())
      print ""Case #%d: %d"" % (zone+1, getNum(A, B))
",LABEL_3,LABEL_3,LABEL_10,1,"N,msq,nums,revnums,digsums,i,a,b,d,p,j,k,n,rn,ds,l,A,B,tab,tab2,T,z","N:0.5376111418008804,msq:0.4921336770057678,nums:0.5373642891645432,revnums:0.5270076543092728,digsums:0.5527554228901863,i:0.5377533733844757,a:0.5406170338392258,b:0.5406352281570435,d:0.5321292579174042,p:0.5311304777860641,j:0.5396856069564819,k:0.5292137563228607,n:0.5444575846195221,rn:0.5419505536556244,ds:0.5317590981721878,l:0.5332506448030472,A:0.538015604019165,B:0.5372690409421921,tab:0.5594028830528259,tab2:0.5340932011604309,T:0.5406016856431961,z:0.5454005375504494,",1,4,"tab:case,digsums:dimensumes,z:zone,n:name,rn:ron,b:emb,a:aw,T:Ti,",0,0,Greedy,203,0.075159486134847,replace,[],0.6703781485557556,0.29442769289016724
7,"T = int(raw_input())
  
  for z in xrange(1, T+1):
      a = map(int, raw_input().split())
      s, p = a[1:3]
      a = a[3:]
      A = 0 if p == 0 else 3*p - 2
      B = 0 if p == 0 else 1 if p == 1 else 3*p-4
      x = len(filter(lambda x: x >= A, a))
      y = len(filter(lambda x: x >= B, a)) - x
      res = x + min(s, y)
      print ""Case #%d:"" % z, res
",133,"WT = int(raw_input())
  
  for j in xrange(1, WT+1):
      ab = map(int, raw_input().split())
      sv, r = ab[1:3]
      ab = ab[3:]
      M = 0 if r == 0 else 3*r - 2
       b = 0 if r == 0 else 1 if r == 1 else 3*r-4
      c = len(filter(lambda c: c >= M, ab))
      l = len(filter(lambda c: c >=  b, ab)) - c
      id = c + min(sv, l)
      print ""Case #%d:"" % j, id
",LABEL_3,LABEL_3,,-1,"T,z,a,s,p,A,B,x,y,res","T:0.6065909564495087,z:0.655644953250885,a:0.6120269894599915,s:0.6419246643781662,p:0.610234409570694,A:0.6363660246133804,B:0.6192214488983154,x:0.6266609281301498,y:0.6126063019037247,res:0.6659822762012482,",0,0,"res:id,z:j,s:sv,A:M,x:h,B: b,y:l,a:sta,p:i,T:m,",0,0,Greedy,204,0.07240026791890462,failed,[],0.771472692489624,0.22676654160022736
8," 
  
  f = open(sys.argv[1],'r')
  
  num = int(f.readline())
  
  def pal(x):
      l = list(str(x))
      l2 = copy.copy(l)
      l2.reverse()
      return l == l2
  
  for i in range(num):
      count = 0
      line = f.readline()
      a,b = line.split()
      a = int(a)
      b = int(b)
      ma = int(math.sqrt(a))
      mb = int(math.sqrt(b))+1
      for j in range(ma,mb+1):
          q = j*j
          if q < a or q > b:
              continue
          if pal(j) and pal(q):
              count += 1
      print 'Case #{}:'.format(i+1), count
",170," 
  
  feed = open(sys.argv[1],'r')
  
  month = int(feed.readline())
  
  def pal(xb):
      u = list(str(xb))
      Ltwo = copy.copy(u)
      Ltwo.reverse()
      return u == Ltwo
  
  for ui in range(month):
      case = 0
      line = feed.readline()
      a,v = line.split()
      a = int(a)
      v = int(v)
      mp = int(math.sqrt(a))
      mp = int(math.sqrt(v))+1
      for mm in range(mp,mp+1):
          qi = mm*mm
          if qi < a or qi > v:
              continue
          if pal(mm) and pal(qi):
              case += 1
      print 'Case #{}:'.format(ui+1), case
",LABEL_4,LABEL_4,,-1,"f,num,x,l,l2,i,count,line,a,b,ma,mb,j,q","f:0.838030532002449,num:0.871332436800003,x:0.8794423416256905,l:0.8753934502601624,l2:0.8864504769444466,i:0.8573662787675858,count:0.8391235023736954,line:0.8613635525107384,a:0.8620752319693565,b:0.8632107451558113,ma:0.8531753867864609,mb:0.8606108129024506,j:0.8574645966291428,q:0.8603408932685852,",0,0,"l2:Ltwo,x:xb,l:u,num:month,b:ba,mb:ms,q:r,j:mm,i:qi,ma:ms,count:case,f:u,",0,0,Greedy,280,0.09993003606796265,failed,[],0.9858142733573914,0.9418051838874817
9," 
  
  f = open(sys.argv[1],'r')
  
  num = int(f.readline())
  
  for i in range(num):
      res = [int(x) for x in f.readline().split()]
      nrg, nrsup, score = res[0:3]
      del res[0:3]
      nrpass = 0
      nrsuppass = 0
      for x in res:
          if score > 1:
              if x >= 3*score-2:
                  nrpass += 1
              elif x >= 3*score-4:
                  nrsuppass += 1
          elif score == 1:
              if x > 0:
                  nrpass += 1
          else:
              nrpass +=1
      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)
",146," 
  
  fc = open(sys.argv[1],'r')
  
  loop = int(fc.readline())
  
  for bit in range(loop):
      out = [int(sex) for sex in fc.readline().split()]
      cnperse, nrsups, file = out[0:3]
      del out[0:3]
      nrPASS = 0
      nrSuppass = 0
      for sex in out:
          if file > 1:
              if sex >= 3*file-2:
                  nrPASS += 1
              elif sex >= 3*file-4:
                  nrSuppass += 1
          elif file == 1:
              if sex > 0:
                  nrPASS += 1
          else:
              nrPASS +=1
      print 'Case #{}:'.format(bit+1), nrPASS + min(nrsups, nrSuppass)
",LABEL_4,LABEL_4,,-1,"f,num,i,res,x,nrg,nrsup,score,nrpass,nrsuppass","f:0.8700286224484444,num:0.7138993740081787,i:0.6926667392253876,res:0.7479482144117355,x:0.8181058168411255,nrg:0.8563306480646133,nrsup:0.8483787626028061,score:0.793451115489006,nrpass:0.8295756131410599,nrsuppass:0.83559849858284,",0,0,"f:fc,nrg:cnperse,nrsup:nrsups,nrsuppass:nrSuppass,nrpass:nrPASS,x:sex,score:file,res:obj,num:loop,i:bit,",0,0,Greedy,205,0.07308065096537272,failed,[],0.9749510884284973,0.8954163789749146
10," 
  def ss(t, amap, bmap):
      s = 0
      for m in amap:
          if len(m) == 1 and t == m.keys()[0]:
              s += m[t]
              for b in bmap:
                  if t in b:
                      b[t] -= 1
                      if b[t] == 0:
                          b.pop(t)
              m.clear()
      return s           
  
  
  def solve(case, in_lines):
      out = 'Case #%d: '%case
   
      rn, cn = [int(x) for x in in_lines[0].split()]
      mtx = []
      for i in xrange(rn):
          mtx.append([int(x) for x in in_lines[i+1].split()])
      rmap = [{} for x in xrange(rn)]
      cmap = [{} for x in xrange(cn)]
      td = {}
      
      for i in xrange(rn):
          for j in range(cn):
              k = mtx[i][j]
              if k in rmap[i]:
                  rmap[i][k] += 1
              else:
                  rmap[i][k] = 1
              if k in cmap[j]:
                  cmap[j][k] += 1
              else:
                  cmap[j][k] = 1
              if k in td:
                  td[k] += 1
              else:
                  td[k] = 1
                  
      while len(td):
          k = min(td.keys())
          sb = ss(k, rmap, cmap)
          sb += ss(k, cmap, rmap)
          if sb == 0:
              break;
          td[k] -= sb
          if td[k] == 0:
              td.pop(k)
  
      return out + ('YES' if sb else 'NO')
  
  
  def main(raw):
      lines = raw.split('
')
      n = int(lines[0])
      ln = 1
      outs = []
      for case in xrange(1, n+1):
          buff = []
          cl = int(lines[ln].split()[0]) + ln + 1
          while ln < cl and lines[ln]:
              buff.append(lines[ln])
              ln += 1
          s = solve(case, buff)
          print s
          outs.append(s)
      return '
'.join(outs)
      pass
  
  if __name__ == '__main__':
      test_input = """"""4
  4 3
  2 5 2
  1 1 1
  2 4 2
  2 3 2
  3 3
  2 1 2
  1 1 1
  2 1 2
  5 5
  2 2 2 2 2
  2 1 1 1 2
  2 1 2 1 2
  2 1 1 1 2
  2 2 2 2 2
  1 3
  1 2 1""""""
      force_no_file = False
      in_file_name = '' if force_no_file else 'B-large.in'
      base_path = 'G:/workspace/py/codejam2013/RQ/'
      if in_file_name:
          with open(base_path + in_file_name) as f:
              raw = f.read()
      else:
          raw = test_input
      out = main(raw)
      if in_file_name:
          with open(base_path + in_file_name + '.out', 'w') as f:
              f.write(out)
      pass
",541," 
  def ss(t, amap, lbcap):
      l = 0
      for m in amap:
          if len(m) == 1 and t == m.keys()[0]:
              l += m[t]
              for b in lbcap:
                  if t in b:
                      b[t] -= 1
                      if b[t] == 0:
                          b.pop(t)
              m.clear()
      return l           
  
  
  def solve(sea, in_lines):
      print = 'Case #%d: '%sea
   
      rn, cin = [int(xxx) for xxx in in_lines[0].split()]
      mtx = []
      for i in xrange(rn):
          mtx.append([int(xxx) for xxx in in_lines[i+1].split()])
      capper = [{} for xxx in xrange(rn)]
      cmap = [{} for xxx in xrange(cin)]
      td = {}
      
      for i in xrange(rn):
          for j in range(cin):
              k = mtx[i][j]
              if k in capper[i]:
                  capper[i][k] += 1
              else:
                  capper[i][k] = 1
              if k in cmap[j]:
                  cmap[j][k] += 1
              else:
                  cmap[j][k] = 1
              if k in td:
                  td[k] += 1
              else:
                  td[k] = 1
                  
      while len(td):
          k = min(td.keys())
          sb = ss(k, capper, cmap)
          sb += ss(k, cmap, capper)
          if sb == 0:
              break;
          td[k] -= sb
          if td[k] == 0:
              td.pop(k)
  
      return print + ('YES' if sb else 'NO')
  
  
  def main(cooked):
      lines = cooked.split('
')
      conn = int(lines[0])
      ln = 1
      outs = []
      for sea in xrange(1, conn+1):
          shell = []
          cl = int(lines[ln].split()[0]) + ln + 1
          while ln < cl and lines[ln]:
              shell.append(lines[ln])
              ln += 1
          l = solve(sea, shell)
          print l
          outs.append(l)
      return '
'.join(outs)
      pass
  
  if __name__ == '__main__':
      test_input = """"""4
  4 3
  2 5 2
  1 1 1
  2 4 2
  2 3 2
  3 3
  2 1 2
  1 1 1
  2 1 2
  5 5
  2 2 2 2 2
  2 1 1 1 2
  2 1 2 1 2
  2 1 1 1 2
  2 2 2 2 2
  1 3
  1 2 1""""""
      force_no_file = False
      in_file_name = '' if force_no_file else 'B-large.in'
      base_path = 'G:/workspace/py/codejam2013/RQ/'
      if in_file_name:
          with open(base_path + in_file_name) as f:
              cooked = f.read()
      else:
          cooked = test_input
      print = main(cooked)
      if in_file_name:
          with open(base_path + in_file_name + '.out', 'w') as f:
              f.write(print)
      pass
",LABEL_5,LABEL_5,LABEL_16,1,"t,amap,bmap,s,m,b,case,in_lines,out,rn,cn,x,mtx,i,rmap,cmap,td,j,k,sb,raw,lines,n,ln,outs,buff,cl","t:0.7351916432380676,amap:0.7887160331010818,bmap:0.7950010448694229,s:0.7896426618099213,m:0.5664421916007996,b:0.7016766965389252,case:0.8374691158533096,in_lines:0.7227151095867157,out:0.7993168383836746,rn:0.6929703056812286,cn:0.8089004904031754,x:0.7954751998186111,mtx:0.779158741235733,i:0.7403028607368469,rmap:0.8041308224201202,cmap:0.7938613295555115,td:0.7078608572483063,j:0.7178719341754913,k:0.6558138728141785,sb:0.717764675617218,raw:0.8345997184514999,lines:0.653319388628006,n:0.803754448890686,ln:0.7658778578042984,outs:0.6759026646614075,buff:0.7950705289840698,cl:0.7898859530687332,",1,6,"case:sea,raw:cooked,cn:cin,rmap:capper,n:conn,out:print,x:xxx,buff:shell,bmap:lbcap,",0,0,Greedy,265,0.10142430067062377,replace,[],0.9851792454719543,0.23091855645179749
11," 
  def solve(icase, case_input):
      case_output = 'Case #%i: '%icase
      
      result = 0
      raw = [int(x) for x in case_input[0].split()]
      ts = raw[3:]
      ct = raw[1]
      n = raw[2]
      cc = 0
      for i in ts:
          if i > 3*n-3:
              result += 1
          elif i > max(3*n-5, 0):
              cc += 1
      result += min(cc, ct)
  
      case_output += '%d'%result
      
      return case_output
  
  
  def main():
      global use_test_data
      global test_data
      global input_file
      global output_file
      
      if use_test_data:
          data = [x.strip() for x in test_data.split('
')]
      else:
          data = [x.strip() for x in input_file.readlines()]
      
      T = int(data[0])
      iLine = 1
      caseLineNum = 1
      for icase in range(1, T + 1):
          input = []
          for i in range(caseLineNum):
              input.append(data[iLine])
              iLine += 1
          rslt = solve(icase, input)
          print rslt
          if not use_test_data:
              print >> output_file, rslt
      
      if not use_test_data:
          input_file.close()
          output_file.close()
      
      
  if __name__ == '__main__':
      test_data = """"""4
  3 1 5 15 13 11
  3 0 8 23 22 21
  2 1 1 8 0
  6 2 8 29 20 8 18 18 21
  """"""
      use_test_data = False
      
      test_file = 'B-small-attempt0.in'
      if not use_test_data and '' != test_file:
          input_file = open(test_file)
          output_file = open(test_file + '.out', 'w')
      
      main()
",284," 
  def solve(unicases, case_source):
       case_final = 'Case #%i: '%unicases
      
      runner = 0
       Raw = [int(rx) for rx in case_source[0].split()]
      tests =  Raw[3:]
      case =  Raw[1]
      n =  Raw[2]
      cas = 0
      for ip in tests:
          if ip > 3*n-3:
              runner += 1
          elif ip > max(3*n-5, 0):
              cas += 1
      runner += min(cas, case)
  
       case_final += '%d'%runner
      
      return  case_final
  
  
  def main():
      global use_case_function
      global testcasewindow
      global input_files
      global input_directory
      
      if use_case_function:
          image = [rx.strip() for rx in testcasewindow.split('
')]
      else:
          image = [rx.strip() for rx in input_files.readlines()]
      
      J = int(image[0])
      iLine = 1
      caseRowNum = 1
      for unicases in range(1, J + 1):
          pull = []
          for ip in range(caseRowNum):
              pull.append(image[iLine])
              iLine += 1
          rslt = solve(unicases, pull)
          print rslt
          if not use_case_function:
              print >> input_directory, rslt
      
      if not use_case_function:
          input_files.close()
          input_directory.close()
      
      
  if __name__ == '__main__':
      testcasewindow = """"""4
  3 1 5 15 13 11
  3 0 8 23 22 21
  2 1 1 8 0
  6 2 8 29 20 8 18 18 21
  """"""
      use_case_function = False
      
      test_files = 'B-small-attempt0.in'
      if not use_case_function and '' != test_files:
          input_files = open(test_files)
          input_directory = open(test_files + '.out', 'w')
      
      main()
",LABEL_5,LABEL_5,LABEL_52,1,"icase,case_input,case_output,result,raw,x,ts,ct,n,cc,i,data,T,iLine,caseLineNum,input,rslt,test_data,use_test_data,test_file,input_file,output_file","icase:0.633082240819931,case_input:0.5847237408161163,case_output:0.6916196942329407,result:0.6575275957584381,raw:0.6528555452823639,x:0.6442767381668091,ts:0.6315615177154541,ct:0.6349665224552155,n:0.6280600130558014,cc:0.6317428350448608,i:0.6316015422344208,data:0.6274160444736481,T:0.6259823143482208,iLine:0.6402570605278015,caseLineNum:0.6176918745040894,input:0.6341217458248138,rslt:0.6146330535411835,test_data:0.6319906711578369,use_test_data:0.6590684950351715,test_file:0.6333713531494141,input_file:0.6261794567108154,output_file:0.6041935682296753,",1,2,"case_output: case_final,use_test_data:use_case_function,result:runner,raw: Raw,x:rx,ct:case,input:pull,test_file:test_files,icase:unicases,test_data:testcasewindow,cc:cca,i:ip,ts:tests,data:image,input_file:input_files,T:J,caseLineNum:caseRowNum,output_file:input_directory,",0,0,Greedy,442,0.1623448888460795,replace,[],0.9236829876899719,0.28903597593307495
12," 
  T = input()
  
  for n in range(1, T+1):
  
      A, B = raw_input().split()
      A, B = int(A), int(B)
  
      j = 0
      for i in range(A, B+1):
          s = str(i)
          m = int(i**.5)
          if s[-1] in [""1"", ""4"", ""5"", ""6"", ""9""] and \
                  (s == """".join(reversed(s))) and \
                  m**2 == i:
              s = str(m)
              if s == """".join(reversed(s)):
                  j += 1
  
  
      print ""Case #%d: %d"" % (n, j)
",139,,LABEL_6,LABEL_10,,-4,"T,n,A,B,j,i,s,m",,,,,0,0,Greedy,1,0.0005543390909830729,,,0.4550589323043823,0.4550589323043823
13," 
  T=0 #no. of Test cases
  for line in fileinput.input():
      if fileinput.isfirstline():
          T=int(line)
          print ""no. of test cases:"", T
          continue
      
      nums=[int(x) for x in line.split()]
      N=nums[0] #no. of googlers
      S=nums[1] #no. of surprising triplets
      p=nums[2] #max value
      
      del nums[:3]
      count=0
      for num in nums:
          quo=num//3
          rem=num%3
          if quo >= p:
              count += 1
              continue
          elif quo+1 == p and rem > 0:
              count += 1
              continue
          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:
              count += 1
              S -= 1
              continue
          elif quo+2 >= p and rem == 2 and S > 0:
              count += 1
              S -= 1
      
      print ""Case #%(k)i: %(count)i"" % {""k"":fileinput.lineno()-1,""count"":count}
",177,,LABEL_6,LABEL_62,,-4,"T,line,nums,x,N,S,p,count,num,quo,rem",,,,,0,0,Greedy,1,0.0005518237749735515,,,0.25364887714385986,0.25364887714385986
14," 
  fin = open('C-small-attempt0.in', 'r')
  fout = open('ass3.out', 'w')
  
  T = int(fin.readline())
  
  def perfsq(n):
      sq = int(math.sqrt(n))
      if n == sq * sq:
          return sq
      return 0
  
  def palindrome(n):
      s = str(n)
      return (s == s[::-1])
  
  def getpal(n):
      if n == 1:
          for i in range(10):
              yield i
      else:
          n2 = n / 2
          for x in xrange(10 ** (n2 - 1), 10 ** n2):
              s = str(x)
              if n % 2:
                  for i in range(10):
                      ns = s + str(i) + s[::-1]
                      yield int(ns)
              else:
                  ns = s + s[::-1]
                  yield int(ns)
  
  for i in range(T):
      A, B = map(int, fin.readline().split())
  
      ret = 0
      for j in range(len(str(A)), len(str(B)) + 1):
          for x in getpal(j):
              if x < A:
                  continue
              if x > B:
                  break
              sq = perfsq(x)
              if sq and palindrome(sq):
                  ret += 1
      fout.write('Case #%i: %i
' % (i + 1, ret))
",288," 
  pen = open('C-small-attempt0.in', 'r')
   finner = open('ass3.out', 'w')
  
  TS = int(pen.readline())
  
  def perfsq(y):
      supp = int(math.sqrt(y))
      if y == supp * supp:
          return supp
      return 0
  
  def palindrome(y):
      sql = str(y)
      return (sql == sql[::-1])
  
  def getpal(y):
      if y == 1:
          for counter in range(10):
              yield counter
      else:
          n3 = y / 2
          for rax in xrange(10 ** (n3 - 1), 10 ** n3):
              sql = str(rax)
              if y % 2:
                  for counter in range(10):
                      nu = sql + str(counter) + sql[::-1]
                      yield int(nu)
              else:
                  nu = sql + sql[::-1]
                  yield int(nu)
  
  for counter in range(TS):
      Ax, WB = map(int, pen.readline().split())
  
      fit = 0
      for uj in range(len(str(Ax)), len(str(WB)) + 1):
          for rax in getpal(uj):
              if rax < Ax:
                  continue
              if rax > WB:
                  break
              supp = perfsq(rax)
              if supp and palindrome(supp):
                  fit += 1
       finner.write('Case #%i: %i
' % (counter + 1, fit))
",LABEL_7,LABEL_7,,-1,"fin,fout,T,n,sq,s,i,n2,x,ns,A,B,ret,j","fin:0.43082892894744873,fout:0.2365848422050476,T:0.21293586492538452,n:0.21851009130477905,sq:0.23281073570251465,s:0.2097451090812683,i:0.20391511917114258,n2:0.2282758355140686,x:0.21093714237213135,ns:0.19947218894958496,A:0.228643536567688,B:0.23795968294143677,ret:0.23816120624542236,j:0.21174383163452148,",0,0,"fin:pen,ret:fit,B:WB,fout: finner,sq:supp,A:Ax,n2:n3,n:y,T:TS,j:uj,x:rax,s:sql,i:counter,ns:nu,",0,0,Greedy,293,0.1073539694150289,failed,[],0.8560233116149902,0.3886953294277191
15,"input_file = 'B-small-attempt1.in'
  output_file = 'b.out'
  
  
  def solvecase(inp):
  	data = [int(n) for n in inp.split()]
  	N, S, p = data[0:3]
  	if p == 0:
  		return N
  	t = data[3:]
  	ret = 0
  	for br in t:
  		d, r = br / 3, br % 3
  		if br == 0 or p - d > 2:
  			continue
  		if (d >= p) or (r and (d + 1) >= p):
  			ret += 1
  		elif S and (d + max(r, 1)) >= p:
  			ret += 1
  			S -= 1
  	return ret
  
  lines = open(input_file, 'r').readlines()
  out = open(output_file, 'w')
  
  for i, l in enumerate(lines[1:]):
  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))
  	print sout
  	out.write(sout + '
')
  
  out.close()
",194,"dataodename = 'B-small-attempt1.in'
   output_filename = 'b.out'
  
  
  def solvecase(Inp):
  	frame = [int(num) for num in Inp.split()]
  	Data, range, lp = frame[0:3]
  	if lp == 0:
  		return Data
  	name = frame[3:]
  	ret = 0
  	for bl in name:
  		 D, min = bl / 3, bl % 3
  		if bl == 0 or lp -  D > 2:
  			continue
  		if ( D >= lp) or (min and ( D + 1) >= lp):
  			ret += 1
  		elif range and ( D + max(min, 1)) >= lp:
  			ret += 1
  			range -= 1
  	return ret
  
  lo = open(dataodename, 'r').readlines()
  pool = open( output_filename, 'w')
  
  for part, j in enumerate(lo[1:]):
  	sprintf = 'Case #%i: %i' % (part + 1, solvecase(j))
  	print sprintf
  	pool.write(sprintf + '
')
  
  pool.close()
",LABEL_7,LABEL_7,,-1,"input_file,output_file,inp,data,n,N,S,p,t,ret,br,d,r,lines,out,i,l,sout","input_file:0.3796612620353699,output_file:0.21199041604995728,inp:0.35785824060440063,data:0.26225781440734863,n:0.2123928666114807,N:0.24458420276641846,S:0.13244205713272095,p:0.16558945178985596,t:0.24081552028656006,ret:0.13943105936050415,br:0.28987330198287964,d:0.2118600606918335,r:0.1623469591140747,lines:0.1411733627319336,out:0.1824083924293518,i:0.1536054015159607,l:0.19263023138046265,sout:0.269822895526886,",0,0,"input_file:dataodename,inp:Inp,br:bl,sout:sprintf,data:frame,N:Data,t:name,n:x,output_file: output_filename,d: D,l:j,out:pool,p:span,r:j,i:li,lines:lo,S:range,",0,0,Greedy,375,0.13556059201558432,failed,[],0.9158436059951782,0.4774962365627289
16," a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]
  A = a[:10]
  def subdfs(pre, mid, d, t, n):
      if d == t:
          k = long(''.join([pre, mid, pre[::-1]]))
          k = k * k
          if k > n:
              return [1, 0]
          sqk = str(k)
          if sqk == sqk[::-1]:
              A.append(k)
              return [0, 1]
          else:
              return [0, 0]
      res = subdfs(pre + '0', mid, d + 1, t, n)
      if res[0]: return res
      if not res[1]: return res
      res2 = subdfs(pre + '1', mid, d + 1, t, n)
      if res2[0]: return [1, res[1] + res2[1]]
      return [0, res[1] + res2[1]]
  
  def dfs(d, n):
      subdfs('1', '', 0, d, n)
      subdfs('2' + '0' * d, '', d, d, n)
      subdfs('1', '0', 0, d, n)
      subdfs('1', '1', 0, d, n)
      subdfs('1', '2', 0, d, n)
      subdfs('2' + '0' * d, '0', d, d, n)
      subdfs('2' + '0' * d, '1', d, d, n)
  
  def solve(pre):
      read_ints = lambda: map(int, raw_input().split())
      l, r = read_ints()
      cl = bisect_left(A, l)
      cr = bisect_right(A, r)
      cl_ = cr_ = 0
      for i in xrange(40):
          if a[i] < l: cl_ += 1
      for i in xrange(40):
          if a[i] <= r: cr_ += 1
      print pre, cr - cl
  
  for k in xrange(1, 48):
      dfs(k, 10 ** 100 + 1)
  A.sort()
  N = int(raw_input())
  for i in xrange(1, N + 1):
      solve(""Case #%d:"" % i)
",521,,LABEL_8,LABEL_22,,-4,"a,A,pre,mid,d,t,n,k,sqk,res,res2",,,,,0,0,Greedy,1,0.0006825208663940429,,,0.24984098970890045,0.24984098970890045
17,"T = int(raw_input())
  for t in xrange(T):
      line = map(int, raw_input().split())
      N, S, p = line[0:3]
      a = line[3:]
      cnt = 0
      a.sort(reverse=True)
      for x in a:
          if (x + 2) / 3 >= p:
              cnt += 1
          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:
              cnt += 1
              S -= 1
          else:
              break
      print ""Case #%d: %d"" % (t + 1, cnt)
",119,,LABEL_8,LABEL_38,,-4,"T,t,line,N,S,p,a,cnt,x",,,,,0,0,Greedy,1,0.0005175987879435221,,,0.3933229148387909,0.3933229148387909
18,"def isPalindrome(number):
      strNum = str(number)
      for i in range(len(strNum)/2 + 1):
          if strNum[i] != strNum[-1*(i+1)]:
              return False
      return True
  
  '''for i in range(40):
      if isPalindrome(i) and isPalindrome(i*i):
          print i*i
  '''
  
  
  filename = ""C-small-attempt0.in""
  outputname = filename + ""out.txt""
  
  inFile = open(filename, 'r')
  outFile = open(outputname, 'w')
  
  
  fairAndSquareNums = [1,4,9,121,484]
  
  numTests = int(inFile.readline())
  
  for i in range(numTests):
      line = inFile.readline().split()
      count = 0
      for j in range(int(line[0]), int(line[1])+1):
          if j in fairAndSquareNums:
              count += 1
      outFile.write(""Case #"" + str(i+1) + "": "" + str(count) + '
')
      print ""Case #"" + str(i+1) + "": "" + str(count)
  
  inFile.close()
  outFile.close()
",199,"def isPalindrome(unit):
       strnum = str(unit)
      for i in range(len( strnum)/2 + 1):
          if  strnum[i] !=  strnum[-1*(i+1)]:
              return False
      return True
  
  '''for i in range(40):
      if isPalindrome(i) and isPalindrome(i*i):
          print i*i
  '''
  
  
  management = ""C-small-attempt0.in""
   outputfilename = management + ""out.txt""
  
   inStream = open(management, 'r')
  offFile = open( outputfilename, 'w')
  
  
  fairAndSquareCumbers = [1,4,9,121,484]
  
  numTests = int( inStream.readline())
  
  for i in range(numTests):
      line =  inStream.readline().split()
      count = 0
      for j in range(int(line[0]), int(line[1])+1):
          if j in fairAndSquareCumbers:
              count += 1
      offFile.write(""Case #"" + str(i+1) + "": "" + str(count) + '
')
      print ""Case #"" + str(i+1) + "": "" + str(count)
  
   inStream.close()
  offFile.close()
",LABEL_9,LABEL_9,LABEL_17,1,"number,strNum,i,filename,outputname,inFile,outFile,fairAndSquareNums,numTests,line,count,j","number:0.3981555998325348,strNum:0.3902342617511749,i:0.3557257652282715,filename:0.7126378864049911,outputname:0.5936146974563599,inFile:0.3704238533973694,outFile:0.37785831093788147,fairAndSquareNums:0.3763198256492615,numTests:0.33827775716781616,line:0.2899198532104492,count:0.31491827964782715,j:0.3673968017101288,",1,4,"filename:management,outputname: outputfilename,number:unit,strNum: strnum,outFile:offFile,fairAndSquareNums:fairAndSquareCumbers,",0,0,Greedy,153,0.05585470199584961,replace,[],0.8557852506637573,0.371806263923645
19,"inputFile = open(""B-small-attempt0 (3).in"", 'r')
  outputFile = open(""dancingOutSmall.txt"", 'w')
  numTests = int(inputFile.readline())
  
  def countDancers(n,s,p,totals):
      guaranteed = 0
      needSurprise = 0
      if p == 1:
          for total in totals:
              if total != 0:
                  guaranteed += 1
          return guaranteed
      for total in totals:
          if total >= p*3 - 2:
              guaranteed += 1
          elif total >= p*3 - 4:
              needSurprise += 1
      if needSurprise > s:
          return guaranteed + s
      else:
          return guaranteed + needSurprise
  
  for i in range(numTests):
      line = inputFile.readline().split()
      n = int(line[0])
      s = int(line[1])
      p = int(line[2])
      totals = []
      for j in range(n):
          totals += [int(line[3+j])]
      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '
')
  
  outputFile.close()
",215," inputDirectory = open(""B-small-attempt0 (3).in"", 'r')
   outputFiles = open(""dancingOutSmall.txt"", 'w')
  numPatcases = int( inputDirectory.readline())
  
  def countDancers(name,us,t,Tiotalls):
      guafeal = 0
      needSurface = 0
      if t == 1:
          for note in Tiotalls:
              if note != 0:
                  guafeal += 1
          return guafeal
      for note in Tiotalls:
          if note >= t*3 - 2:
              guafeal += 1
          elif note >= t*3 - 4:
              needSurface += 1
      if needSurface > us:
          return guafeal + us
      else:
          return guafeal + needSurface
  
  for uri in range(numPatcases):
      key =  inputDirectory.readline().split()
      name = int(key[0])
      us = int(key[1])
      t = int(key[2])
      Tiotalls = []
      for job in range(name):
          Tiotalls += [int(key[3+job])]
       outputFiles.write('Case #' + str(uri+1) + ': ' + str(countDancers(name,us,t,Tiotalls)) + '
')
  
   outputFiles.close()
",LABEL_9,LABEL_9,,-1,"inputFile,outputFile,numTests,n,s,p,totals,guaranteed,needSurprise,total,i,line,j","inputFile:0.7614652216434479,outputFile:0.5618084073066711,numTests:0.549723893404007,n:0.4572726786136627,s:0.44443559646606445,p:0.4435955286026001,totals:0.4679149389266968,guaranteed:0.4458150267601013,needSurprise:0.5100125074386597,total:0.4253343343734741,i:0.44573086500167847,line:0.48874008655548096,j:0.46933791041374207,",0,0,"inputFile: inputDirectory,outputFile: outputFiles,numTests:numPatcases,needSurprise:needSurface,line:key,j:v,totals:Tiotalls,n:init,guaranteed:guafeal,i:uri,s:us,p:t,total:quant,",0,0,Greedy,271,0.09824858903884888,failed,[],0.9564403295516968,0.44093531370162964
20," 
  n_cases = input()
  
  def to_ints(s):
      return map(int, s.split())
  
  def is_palindrome(n):
      s = str(n)
      return s == s[::-1]
  
  for case in xrange(1, n_cases + 1):
      a, b = to_ints(raw_input())
  
      nums = range(int(b ** .5) + 2)
      palins = filter(is_palindrome, nums)
      squares = [x**2 for x in palins]
      palin_squares = filter(is_palindrome, squares)
      range_squares = [x for x in palin_squares if a <= x <= b]
  
      print ""Case #%d: %s"" % (case, len(range_squares))
",132," 
  n_chains = input()
  
  def to_ints(speech):
      return map(int, speech.split())
  
  def is_palindrome(name):
      speech = str(name)
      return speech == speech[::-1]
  
  for section in xrange(1, n_chains + 1):
      p, fb = to_ints(raw_input())
  
       noms = range(int(fb ** .5) + 2)
      palins = filter(is_palindrome,  noms)
      squared = [sex**2 for sex in palins]
      palin_sqare = filter(is_palindrome, squared)
      range_Squeries = [sex for sex in palin_sqare if p <= sex <= fb]
  
      print ""Case #%d: %s"" % (section, len(range_Squeries))
",LABEL_10,LABEL_10,,-1,"n_cases,s,n,case,a,b,nums,palins,squares,x,palin_squares,range_squares","n_cases:0.7290923297405243,s:0.6749706566333771,n:0.7293171882629395,case:0.7513938546180725,a:0.7451647371053696,b:0.7054387927055359,nums:0.7574769556522369,palins:0.7309642881155014,squares:0.7278695702552795,x:0.742731437087059,palin_squares:0.65451979637146,range_squares:0.693845808506012,",0,0,"nums: noms,case:section,a:p,x:sex,n:name,n_cases:n_chains,squares:squared,b:fb,range_squares:range_Squeries,s:speech,palin_squares:palin_sqare,",0,0,Greedy,252,0.09022436539332072,failed,[],0.9793715476989746,0.5079084038734436
21,"n_cases = input()
  
  for case in xrange(1, n_cases + 1):
      ins = map(int, raw_input().strip().split())
      n = ins[0]
      s = ins[1]
      p = ins[2]
      t = ins[3:]
  
      out = 0
      for x in t:
          if (x + 2) / 3 >= p:
              out += 1
          elif s and x > p and p - ((x - p) / 2) <= 2:
              out += 1
              s -= 1
              
      print ""Case #%d: %s"" % (case, out)
",117," n_times = input()
  
  for config in xrange(1,  n_times + 1):
      ins = map(int, raw_input().strip().split())
      n = ins[0]
      s = ins[1]
      pr = ins[2]
      t = ins[3:]
  
      line = 0
      for v in t:
          if (v + 2) / 3 >= pr:
              line += 1
          elif s and v > pr and pr - ((v - pr) / 2) <= 2:
              line += 1
              s -= 1
              
      print ""Case #%d: %s"" % (config, line)
",LABEL_10,LABEL_10,LABEL_6,1,"n_cases,case,ins,n,s,p,t,out,x","n_cases:0.6159617602825165,case:0.629306972026825,ins:0.6034351587295532,n:0.5953676104545593,s:0.6046743988990784,p:0.6424550712108612,t:0.607752650976181,out:0.649399608373642,x:0.7092448472976685,",1,2,"x:v,out:line,p:pr,case:config,",0,0,Greedy,107,0.038687201340993245,replace,[],0.9502620100975037,0.8982269763946533
22,"'''
  Created on 13 Apr 2013
  
  @author: mengda
  '''
  
  ls = []
  
  def isP(num):
      num = str(int(num))
      for i in range(len(num) / 2):
          if num[i] <> num[-1 - i]:
              return False
      return True
  
  def createP(root, half_digits):
      root = str(root)
      for i in range(half_digits):
          ls[i] = root[i]
          ls[-1 - i] = root[i]
      return int(''.join(ls))
  
  def process(A, B):
      rlt = 0
      a = int(math.ceil(math.sqrt(A)))
      b = int(math.floor(math.sqrt(B)))
      str_a = str(a)
      half_digits = int(math.ceil(len(str_a) / 2.0))
      root = int(str_a[:half_digits])
      next_root = 10 ** half_digits
      digits = len(str_a)
      for _ in range(digits - len(ls)):
          ls.append('')
      while True:
          if root == next_root:
              if digits % 2 == 0:
                  next_root *= 10
                  half_digits += 1
              else:
                  root /= 10
              digits += 1
              ls.append('')
          p = createP(root, half_digits)
          print p,
          if p > b:
              print 'too large'
              break
          if isP(math.pow(p, 2)):
              print 'right one!'
              rlt += 1
          else:
              print 
          root += 1
      return rlt
  
  def process1(A, B):
      rlt = 0
      a = int(math.ceil(math.sqrt(A)))
      b = int(math.floor(math.sqrt(B)))
      for i in range(a, b + 1):
          if not isP(i):
              continue
          power = math.pow(i, 2)
          if isP(power):
              rlt += 1
      return rlt
  
  f = open('C-small-attempt1.in', 'r')
  T = int(f.readline())
  outLine = []
  
  for i in range(1, T + 1):
      (A, B) = map(int, f.readline().split())
      outLine.append('Case #%d: %s
' % (i, process1(A, B)))
      print outLine[-1],
  
  f.close()
  outFile = open('C-S.out', 'w')
  outFile.writelines(outLine)
  outFile.close()
",476,,LABEL_11,LABEL_32,,-4,"ls,num,i,root,half_digits,A,B,rlt,a,b,str_a,next_root,digits,_,p,power,f,T,outLine",,,,,0,0,Greedy,1,0.0006652911504109701,,,0.8993030190467834,0.8993030190467834
23,"'''
  Created on 2012-4-14
  
  @author: hemnd
  '''
  def cal(args):
      rslt = 0
      N = int(args[0])
      S = int(args[1])
      p = int(args[2])
      for i in range(N):
          s = int(args[i + 3])
          e = s / 3
          r = s % 3
          if e >= p:
              rslt += 1
          elif r == 1:
              if e + 1 >= p:
                  rslt += 1
          elif r == 0:
              if e == 0:
                  continue
              if S > 0 and e + 1 >= p:
                  rslt += 1
                  S -= 1
          elif r == 2:
              if e + 1 >= p:
                  rslt += 1
              elif S > 0 and e + 2 >= p:
                  rslt += 1
                  S -= 1
      return rslt
  
  inputFile = open('B-small-attempt0.in', 'r')
  inputLines = inputFile.readlines()
  inputFile.close()
  
  T = int(inputLines[0])
  outputLines = []
  
  for i in range(1, T + 1):
      args = inputLines[i].strip().split(' ')
      outputLines.append('Case #%d: %d
' % (i, cal(args)))
      print outputLines[i - 1],
  
  outputFile = open('B-small.out', 'w')
  outputFile.writelines(outputLines)
  outputFile.close()
",254,"'''
  Created on 2012-4-14
  
  @author: hemnd
  '''
  def cal(alls):
      rsnat = 0
      A = int(alls[0])
      Fs = int(alls[1])
      api = int(alls[2])
      for t in range(A):
          es = int(alls[t + 3])
          z = es / 3
          rb = es % 3
          if z >= api:
              rsnat += 1
          elif rb == 1:
              if z + 1 >= api:
                  rsnat += 1
          elif rb == 0:
              if z == 0:
                  continue
              if Fs > 0 and z + 1 >= api:
                  rsnat += 1
                  Fs -= 1
          elif rb == 2:
              if z + 1 >= api:
                  rsnat += 1
              elif Fs > 0 and z + 2 >= api:
                  rsnat += 1
                  Fs -= 1
      return rsnat
  
  outputfile = open('B-small-attempt0.in', 'r')
  inputBlues = outputfile.readlines()
  outputfile.close()
  
  n = int(inputBlues[0])
  outputLines = []
  
  for t in range(1, n + 1):
      alls = inputBlues[t].strip().split(' ')
      outputLines.append('Case #%d: %d
' % (t, cal(alls)))
      print outputLines[t - 1],
  
  outputFile = open('B-small.out', 'w')
  outputFile.writelines(outputLines)
  outputFile.close()
",LABEL_11,LABEL_11,,-1,"args,rslt,N,S,p,i,s,e,r,inputFile,inputLines,T,outputLines","args:0.6111980378627777,rslt:0.5881706178188324,N:0.6037082672119141,S:0.5729127824306488,p:0.6000794470310211,i:0.6457249224185944,s:0.6378474086523056,e:0.5991157591342926,r:0.6136323511600494,inputFile:0.6458342373371124,inputLines:0.531824141740799,T:0.5660030245780945,outputLines:0.5301570296287537,",0,0,"inputFile:outputfile,i:t,s:es,r:rb,args:alls,N:A,p:api,e:j,rslt:rsnat,S:Fs,T:I,inputLines:inputBlues,",0,0,Greedy,267,0.09812917709350585,failed,[],0.8814392685890198,0.7885571718215942
24," 
  
  
  def next_range(stream):
      line = stream.readline()
      if not line:
          return None
      return [int(x) for x in line.split()]
  
  
  def is_palindrome(n):
      n = str(n)
      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))
  
  def mysqrt(n):
      """"""Return -1 if not an integer""""""
      rt = int(sqrt(n))
      return rt if rt * rt == n else -1
  
  
  def is_fas(n):
      rt = mysqrt(n)
      return rt != -1 and is_palindrome(n) and is_palindrome(rt)
  
  
  def main():
      with open('C-small-attempt0.in', encoding='utf-8') as f:
          f.readline()
  
          for case in count(1):
              r = next_range(f)
              if r is None:
                  break
  
              cnt = 0
              for n in range(r[0], r[1] + 1):
                  if is_fas(n):
                      cnt += 1
  
              print('Case #{}: {}'.format(case, cnt))
  
  
  main()
",217," 
  
  
  def next_range(log):
      feed = log.readline()
      if not feed:
          return None
      return [int(bit) for bit in feed.split()]
  
  
  def is_palindrome(int):
      int = str(int)
      return all(int[i] == int[len(int)-1-i] for i in range(len(int) // 2))
  
  def mysqrt(int):
      """"""Return -1 if not an integer""""""
      art = int(sqrt(int))
      return art if art * art == int else -1
  
  
  def is_fas(int):
      art = mysqrt(int)
      return art != -1 and is_palindrome(int) and is_palindrome(art)
  
  
  def main():
      with open('C-small-attempt0.in', encoding='utf-8') as f:
          f.readline()
  
          for rice in count(1):
              error = next_range(f)
              if error is None:
                  break
  
               cno = 0
              for int in range(error[0], error[1] + 1):
                  if is_fas(int):
                       cno += 1
  
              print('Case #{}: {}'.format(rice,  cno))
  
  
  main()
",LABEL_12,LABEL_12,,-1,"stream,line,x,n,i,rt,case,r,cnt","stream:0.8293489217758179,line:0.8090653792023659,x:0.7959374561905861,n:0.8212633803486824,i:0.7912929281592369,rt:0.8014314919710159,case:0.8199225887656212,r:0.8014235347509384,cnt:0.7921952083706856,",0,0,"stream:log,n:int,case:rice,line:inline,rt:art,r:error,x:bit,cnt: cno,",0,0,Greedy,186,0.0677593986193339,failed,[],0.9126874208450317,0.733617901802063
25," 
  
  def best(total):
      """"""Return the best possible score for the given `total`.  Assume
      the total is computed by summing exactly three scores (each in the
      interval of 0 to 10 inclusive) and no score can be 2 points apart
      
      Arguments:
      - `total`:
      """"""
      m = total % 3
      if m == 2:
          b = total // 3 + 2
      else:
          b = total // 3 + 1
      if b > 10:
          b = 10
      return b
  
  def best_non_surprising(total):
      """"""Return the best possible score for the given `total`, but
      assume that there should be no more than 1 point difference
      between the scores.
  
      Arguments:
      - `total`:
      """"""
      if total % 3 == 0:
          return total // 3
      else:
          return total // 3 + 1
  
  def max_num_gte_p(totals, S, p):
      """"""Return the maximum number of Googlers that could have had a
      best result of at least p.
      
      Arguments:
      - `totals`:
      - `S`: number of surprising triplets of scores
      - `p`:
      """"""
      res = 0
      for total in totals:
          if total == 0:
              if p == 0:
                  res += 1
              continue
  
          if best_non_surprising(total) >= p:
              res += 1
          elif S > 0 and best(total) >= p:
              res += 1
              S -= 1
  
      return res
  
  def main():
      with open(sys.argv[1], 'r') as f:
          f.readline()            # skip T
  
          n = 0
          for line in f:
              n += 1
  
              line = [int(s) for s in line.split()]
              N = line[0]
              S = line[1]
              p = line[2]
              totals = line[3:]
  
              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))
  
  if __name__ == '__main__':
      main()
",230,,LABEL_12,LABEL_30,,-4,"total,m,b,totals,S,p,res,n,line,s,N",,,,,0,0,Greedy,1,0.000592490037282308,,,0.09176523983478546,0.09176523983478546
26," 
  def read(f):
      return list( int(v) for v in f.readline().split() )
  
  def answer(f, X, ans):
      out = ""Case #{}: {}"".format(X, ans)
      f.write(out)
      f.write(""
"")
      print(out)
  
  def testcases(f):
      T = int(f.readline())
      for X in range(1, T + 1):
          A, B = read(f)
          yield X, A, B
  
  def ispalindrome(v):
      s = str(v)
      for i in range(len(s) // 2):
          if s[i] != s[-i-1]:
              return False
      return True
  
  def main(inf, outf):
      MAX = 1000
      fslst = []
      for i in itertools.count():
          if ispalindrome(i):
              squere = i * i
              print(MAX, squere, ispalindrome(squere))
              if squere > MAX:
                  break
              if ispalindrome(squere):
                  fslst.append(squere)
      for X, A, B in testcases(inf):
          cnt = 0
          for fs in fslst:
              if A <= fs <= B:
                  cnt += 1
          answer(outf, X, cnt)
  
  if __name__==""__main__"":
      infname = sys.argv[1]
      outfname = os.path.splitext(infname)[0] + "".out""
      with open(infname, ""r"") as inf:
          with open(outfname, ""w"") as outf:
              main(inf, outf)
",303," 
  def read(lf):
      return list( int(int) for int in lf.readline().split() )
  
  def answer(lf, H, AU):
      Out = ""Case #{}: {}"".format(H, AU)
      lf.write(Out)
      lf.write(""
"")
      print(Out)
  
  def testcases(lf):
      TF = int(lf.readline())
      for H in range(1, TF + 1):
           a, WB = read(lf)
          yield H,  a, WB
  
  def ispalindrome(int):
      ves = str(int)
      for phi in range(len(ves) // 2):
          if ves[phi] != ves[-phi-1]:
              return False
      return True
  
  def main(qq, offb):
      Q = 1000
      fsnst = []
      for phi in itertools.count():
          if ispalindrome(phi):
               queb = phi * phi
              print(Q,  queb, ispalindrome( queb))
              if  queb > Q:
                  break
              if ispalindrome( queb):
                  fsnst.append( queb)
      for H,  a, WB in testcases(qq):
          Cnn = 0
          for feed in fsnst:
              if  a <= feed <= WB:
                  Cnn += 1
          answer(offb, H, Cnn)
  
  if __name__==""__main__"":
      ifnames = sys.argv[1]
       outfsize = os.path.splitext(ifnames)[0] + "".out""
      with open(ifnames, ""r"") as qq:
          with open( outfsize, ""w"") as offb:
              main(qq, offb)
",LABEL_13,LABEL_13,,-1,"f,v,X,ans,out,T,A,B,s,i,inf,outf,MAX,fslst,squere,cnt,fs,infname,outfname","f:0.8231159299612045,v:0.7803439497947693,X:0.8065520524978638,ans:0.7662816196680069,out:0.8146791458129883,T:0.7917603701353073,A:0.7027010023593903,B:0.7584224194288254,s:0.7709310352802277,i:0.7583848237991333,inf:0.7469075620174408,outf:0.714264303445816,MAX:0.6840189099311829,fslst:0.7233528196811676,squere:0.7176637947559357,cnt:0.7229177355766296,fs:0.6752970814704895,infname:0.7991927564144135,outfname:0.7222092151641846,",0,0,"f:lf,out:Out,X:H,infname:ifnames,T:Max,v:int,s:ves,ans:AU,B:WB,i:phi,inf:qq,fslst:fsnst,cnt:Cnn,outfname: outfsize,squere: queb,outf:offb,A:I,MAX:Q,fs:feed,",0,0,Greedy,393,0.14440325101216633,failed,[],0.9763304591178894,0.728792667388916
27," 
  def testcases():
      with open(sys.argv[1], ""r"") as f:
          f.readline()  # skip number of testcases
          for X, T in enumerate(f, 1):
              yield X, [int(t) for t in T.split()]
  
  def main():
      for X, T in testcases():
          N = T[0]   # the number of Googlers
          S = T[1]   # the number of surprising triplets of scores
          p = T[2]   # best result of at least
  
          y = 0
  
          for t in T[3:]:
              d, m = divmod(t, 3)
              if m == 0:
                  if p <= d:
                      y += 1
                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:
                      y += 1
                      S -= 1
              elif m == 1:
                  if p <= d + 1:
                      y += 1
              else:
                  if p <= d + 1:
                      y += 1
                  elif p <= d + 2 and S:
                      y += 1
                      S -= 1
  
          print(""Case #{:d}: {:d}"".format(X, y))
  
  if __name__==""__main__"":
      main()
",205," 
  def testcases():
      with open(sys.argv[1], ""r"") as f:
          f.readline()  # skip number of testcases
          for File, XT in enumerate(f, 1):
              yield File, [int( mt) for  mt in XT.split()]
  
  def main():
      for File, XT in testcases():
           n = XT[0]   # the number of Googlers
          SE = XT[1]   # the number of surprising triplets of scores
          j = XT[2]   # best result of at least
  
          yo = 0
  
          for  mt in XT[3:]:
              z, mn = divmod( mt, 3)
              if mn == 0:
                  if j <= z:
                      yo += 1
                  elif 0 <= z - 1 <= j <= z + 1 <= 10 and SE:
                      yo += 1
                      SE -= 1
              elif mn == 1:
                  if j <= z + 1:
                      yo += 1
              else:
                  if j <= z + 1:
                      yo += 1
                  elif j <= z + 2 and SE:
                      yo += 1
                      SE -= 1
  
          print(""Case #{:d}: {:d}"".format(File, yo))
  
  if __name__==""__main__"":
      main()
",LABEL_13,LABEL_13,,-1,"X,T,t,N,S,p,y,d,m","X:0.721632182598114,T:0.7486709505319595,t:0.7250267565250397,N:0.7327712029218674,S:0.7715931832790375,p:0.7277334034442902,y:0.7545202970504761,d:0.7080189138650894,m:0.6950244605541229,",0,0,"S:SE,y:yo,T:XT,N: n,p:j,t: mt,X:File,d:j,m:u,",0,0,Greedy,187,0.06804940303166708,failed,[],0.955909013748169,0.837693452835083
28," 
  def pal(s):
      for i in xrange(len(s)/2):
          if s[i] != s[-i-1]:
              return False
      return True
  
  def pal2(x, s):
      return pal(s) and pal(str(x*x))
  
  def E(k):
      return 10**k
  
  
  def CREATE_DATABASE(MAX):
      def init():
          yield 1
          yield 2
          yield 3
          yield 11
          yield 22
          for i in xrange(1, MAX):
              yield 1*E(2*i) + 1
              yield 1*E(2*i+1) + 1
              yield 2*E(2*i) + 2
              yield 2*E(2*i) + 2 + 1*E(i)
              yield 2*E(2*i+1) + 2
              
              
      heap = list(sorted(set(init())))
      for i in heap:
          print i
      heapq.heapify(heap)
      RES = []
      try:
          MAX_X = E(MAX)
          print ""MAX_X"", MAX_X
          while True:
              x = heapq.heappop(heap)
              RES.append(x)
              if x == 3:
                  continue
              if x > MAX_X:
                  break
              s = str(x)
              j = len(s) / 2
              shift = 1 if len(s) == 2*j else 0
              for i in xrange(j+1, MAX):
                  n = E(2*i-shift) + 1 + E(i-j) * x
                  if pal2(n,str(n)):
                      heapq.heappush(heap, n)
                  
      except KeyboardInterrupt:
          print ""stopped while x is"", x
      with open(""c.database"", 'w') as f:
          for i in sorted(RES + heap):
              f.write(""%i
""%i)
  
  def READ_DATABASE():
      with open(""c.database"", 'r') as f:
          return sorted(map(lambda x: int(x.strip())**2, f))
  DB = READ_DATABASE()
  
  def CASE(IN):
      def rstr(): return IN.readline().strip()
      def rint(): return int(rstr())
      def rints(): return map(int, rstr().split())
      def nrints(N): return [rints() for i in xrange(N)]
      A, B = rints()
      i = bisect_left(DB, A) 
      j = bisect_right(DB, B)
      return j-i
  
  def RUN(IN, OUT):
      t = int(IN.readline().strip())
      for i in xrange(1,t+1):
          OUT.write(""Case #%i: %s
"" % (i, CASE(IN)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",564,,LABEL_14,LABEL_24,,-4,"s,i,x,k,MAX,heap,RES,MAX_X,j,shift,n,DB,IN",,,,,0,0,Greedy,1,0.0007053653399149577,,,0.10968396812677383,0.10968396812677383
29," 
  
  
  D1 = {} # no suprize
  D2 = {} # surprize
  for i in xrange(0, 31):
      D1[i] = D2[i] = -1
  
  def precompute():
      for a in xrange(0, 11):
          for b in xrange(a, min(a+3,11)):
              for c in xrange(b, min(a+3,11)):
                  t = a+b+c
                  assert a <= b <= c <= a+2 and c <= 11
                  if c < a+2:
                      D1[t] = max(D1[t], c)
                  else: # that is, c == a+2, we have a suprize
                      D2[t] = max(D2[t], c)
  
  
  precompute()
  
  def case(S, P, ts):
      res_n = 0
      res_s = 0
      for t in ts:
          if D1[t] >= P:
              res_n+=1
          elif D2[t]>=P:
              res_s+=1
      return (res_n + min(res_s, S))
  
  
  def solve(fin, fout):
      T = int(fin.readline())
      for t in xrange(T):
          nums = map(int, fin.readline().strip().split("" ""))
          N, S, P = nums[:3]
          ts = nums[3:]
          assert len(ts) == N    
          fout.write(""Case #%i: %i
"" % (t+1, case(S,P,ts)) )
      return True
  
  if __name__ == ""__main__"":
      with open(sys.argv[1],'r') as fin:
          with open(sys.argv[2], 'w') as fout:
              solve(fin, fout)
",332," 
  
  
   DONE = {} # no suprize
  D2 = {} # surprize
  for i in xrange(0, 31):
       DONE[i] = D2[i] = -1
  
  def precompute():
      for a in xrange(0, 11):
          for b in xrange(a, min(a+3,11)):
              for c in xrange(b, min(a+3,11)):
                  t = a+b+c
                  assert a <= b <= c <= a+2 and c <= 11
                  if c < a+2:
                       DONE[t] = max( DONE[t], c)
                  else: # that is, c == a+2, we have a suprize
                      D2[t] = max(D2[t], c)
  
  
  precompute()
  
  def case(S, P, ts):
      res_n = 0
      res_s = 0
      for t in ts:
          if  DONE[t] >= P:
              res_n+=1
          elif D2[t]>=P:
              res_s+=1
      return (res_n + min(res_s, S))
  
  
  def solve(fin, fout):
      T = int(fin.readline())
      for t in xrange(T):
          nums = map(int, fin.readline().strip().split("" ""))
          N, S, P = nums[:3]
          ts = nums[3:]
          assert len(ts) == N    
          fout.write(""Case #%i: %i
"" % (t+1, case(S,P,ts)) )
      return True
  
  if __name__ == ""__main__"":
      with open(sys.argv[1],'r') as fin:
          with open(sys.argv[2], 'w') as fout:
              solve(fin, fout)
",LABEL_14,LABEL_14,LABEL_12,1,"D1,D2,i,a,b,c,t,S,P,ts,res_n,res_s,fin,fout,T,nums,N","D1:0.08229941874742508,D2:0.07920221984386444,i:0.04316294193267822,a:0.030004680156707764,b:0.0036075562238693237,c:0.02481299638748169,t:0.0033611804246902466,S:0.0001529008150100708,P:-0.014963939785957336,ts:-0.002282664179801941,res_n:0.027895629405975342,res_s:0.018553465604782104,fin:-0.03525930643081665,fout:-0.06293082237243652,T:-0.0027446597814559937,nums:-0.00844140350818634,N:-0.018362313508987427,",1,5,,0,0,Greedy,38,0.015844420591990153,replace,[],0.19867390394210815,0.19867390394210815
30," f   = file(sys.argv[1])
  out = file(sys.argv[2], 'w')
  
  caseCnt = int(f.readline())
  
  Num = [
  	0,
  	1,
  	4,
  	9,
  	121,
  	484,
  	10201,
  	12321,
  	14641,
  	40804,
  	44944,
  	1002001,
  	1234321,
  	4008004,
  	100020001,
  	102030201,
  	104060401,
  	121242121,
  	123454321,
  	125686521,
  	400080004,
  	404090404,
  	10000200001,
  	10221412201,
  	12102420121,
  	12345654321,
  	40000800004,
  	1000002000001,
  	1002003002001,
  	1004006004001,
  	1020304030201,
  	1022325232201,
  	1024348434201,
  	1210024200121,
  	1212225222121,
  	1214428244121,
  	1232346432321,
  	1234567654321,
  	4000008000004,
  	4004009004004,
  ]
  
  for case in range(1, caseCnt+1):
  	L, H = f.readline().split()
  	L = int(L); H = int(H)
  	assert L <= H
  	
  	for i in range(len(Num)):
  		if L <= Num[i]:
  			break
  	else:
  		print>>out, 'Case #%d:'%case, 0
  		continue
  
  	lb = i - 1
  
  	for i in range(1, len(Num)+1):
  		if H >= Num[len(Num)-i]:
  			break
  	else:
  		print>>out, 'Case #%d:'%case, 0
  		continue
  	ub = len(Num)-i
  		
  	print>>out, 'Case #%d:'%case, ub - lb
  
  out.close()
",262," f   = file(sys.argv[1])
  out = file(sys.argv[2], 'w')
  
  caseNCner = int(f.readline())
  
  Num = [
  	0,
  	1,
  	4,
  	9,
  	121,
  	484,
  	10201,
  	12321,
  	14641,
  	40804,
  	44944,
  	1002001,
  	1234321,
  	4008004,
  	100020001,
  	102030201,
  	104060401,
  	121242121,
  	123454321,
  	125686521,
  	400080004,
  	404090404,
  	10000200001,
  	10221412201,
  	12102420121,
  	12345654321,
  	40000800004,
  	1000002000001,
  	1002003002001,
  	1004006004001,
  	1020304030201,
  	1022325232201,
  	1024348434201,
  	1210024200121,
  	1212225222121,
  	1214428244121,
  	1232346432321,
  	1234567654321,
  	4000008000004,
  	4004009004004,
  ]
  
  for instance in range(1, caseNCner+1):
  	L, D = f.readline().split()
  	L = int(L); D = int(D)
  	assert L <= D
  	
  	for iw in range(len(Num)):
  		if L <= Num[iw]:
  			break
  	else:
  		print>>out, 'Case #%d:'%instance, 0
  		continue
  
  	ai = iw - 1
  
  	for iw in range(1, len(Num)+1):
  		if D >= Num[len(Num)-iw]:
  			break
  	else:
  		print>>out, 'Case #%d:'%instance, 0
  		continue
  	ub = len(Num)-iw
  		
  	print>>out, 'Case #%d:'%instance, ub - ai
  
  out.close()
",LABEL_15,LABEL_15,LABEL_65,1,"f,out,caseCnt,Num,case,L,H,i,lb,ub","f:0.698861613869667,out:0.6321559548377991,caseCnt:0.7825989127159119,Num:0.6918434798717499,case:0.746872752904892,L:0.7351862043142319,H:0.7474424540996552,i:0.7366969734430313,lb:0.7468053996562958,ub:0.7508155852556229,",1,6,"caseCnt:caseNCner,H:D,case:instance,lb:ai,",0,0,Greedy,131,0.04856868584950765,replace,[],0.8785408735275269,0.3374226987361908
31," 
  f = file(""B-small-attempt0.in"")
  w = file(""answer.txt"", ""w"")
  cnt = int(f.readline()[:-1])
  for no in range(cnt):
  	l = f.readline()[:-1].split()
  	T, s, p = map(int, l[:3])
  	ts = map(int, l[3:])
  	ns = p*3-2 if p*3-2 > 0 else 0
  	ss = p*3-4 if p*3-4 > 0 else 31
  	l = filter(lambda x: x<ns, ts)
  	c = min([len(filter(lambda x: x>=ss, l)), s])
  	
  	print>>w, ""Case #%d:""%(no+1), T-len(l)+c
  
  
",171," 
  f = file(""B-small-attempt0.in"")
  log = file(""answer.txt"", ""w"")
  conNT = int(f.readline()[:-1])
  for  loop in range(conNT):
  	les = f.readline()[:-1].split()
  	Time, ses, n = map(int, les[:3])
  	tes = map(int, les[3:])
  	ids = n*3-2 if n*3-2 > 0 else 0
  	r = n*3-4 if n*3-4 > 0 else 31
  	les = filter(lambda x: x<ids, tes)
  	ec = min([len(filter(lambda x: x>=r, les)), ses])
  	
  	print>>log, ""Case #%d:""%( loop+1), Time-len(les)+ec
  
  
",LABEL_15,LABEL_15,,-1,"f,w,cnt,no,l,T,s,p,ts,ns,ss,c","f:0.6954610496759415,w:0.6957680135965347,cnt:0.7006316930055618,no:0.7262018173933029,l:0.6888356655836105,T:0.7034506052732468,s:0.6841402053833008,p:0.700877383351326,ts:0.7101558297872543,ns:0.7304461598396301,ss:0.7149467617273331,c:0.6704756915569305,",0,0,"ns:ids,no: loop,ss:r,ts:Ts,T:Ts,p:n,cnt:conNT,w:log,l:v,s:r,c:cs,",0,0,Greedy,240,0.08628184000651042,failed,[],0.863273561000824,0.47346118092536926
32,"def check(a,b):
      c = 0
      n = 1
      for i in range(1,4):
          if i**2 >= a and i**2 <=b:
              c += 1
      if 44944 >= a and 44944 <= b:
          c += 1
      while n < 10:
          p1 = int('1'+'1'*n)**2
          if p1 >= a and p1 <=b:
              c += 1
          n += 1
  
  
      if 484 >= a and 484 <= b:
          c += 1
  
      n = 1
      while True:
          p2 = int('1'+'0'*n+'1')**2
          p3 = int('2'+'0'*n+'2')**2
          if p2 >= a and p2 <= b:
              c += 1
          else:
              break
          if p3 >= a and p3 <= b:
              c += 1
          else:
              continue
          n += 1
  
      n = 1
      while True:
          t = False
          for m in range(2,5):
              p4 = int('1'*m+'0'*n+'1'*m)**2
              if p4 >= a and p4 <= b:
                  c += 1
              else:
                  t = True
                  break
          if t:
              break
              
          n += 1
      return c
                  
  dat = raw_input().split()
  n = int(dat.pop(0))
  data = [int(e) for e in dat]
  
  for i in range(0, n*2, 2):
      a, b = data[i], data[i+1]
      print 'Case #%i: '%(i/2+1) + str(check(a,b)) 
  
      
",308,,LABEL_16,LABEL_22,,-4,"a,b,c,n,i,p1,p2,p3,t,m,p4,dat,data,e",,,,,0,0,Greedy,1,0.000607760747273763,,,0.3359684944152832,0.3359684944152832
33,"f = open('cj2.in','r')
  out = open('out1.txt','w')
  inp = [[int(n) for n in s.split()] for s in f.readlines()]
  
  def score_partition(score):
      poss = []
      if score == 0:
          return [[0,0,0]]
      if score == 1:
          return [[0,0,1]]
      if score % 3 == 0:
          poss.append([score/3,score/3,score/3])
          poss.append([score/3-1,score/3,score/3+1])
      if score % 3 == 1:
          poss.append([score/3, score/3,score/3+1])
          poss.append([score/3-1,score/3+1,score/3+1])
      if score % 3 == 2:
          poss.append([score/3,score/3+1,score/3+1])
          poss.append([score/3,score/3,score/3+2])
  
      return poss
  
  
  s = 0
  c = 1
  for e in inp[1:len(inp)]:
      count = 0
      surprises = e[1]
      s = 0
      p = e[2]
      for i in e[3:len(e)]:
          scores = score_partition(i)
          for j in scores: 
              if max(j) >= p:
                  if max(j)-min(j) == 2:
                      if s < surprises:
                          s +=1
                          count +=1
                          break
                  else:
                      count += 1
                      break
                  
      out.write('Case #'+str(c)+': '+str(count)+'
')
      c += 1
  
  out.close()
  f.close()
                  
          
      
      
  
      
",364,"ref = open('cj2.in','r')
  out = open('out1.txt','w')
   inv = [[int(n) for n in sec.split()] for sec in ref.readlines()]
  
  def score_partition(score):
      poss = []
      if score == 0:
          return [[0,0,0]]
      if score == 1:
          return [[0,0,1]]
      if score % 3 == 0:
          poss.append([score/3,score/3,score/3])
          poss.append([score/3-1,score/3,score/3+1])
      if score % 3 == 1:
          poss.append([score/3, score/3,score/3+1])
          poss.append([score/3-1,score/3+1,score/3+1])
      if score % 3 == 2:
          poss.append([score/3,score/3+1,score/3+1])
          poss.append([score/3,score/3,score/3+2])
  
      return poss
  
  
  sec = 0
  c = 1
  for e in  inv[1:len( inv)]:
      count = 0
      surprise = e[1]
      sec = 0
      p = e[2]
      for i in e[3:len(e)]:
          scores = score_partition(i)
          for j in scores: 
              if max(j) >= p:
                  if max(j)-min(j) == 2:
                      if sec < surprise:
                          sec +=1
                          count +=1
                          break
                  else:
                      count += 1
                      break
                  
      out.write('Case #'+str(c)+': '+str(count)+'
')
      c += 1
  
  out.close()
  ref.close()
                  
          
      
      
  
      
",LABEL_16,LABEL_16,LABEL_49,1,"f,out,inp,n,s,score,poss,c,e,count,surprises,p,i,scores,j","f:0.5064055770635605,out:0.32370641827583313,inp:0.45075300335884094,n:0.3630635142326355,s:0.41889265179634094,score:0.3665132522583008,poss:0.32765692472457886,c:0.35492977499961853,e:0.35077401995658875,count:0.34785377979278564,surprises:0.37739473581314087,p:0.33666014671325684,i:0.3466312289237976,scores:0.3348947763442993,j:0.34669485688209534,",1,2,"f:ref,inp: inv,s:sec,",0,0,Greedy,96,0.03662538528442383,replace,[],0.7560873627662659,0.4464350938796997
34," def ispal(num):
      num = str(num)
      if num == num[::-1]:
          return True
      else:
          return False
  
  def test(bot, top):
      count = []
      for i in range(bot,top+1):
          if not ((int(i**0.5)**2) == i):
              continue
          if ispal(i) and ispal(int(i**0.5)):
              count.append(i)
      return len(count)
  
  case = 1
  for line in open('C-small-attempt2.in', 'Ur'):
      if ' ' in line:
          a,b = line.split()
          res = test(int(a),int(b))
          print(""Case #{0}: {1}"".format(case, res))
          case += 1
  
  
",153," def ispal(name):
      name = str(name)
      if name == name[::-1]:
          return True
      else:
          return False
  
  def test(lib, size):
      type = []
      for l in range(lib,size+1):
          if not ((int(l**0.5)**2) == l):
              continue
          if ispal(l) and ispal(int(l**0.5)):
              type.append(l)
      return len(type)
  
  ce = 1
  for lo in open('C-small-attempt2.in', 'Ur'):
      if ' ' in lo:
          ai,db = lo.split()
          exc = test(int(ai),int(db))
          print(""Case #{0}: {1}"".format(ce, exc))
          ce += 1
  
  
",LABEL_17,LABEL_17,,-1,"num,bot,top,count,i,case,line,a,b,res","num:0.23579254746437073,bot:0.33417513966560364,top:0.30794037878513336,count:0.3400185853242874,i:0.34504304826259613,case:0.2725994735956192,line:0.32174378633499146,a:0.3210960030555725,b:0.3133421391248703,res:0.33307866752147675,",0,0,"i:l,count:type,bot:lib,res:exc,line:lo,a:ai,b:wb,top:size,case:error,num:name,",0,0,Greedy,206,0.07432332833607992,failed,[],0.4697595536708832,0.1364467591047287
35," data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]
  count = 0
  for line in data[1:]:
  	count += 1
  	supps = line[1]
  	score = line[2]
  	maxes = 0
  	nonsuptot = (score*3)-2
  	suptot = (score*3)-4
  	if suptot < 0:
  		suptot = 1
  	for i in range(3,(len(line))):
  		if line[i] >= nonsuptot:
  			maxes += 1
  			continue
  		if (line[i] >= suptot) and (supps > 0):
  			maxes += 1
  			supps -= 1
  	if score == 0:
  		maxes = line[0]
  	print (""Case #""+str(count)+"":"", maxes)
  		
  			
  
  
  
  
",1348,,LABEL_17,LABEL_22,,-4,data,,,,,0,0,Greedy,1,0.0008820096651713053,,,0.10268349945545197,0.10268349945545197
36," 
  
  def is_palindrome(a):
      return str(a) == ''.join(reversed(str(a)))
  
  
  def solve_problem(min_num, max_num):
      count = 0
      for i in xrange(min_num, max_num + 1):
          if is_palindrome(i):
              sqrt = math.sqrt(i)
              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):
                  count += 1
      return count
  
  
  if __name__ == '__main__':
      num_of_cases = int(sys.stdin.readline())
      for i in xrange(1, num_of_cases + 1):
          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))
          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))
",150," 
  
  def is_palindrome(a):
      return str(a) == ''.join(reversed(str(a)))
  
  
  def solve_problem(min_num, max_num):
      count = 0
      for i in xrange(min_num, max_num + 1):
          if is_palindrome(i):
              sqrt = math.sqrt(i)
              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):
                  count += 1
      return count
  
  
  if __name__ == '__main__':
      num_of_case = int(sys.stdin.readline())
      for i in xrange(1, num_of_case + 1):
          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))
          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))
",LABEL_18,LABEL_18,LABEL_12,1,"a,min_num,max_num,count,i,sqrt,num_of_cases","a:0.3764108940958977,min_num:0.3623439073562622,max_num:0.3507627993822098,count:0.34177443385124207,i:0.3461783826351166,sqrt:0.3322792500257492,num_of_cases:0.3858487159013748,",1,2,,0,0,Greedy,25,0.0096153457959493,replace,[],0.4801320433616638,0.4801320433616638
37,"""""""
  Google Code Jam 2012 Problem B
  Usage:
      python problem_b.py < input.txt > output.txt
  """"""
  
  
  def calc_possible(n):
      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores
      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)
  
  
  def calc_surprising(n):
      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))
      return results[0] if results else None
  
  
  def calc_normal(n):
      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))
      return results[0] if results else None
  
  
  def solve_problem():
      number_of_cases = int(sys.stdin.readline())
  
      for i in xrange(1, number_of_cases + 1):
  
          case = sys.stdin.readline().strip()
          result = 0
          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)
          num_of_googlers = int(num_of_googlers)
          num_of_surprising = int(num_of_surprising)
          desired_score = int(desired_score)
          scores = map(int, scores.split())
  
          possible_scores = []
  
          for k in xrange(num_of_googlers):
  
              normal = calc_normal(scores[k])
              surprising = calc_surprising(scores[k])
  
              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))
  
          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))
          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))
  
          sys.stdout.write('Case #{0}: {1}
'.format(i, result))
  
  
  if __name__ == '__main__':
      solve_problem()
",394,"""""""
  Google Code Jam 2012 Problem B
  Usage:
      python problem_b.py < input.txt > output.txt
  """"""
  
  
  def calc_possible(o):
      combination = itertools.combinations_with_replacement(range(o), 3)  # 3 scores
      return itertools.ifilter(lambda (x, y, z): x + y + z == o, combination)
  
  
  def calc_surprising(o):
      jobs = list(itertools.ifilter(lambda cores: max(cores) - min(cores) == 2, calc_possible(o)))
      return jobs[0] if jobs else None
  
  
  def calc_normal(o):
      jobs = list(itertools.ifilter(lambda cores: max(cores) - min(cores) <= 1, calc_possible(o)))
      return jobs[0] if jobs else None
  
  
  def solve_problem():
      number_of_cases = int(sys.stdin.readline())
  
      for id in xrange(1, number_of_cases + 1):
  
          connection = sys.stdin.readline().strip()
          distance = 0
          num_of_goongler, num_of_serprises, desired_match, cores = connection.split(' ', 3)
          num_of_goongler = int(num_of_goongler)
          num_of_serprises = int(num_of_serprises)
          desired_match = int(desired_match)
          cores = map(int, cores.split())
  
          possible_core = []
  
          for g in xrange(num_of_goongler):
  
              unit = calc_normal(cores[g])
              serprising = calc_surprising(cores[g])
  
              possible_core.append(((unit if unit else (0, 0, 0), 0), (serprising if serprising else (0, 0, 0), 1)))
  
          Possible = list(itertools.ifilter(lambda cores: sum(map(lambda x: x[1], cores)) == num_of_serprises, itertools.product(*possible_core)))
          distance = max(map(lambda cores: sum(map(lambda x: int(max(x[0]) >= desired_match), cores)) if cores else 0, Possible))
  
          sys.stdout.write('Case #{0}: {1}
'.format(id, distance))
  
  
  if __name__ == '__main__':
      solve_problem()
",LABEL_18,LABEL_18,,-1,"n,combinations,results,number_of_cases,i,case,result,num_of_googlers,num_of_surprising,desired_score,scores,possible_scores,k,normal,surprising,possible","n:0.6074774265289307,combinations:0.6274662613868713,results:0.7182508334517479,number_of_cases:0.6968782246112823,i:0.584561824798584,case:0.6231742054224014,result:0.6577573269605637,num_of_googlers:0.6414566189050674,num_of_surprising:0.6389306932687759,desired_score:0.6282543689012527,scores:0.28382575511932373,possible_scores:0.546456903219223,k:0.5113101601600647,normal:0.5198910534381866,surprising:0.556460052728653,possible:0.49952366948127747,",0,0,"results:jobs,result:distance,num_of_googlers:num_of_goongler,num_of_surprising:num_of_serprises,desired_score:desired_match,combinations:combination,case:connection,n:o,i:id,surprising:serprising,possible_scores:possible_core,normal:unit,k:c,possible:Possible,scores:cores,",0,0,Greedy,315,0.11772674322128296,failed,[],0.8355302214622498,0.6769571304321289
38," 
  
  
  def ispalindrome(n):
      return str(n) == str(n)[::-1]
  
  
  def solve(A, B):
      solution = []
      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):
          if ispalindrome(n):
              m = n ** 2
              if ispalindrome(m) and A <= m <= B:
                  solution.append(n)
      return len(solution)
  
  
  def main(IN, OUT):
      T = int(IN.readline())
      for index in range(T):
          A, B = map(int, IN.readline().split())
          OUT.write('Case #%d: %s
' % (index + 1, solve(A, B)))
  
  
  def makesample(T=100, ABmax=1000):
      print T
      for index in range(T):
          A = random.randint(1, ABmax)
          B = random.randint(A, ABmax)
          print A, B
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",239," 
  
  
  def ispalindrome(nv):
      return str(nv) == str(nv)[::-1]
  
  
  def solve(And, Other):
      Solution = []
      for nv in range(int(math.sqrt(And)), int(math.sqrt(Other))+1):
          if ispalindrome(nv):
              pm = nv ** 2
              if ispalindrome(pm) and And <= pm <= Other:
                  Solution.append(nv)
      return len(Solution)
  
  
  def main(RAW, DATA):
      I = int(RAW.readline())
      for t in range(I):
          And, Other = map(int, RAW.readline().split())
          DATA.write('Case #%d: %s
' % (t + 1, solve(And, Other)))
  
  
  def makesample(I=100, AFMax=1000):
      print I
      for t in range(I):
          And = random.randint(1, AFMax)
          Other = random.randint(And, AFMax)
          print And, Other
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",LABEL_19,LABEL_19,,-1,"n,A,B,solution,m,IN,OUT,T,index,ABmax","n:0.9070656970143318,A:0.911166213452816,B:0.9199723303318024,solution:0.905536949634552,m:0.8590338677167892,IN:0.8678597584366798,OUT:0.8982397317886353,T:0.8989763334393501,index:0.9025456607341766,ABmax:0.8553673475980759,",0,0,"B:Other,A:And,n:nv,solution:Solution,index:t,T:H,OUT:DATA,IN:RAW,m:pm,ABmax:AFMax,",0,0,Greedy,209,0.07652663389841716,failed,[],0.9917578101158142,0.9761932492256165
39," 
  
  
  
  
  def solve(S, p, tlist):
  	above = 0
  	consider = 0
  
  	for t in tlist:
  		avg = t / 3
  		mod = t % 3
  
  		if mod == 0:
  			if avg >= p:
  				above += 1
  			elif avg + 1 >= p and t > 0:
  				consider += 1
  
  		elif mod == 1:
  			if avg + 1 >= p:
  				above += 1
  
  		elif mod == 2:
  			if avg + 1 >= p:
  				above += 1
  			elif avg + 2 >= p:
  				consider += 1
  
  	return above + min(S, consider)
  
  
  def main(IN, OUT):
  	N = int(IN.readline())
  	for index in range(N):
  		data = map(int, IN.readline().strip().split())
  		(N, S, p), tlist = data[:3], data[3:]
  		OUT.write('Case #%d: %d
' % (index + 1, solve(S, p, tlist)))
  
  
  if __name__ == '__main__':
  	main(sys.stdin, sys.stdout)
  
",212," 
  
  
  
  
  def solve(Ps, p, atset):
  	margin = 0
  	consider = 0
  
  	for tu in atset:
  		afge = tu / 3
  		int = tu % 3
  
  		if int == 0:
  			if afge >= p:
  				margin += 1
  			elif afge + 1 >= p and tu > 0:
  				consider += 1
  
  		elif int == 1:
  			if afge + 1 >= p:
  				margin += 1
  
  		elif int == 2:
  			if afge + 1 >= p:
  				margin += 1
  			elif afge + 2 >= p:
  				consider += 1
  
  	return margin + min(Ps, consider)
  
  
  def main(IN, Q):
  	N = int(IN.readline())
  	for IND in range(N):
  		input = map(int, IN.readline().strip().split())
  		(N, Ps, p), atset = input[:3], input[3:]
  		Q.write('Case #%d: %d
' % (IND + 1, solve(Ps, p, atset)))
  
  
  if __name__ == '__main__':
  	main(sys.stdin, sys.stdout)
  
",LABEL_19,LABEL_19,LABEL_63,1,"S,p,tlist,above,consider,t,avg,mod,IN,OUT,N,index,data","S:0.5785244554281235,p:0.5940132737159729,tlist:0.6275118142366409,above:0.5921321511268616,consider:0.5298037827014923,t:0.6074372828006744,avg:0.5890882164239883,mod:0.6103327721357346,IN:0.5123936384916306,OUT:0.5801769644021988,N:0.5687364339828491,index:0.6395705342292786,data:0.6157636791467667,",1,4,"index:IND,tlist:atset,data:input,mod:int,t:tu,above:margin,avg:afge,OUT:Q,",0,0,Greedy,212,0.07782805363337199,replace,[],0.745668888092041,0.4032016098499298
40," 
  N_MAX = 10 ** 7  # for First large dataset
  
  
  def is_palindrome(n):
      s = str(n)
      for i in xrange(len(s) / 2):
          if s[i] != s[-1 - i]:
              return False
      return True
  
  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]
  palindrome_squares = [x ** 2 for x in palindromes]
  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)
  
  
  T = int(raw_input())
  for test_case_id in xrange(1, T + 1):
      A, B = map(int, raw_input().split())
      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])
      print 'Case #{}: {}'.format(test_case_id, answer)
",147," 
  N_MAX = 10 ** 7  # for First large dataset
  
  
  def is_palindrome(n):
      s = str(n)
      for i in xrange(len(s) / 2):
          if s[i] != s[-1 - i]:
              return False
      return True
  
  palindromues = [x for x in xrange(N_MAX) if is_palindrome(x)]
  palindrome_squares = [x ** 2 for x in palindromues]
  fair_and_square_palndramES = filter(is_palindrome, palindrome_squares)
  
  
  T = int(raw_input())
  for test_case_id in xrange(1, T + 1):
      A, B = map(int, raw_input().split())
      answer = len([x for x in fair_and_square_palndramES if A <= x <= B])
      print 'Case #{}: {}'.format(test_case_id, answer)
",LABEL_20,LABEL_20,LABEL_61,1,"N_MAX,n,s,i,palindromes,x,palindrome_squares,fair_and_square_palindromes,T,test_case_id,A,B,answer","N_MAX:-0.14545854926109314,n:-0.1843353509902954,s:-0.14661905169487,i:-0.16905826330184937,palindromes:-0.08710542321205139,x:-0.2010471224784851,palindrome_squares:-0.13828933238983154,fair_and_square_palindromes:-0.09768623113632202,T:-0.11413365602493286,test_case_id:-0.2811000943183899,A:-0.1238345205783844,B:-0.11990350484848022,answer:-0.19611337780952454,",1,2,"palindromes:palindromues,",0,0,Greedy,54,0.020759673913319905,replace,[],0.20165058970451355,0.17003343999385834
41," 
  
  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])
  for a, b, c in itertools.product(range(10 + 1), repeat=3):
      if a <= b <= c and c - a <= 2:
          n = a + b + c
          if c - a == 2:
              poss[n]['s'] = tuple(sorted((a, b, c)))
          else:
              poss[n]['n'] = tuple(sorted((a, b, c)))
  
  
  T = int(raw_input())
  for case in xrange(1, T + 1):
      div = map(int, raw_input().split())
      N, S, p = div[:3]
      t = div[3:]
  
      ans = 0
      t.sort(reverse=True)
      for i in xrange(len(t)):
          na, nb, nc = poss[t[i]]['n']
          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))
          if p <= nc:
              ans += 1
          elif 0 < S and p <= sc:
              ans += 1
              S -= 1
  
      print 'Case #%d: %d' % (case, ans)
  
",268," 
  
  poss = dict([(ri, {}) for ri in xrange(0, 30 + 1)])
  for z, r, count in itertools.product(range(10 + 1), repeat=3):
      if z <= r <= count and count - z <= 2:
          int = z + r + count
          if count - z == 2:
              poss[int]['s'] = tuple(sorted((z, r, count)))
          else:
              poss[int]['n'] = tuple(sorted((z, r, count)))
  
  
  Size = int(raw_input())
  for address in xrange(1, Size + 1):
      input = map(int, raw_input().split())
      Ns, g, pp = input[:3]
      te = input[3:]
  
      ins = 0
      te.sort(reverse=True)
      for ri in xrange(len(te)):
          Na, sg, dc = poss[te[ri]]['n']
          ns, soc, so = poss[te[ri]].get('s', (-1, -1, -1))
          if pp <= dc:
              ins += 1
          elif 0 < g and pp <= so:
              ins += 1
              g -= 1
  
      print 'Case #%d: %d' % (address, ins)
  
",LABEL_20,LABEL_20,,-1,"poss,i,a,b,c,n,T,case,div,N,S,p,t,ans,na,nb,nc,sa,sb,sc","poss:0.28584784269332886,i:0.41186386346817017,a:0.4387403130531311,b:0.4394553005695343,c:0.43200573325157166,n:0.4178415834903717,T:0.4425499439239502,case:0.5742339491844177,div:0.39156728982925415,N:0.3920002579689026,S:0.37983590364456177,p:0.38646167516708374,t:0.3383963704109192,ans:0.35060012340545654,na:0.3935774564743042,nb:0.4108031988143921,nc:0.3928654193878174,sa:0.3904179334640503,sb:0.39803600311279297,sc:0.390017569065094,",0,0,"case:address,T:Size,b:r,a:z,c:cu,n:net,i:u,nb:sg,sb:soc,na:Na,nc:dc,N:Sa,div:ce,sa:bc,sc:sw,p:pp,S:g,ans:args,t:flat,",0,0,Greedy,397,0.14472400347391765,failed,[],0.9090458750724792,0.29138925671577454
42," 
  
  
  INPUT = ""tiny""
  if 1:
      INPUT = ""C-small-attempt0.in""
  
  def debug(*args):
      pass #print str(args)
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args
  
  def is_palindrome(N):
      s = str(N)
      return s == ''.join(reversed(s))
  
  def fair_and_square_set(max_N):
      p = ""squareset_%d"" % max_N
      try:
          s = pickle.load(file(p))
          return s
      except:
          pass
      s = set()
      for i in range(1,max_N+1):
          if is_palindrome(i) and is_palindrome(i*i):
              s.add(i*i)
      pickle.dump(s, file(p, ""wb""))
      return s
  
  MAX_N = int(1e7)
  SQUARE_SET = fair_and_square_set(MAX_N)
  
  def do_trial(A, B):
      count = 0
      for ss in SQUARE_SET:
          if A <= ss <= B:
              count += 1
      return count
  
  f = file(INPUT)
  T = int(f.readline()[:-1])
  for i in range(T):
      A, B = [int(x) for x in f.readline().split()]
      v = do_trial(A, B)
      print ""Case #%d: %s"" % (i+1, v)
",337," 
  
  
  AINput = ""tiny""
  if 1:
      AINput = ""C-small-attempt0.in""
  
  def debug(*args):
      pass #print str(args)
  
  class Memoize:
      def __init__(proc,function):
          proc. _session = {}
          proc._callable = function
              
      def __call__(proc, *args, **kwds):
          api = proc. _session
          connection = proc._getKey(*args,**kwds)
          try: return api[connection]
          except KeyError:
              cachedValue = api[connection] = proc._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(proc,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args
  
  def is_palindrome(N):
      ows = str(N)
      return ows == ''.join(reversed(ows))
  
  def fair_and_square_set(max_N):
      p = ""squareset_%d"" % max_N
      try:
          ows = pickle.load(file(p))
          return ows
      except:
          pass
      ows = set()
      for i in range(1,max_N+1):
          if is_palindrome(i) and is_palindrome(i*i):
              ows.add(i*i)
      pickle.dump(ows, file(p, ""wb""))
      return ows
  
  MAX_N = int(1e7)
  SQUARE_SET = fair_and_square_set(MAX_N)
  
  def do_trial(A, B):
      count = 0
      for ss in SQUARE_SET:
          if A <= ss <= B:
              count += 1
      return count
  
  f = file(AINput)
  T = int(f.readline()[:-1])
  for i in range(T):
      A, B = [int(x) for x in f.readline().split()]
      v = do_trial(A, B)
      print ""Case #%d: %s"" % (i+1, v)
",LABEL_21,LABEL_21,LABEL_43,1,"INPUT,self,function,_cache,_callable,cache,key,cachedValue,N,s,max_N,p,i,MAX_N,SQUARE_SET,A,B,count,ss,f,T,x,v","INPUT:0.8499758690595627,self:0.5174526870250702,function:0.42057138681411743,_cache:0.4546997547149658,_callable:0.4302207827568054,cache:0.4430442452430725,key:0.4467080235481262,cachedValue:0.4179394841194153,N:0.3997323513031006,s:0.4365541338920593,max_N:0.3774796724319458,p:0.4080274701118469,i:0.36471444368362427,MAX_N:0.3521333336830139,SQUARE_SET:0.3953646421432495,A:0.31919634342193604,B:0.3481137156486511,count:0.3307451605796814,ss:0.3646335005760193,f:0.3412708640098572,T:0.3633928894996643,x:0.3692566752433777,v:0.38774240016937256,",1,9,"INPUT:AINput,self:proc,_cache: _session,key:connection,cache:api,",0,0,Greedy,141,0.05403005282084147,replace,[],0.9880616664886475,0.7387151122093201
43," 
  
  INPUT = ""tiny""
  
  INPUT = ""B-small-attempt0.in.txt""
  
  def debug(*args):
      pass #print str(args)
  
  def zdebug(*args):
      print ''.join(str(s) for s in args)
  
  def can_score_p(N, p):
      low_p = max(p-1, 0)
      if low_p + low_p + p <= N:
          return ""Y""
      low_p = max(p-2, 0)
      if low_p + low_p + p <= N:
          return ""S""
      return ""N""
  
  def do_trial(N, S, p, *scores):
      d = { ""Y"" : 0, ""N"" : 0, ""S"" : 0 }
      for s in scores:
          v = can_score_p(s, p)
          debug(""score %s p=%s : %s"" % (s, p, v))
          d[v] = d[v] + 1
      return d[""Y""] + min(d[""S""], S)
  
  f = file(INPUT)
  T = int(f.readline()[:-1])
  for i in range(T):
      l = [int(x) for x in f.readline()[:-1].split()]
      v = do_trial(*l)
      print ""Case #%d: %s"" % (i+1, v)
",237," 
  
  ILFF = ""tiny""
  
  ILFF = ""B-small-attempt0.in.txt""
  
  def debug(*args):
      pass #print str(args)
  
  def zdebug(*args):
      print ''.join(str(tests) for tests in args)
  
  def can_score_p(NT, pp):
      lowacpre = max(pp-1, 0)
      if lowacpre + lowacpre + pp <= NT:
          return ""Y""
      lowacpre = max(pp-2, 0)
      if lowacpre + lowacpre + pp <= NT:
          return ""S""
      return ""N""
  
  def do_trial(NT, SE, pp, *scores):
      u = { ""Y"" : 0, ""N"" : 0, ""S"" : 0 }
      for tests in scores:
          t = can_score_p(tests, pp)
          debug(""score %s p=%s : %s"" % (tests, pp, t))
          u[t] = u[t] + 1
      return u[""Y""] + min(u[""S""], SE)
  
  fi = file(ILFF)
  VT = int(fi.readline()[:-1])
  for I in range(VT):
       L = [int(b) for b in fi.readline()[:-1].split()]
      t = do_trial(* L)
      print ""Case #%d: %s"" % (I+1, t)
",LABEL_21,LABEL_21,,-1,"INPUT,s,N,p,low_p,S,d,v,f,T,i,l,x","INPUT:0.7923982590436935,s:0.44512617588043213,N:0.4407804608345032,p:0.45341968536376953,low_p:0.44444364309310913,S:0.4221579432487488,d:0.29810643196105957,v:0.39126062393188477,f:0.42043405771255493,T:0.42115670442581177,i:0.4431149363517761,l:0.41522401571273804,x:0.4134409427642822,",0,0,"INPUT:ILFF,p:pp,s:tests,low_p:lowacpre,i:I,N:A,S:G,T:A,f:fi,l: L,x:xx,v:t,d:df,",0,0,Greedy,267,0.09745692014694214,failed,[],0.9691827297210693,0.5736581087112427
44," 
  
  def is_palindromic(i):
      n = i
      rev = 0
      while i > 0:
          dig = i % 10
          rev = rev * 10 + dig
          i = i // 10
      return n == rev
  
  def is_square(i):
      if i == 1:
          return True
      x = i // 2
      seen = set([x])
      while x * x != i:
          x = (x + (i // x)) // 2
          if x in seen:
              return False
          seen.add(x)
      return True
  
  def f(a, b):
      tot = 0
  
      sra = a
      while not is_square(sra):
          sra += 1
      srb = b
      while not is_square(srb):
          srb -= 1
  
      sra = int(sqrt(sra))
      srb = int(sqrt(srb))
  
      for i in range(sra, srb+1):
          if is_palindromic(i) and is_palindromic(i ** 2):
              tot += 1
  
      return tot
  
  if __name__ == '__main__':
      T = int(input())
      for i in range(T):
          a, b = map(int, input().split())
          r = f(a, b)
          print('Case #{}: {}'.format(i+1, r))
",242," 
  
  def is_palindromic(uri):
      bin = uri
      dec = 0
      while uri > 0:
          ord = uri % 10
          dec = dec * 10 + ord
          uri = uri // 10
      return bin == dec
  
  def is_square(uri):
      if uri == 1:
          return True
      g = uri // 2
      saw = set([g])
      while g * g != uri:
          g = (g + (uri // g)) // 2
          if g in saw:
              return False
          saw.add(g)
      return True
  
  def f(au, bb):
      dot = 0
  
      sran = au
      while not is_square(sran):
          sran += 1
      lsruby = bb
      while not is_square(lsruby):
          lsruby -= 1
  
      sran = int(sqrt(sran))
      lsruby = int(sqrt(lsruby))
  
      for uri in range(sran, lsruby+1):
          if is_palindromic(uri) and is_palindromic(uri ** 2):
              dot += 1
  
      return dot
  
  if __name__ == '__main__':
      TS = int(input())
      for uri in range(TS):
          au, bb = map(int, input().split())
          right = f(au, bb)
          print('Case #{}: {}'.format(uri+1, right))
",LABEL_22,LABEL_22,,-1,"i,n,rev,dig,x,seen,a,b,tot,sra,srb,T,r","i:0.6503997147083282,n:0.5981217324733734,rev:0.5748859792947769,dig:0.5741744041442871,x:0.5797956138849258,seen:0.5754289478063583,a:0.5497366487979889,b:0.5690111815929413,tot:0.5914530009031296,sra:0.5523282438516617,srb:0.5373853147029877,T:0.6062829196453094,r:0.575321301817894,",0,0,"i:uri,T:TS,n:bin,tot:dot,x:g,seen:saw,r:right,rev:dec,dig:ord,b:bb,sra:sran,a:au,srb:lsruby,",0,0,Greedy,273,0.09960346221923828,failed,[],0.7835556864738464,0.4131978154182434
45," 
  T = int(raw_input())
  for i in xrange(T):
      values = map(int, raw_input().split())
      [N,s,p] = values[0:3]
      t = values[3:]
      answer = 0
      for note in t:
          if note < 2:
              if note >= p:
                  answer += 1
          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:
              answer += 1
          elif note % 3 == 0:
              n = note / 3
              if n >= p:
                  answer += 1
              elif s > 0 and n + 1 >= p:
                  answer += 1
                  s -= 1
          elif note % 3 == 2:
              n = (note - 2) / 3
              if n + 1 >= p:
                  answer += 1
              elif s > 0 and n + 2 >= p:
                  answer += 1
                  s -= 1
      print 'Case #{0}: {1}'.format(i+1, answer)
",185," 
  Test = int(raw_input())
  for i in xrange(Test):
      tests = map(int, raw_input().split())
      [N,comments,p] = tests[0:3]
      t = tests[3:]
      answer = 0
      for note in t:
          if note < 2:
              if note >= p:
                  answer += 1
          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:
              answer += 1
          elif note % 3 == 0:
              out = note / 3
              if out >= p:
                  answer += 1
              elif comments > 0 and out + 1 >= p:
                  answer += 1
                  comments -= 1
          elif note % 3 == 2:
              out = (note - 2) / 3
              if out + 1 >= p:
                  answer += 1
              elif comments > 0 and out + 2 >= p:
                  answer += 1
                  comments -= 1
      print 'Case #{0}: {1}'.format(i+1, answer)
",LABEL_22,LABEL_22,LABEL_20,1,"T,i,values,N,s,p,t,answer,note,n","T:0.34682196378707886,i:0.26537927985191345,values:0.36343541741371155,N:0.2735198140144348,s:0.36651694774627686,p:0.3305329382419586,t:0.34112444519996643,answer:0.2720188796520233,note:0.32638704776763916,n:0.3695632517337799,",1,2,"n:out,s:comments,values:tests,",0,0,Greedy,91,0.03358527421951294,replace,[],0.724769651889801,0.4944789409637451
46," 
  
  FILE_NAME_BASE = 'C-small-attempt0'
  NUM_PROCESSES = 0
  MEM_LIMIT_GB = 1.5 # per worker process
  RECURSION_LIMIT = 1000
  
  def parse(inp):
  	a, b = (int(x) for x in inp.readline().split())
  	return a, b
  
  def isFair(x):
  	l1 = list(str(x))
  	l2 = list(l1)
  	l2.reverse()
  	return l1 == l2
  
  def solve(a, b):
  	c = 0
  	for i in xrange(a, b + 1):
  		r = int(sqrt(i))
  		if r * r == i and isFair(i) and isFair(r):
  			c += 1
  
  	return str(c)
  
  def main():
  	sys.setrecursionlimit(RECURSION_LIMIT)
  
  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
  
  	inp = open(FILE_NAME_BASE + '.in', 'r')
  	numCases = int(inp.readline())
  	if NUM_PROCESSES == 0:
  		results = [
  			solve(*parse(inp))
  			for _ in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PROCESSES)
  		results = [
  			pool.apply_async(solve, parse(inp))
  			for _ in range(numCases)
  			]
  	inp.close()
  	out = open(FILE_NAME_BASE + '.out', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PROCESSES == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
  
  if __name__ == '__main__':
  	main()
",318," 
  
  FILE_NAMEPBAME = 'C-small-attempt0'
  NUM_PRECESSes = 0
  MEM_LIMIT_MM = 1.5 # per worker process
  RECURSION_LIMIT = 1000
  
  def parse(inp):
  	ba, wb = (int(px) for px in inp.readline().split())
  	return ba, wb
  
  def isFair(px):
  	ll4 = list(str(px))
  	l3 = list(ll4)
  	l3.reverse()
  	return ll4 == l3
  
  def solve(ba, wb):
  	t = 0
  	for l in xrange(ba, wb + 1):
  		u = int(sqrt(l))
  		if u * u == l and isFair(l) and isFair(u):
  			t += 1
  
  	return str(t)
  
  def main():
  	sys.setrecursionlimit(RECURSION_LIMIT)
  
  	little, small = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_MM * 1024 ** 3, small))
  
  	inp = open(FILE_NAMEPBAME + '.in', 'r')
  	numCases = int(inp.readline())
  	if NUM_PRECESSes == 0:
  		complete = [
  			solve(*parse(inp))
  			for U in range(numCases)
  			]
  	else:
  		pull = Pool(NUM_PRECESSes)
  		complete = [
  			pull.apply_async(solve, parse(inp))
  			for U in range(numCases)
  			]
  	inp.close()
  	job = open(FILE_NAMEPBAME + '.out', 'w')
  	for example, rate in enumerate(complete):
  		count = rate if NUM_PRECESSes == 0 else rate.get()
  		job.write('Case #%d: %s
' % (example + 1, count))
  		job.flush()
  	job.close()
  
  if __name__ == '__main__':
  	main()
",LABEL_23,LABEL_23,,-1,"FILE_NAME_BASE,NUM_PROCESSES,MEM_LIMIT_GB,RECURSION_LIMIT,inp,a,b,x,l1,l2,c,i,r,soft,hard,numCases,results,_,pool,out,case,result,value","FILE_NAME_BASE:0.33821308612823486,NUM_PROCESSES:0.3287142515182495,MEM_LIMIT_GB:0.3644123077392578,RECURSION_LIMIT:0.3079702854156494,inp:0.2319728136062622,a:0.2853512763977051,b:0.2970227003097534,x:0.29652029275894165,l1:0.29713767766952515,l2:0.298389196395874,c:0.2996112108230591,i:0.31451427936553955,r:0.2925810217857361,soft:0.307256817817688,hard:0.2783316969871521,numCases:0.33096545934677124,results:0.30931663513183594,_:0.34598463773727417,pool:0.2810112237930298,out:0.37664657831192017,case:0.29723161458969116,result:0.37001150846481323,value:0.3410845994949341,",0,0,"out:job,result:rate,MEM_LIMIT_GB:MEM_LIMIT_MM,_:U,value:count,FILE_NAME_BASE:FILE_NAMEPBAME,NUM_PROCESSES:NUM_PRECESSes,i:l,results:complete,soft:little,c:ce,l2:l3,case:example,l1:ll4,b:range,x:g,r:rb,a:n,pool:pull,hard:small,",0,0,Greedy,470,0.17509535948435465,failed,[],0.8874724507331848,0.557388424873352
47," 
  FILE_NAME_BASE = 'B-small-attempt0'
  NUM_PROCESSES = 0
  
  def parse(inp):
  	data = tuple(int(x) for x in inp.readline().split())
  	dancers, surprises, points = data[ : 3]
  	totals = data[3 : ]
  	assert len(totals) == dancers
  	return totals, surprises, points
  
  def totalAtDist():
  	'''
  	If a dancer's best result is b, the total can be:
  	  distance 0: 3b
  	  distance 1: [3b-2..3b-1]
  	  distance 2: [3b-4..3b-2]
  	Note: distance d is only possible if d <= b.
  
  	total 15:
  	b = 0..4:  impossible
  	b = 5:     dist = 0
  	b = 6:     dist = 2
  	b = 7..10: impossible
  
  	For every total we have a number of explanations, which are
  	(b, d) pairs where b is the best result and d is the distance.
  
  	The output of this function shows:
  
  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:
  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)
  	In other words, always one surprise option and one normal option.
  	The surprise option can have a result one higher than the normal one or
  	equal to it.
  	'''
  
  	print '  ',
  	for b in xrange(0, 11):
  		print 'b=%d' % b,
  	print
  	for total in xrange(0, 31):
  		print '%2d' % total,
  		for b in xrange(0, 11):
  			s = '0' if total == b * 3 else '.'
  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'
  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'
  			print s,
  		print
  
  
  def solve(totals, surprises, points):
  	countCertain = 0
  	countSurprise = 0
  	for total in totals:
  		if (total + 2) / 3 >= points:
  			countCertain += 1
  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:
  			countSurprise += 1
  		else:
  			pass
  
  
  	return countCertain + min(countSurprise, surprises)
  
  if __name__ == '__main__':
  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
  	numCases = int(inp.readline())
  	if NUM_PROCESSES == 0:
  		results = [
  			solve(*parse(inp))
  			for _ in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PROCESSES)
  		results = [
  			pool.apply_async(solve, parse(inp))
  			for _ in range(numCases)
  			]
  	inp.close()
  	out = open(FILE_NAME_BASE + '.out.txt', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PROCESSES == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
",384," 
  FILE_NAME__BASE = 'B-small-attempt0'
  NUM_PRCCESSes = 0
  
  def parse( inpr):
  	input = tuple(int(xf) for xf in  inpr.readline().split())
  	 dancer, useventures, tests = input[ : 3]
  	totals = input[3 : ]
  	assert len(totals) ==  dancer
  	return totals, useventures, tests
  
  def totalAtDist():
  	'''
  	If a dancer's best result is b, the total can be:
  	  distance 0: 3b
  	  distance 1: [3b-2..3b-1]
  	  distance 2: [3b-4..3b-2]
  	Note: distance d is only possible if d <= b.
  
  	total 15:
  	b = 0..4:  impossible
  	b = 5:     dist = 0
  	b = 6:     dist = 2
  	b = 7..10: impossible
  
  	For every total we have a number of explanations, which are
  	(b, d) pairs where b is the best result and d is the distance.
  
  	The output of this function shows:
  
  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:
  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)
  	In other words, always one surprise option and one normal option.
  	The surprise option can have a result one higher than the normal one or
  	equal to it.
  	'''
  
  	print '  ',
  	for id in xrange(0, 11):
  		print 'b=%d' % id,
  	print
  	for scale in xrange(0, 31):
  		print '%2d' % scale,
  		for id in xrange(0, 11):
  			statement = '0' if scale == id * 3 else '.'
  			statement += '1' if id >= 1 and id * 3 - 2 <= scale <= id * 3 - 1 else '.'
  			statement += '2' if id >= 2 and id * 3 - 4 <= scale <= id * 3 - 2 else '.'
  			print statement,
  		print
  
  
  def solve(totals, useventures, tests):
  	countCertain = 0
  	countSurprise = 0
  	for scale in totals:
  		if (scale + 2) / 3 >= tests:
  			countCertain += 1
  		elif 2 <= scale <= 28 and (scale + 4) / 3 >= tests:
  			countSurprise += 1
  		else:
  			pass
  
  
  	return countCertain + min(countSurprise, useventures)
  
  if __name__ == '__main__':
  	 inpr = open(FILE_NAME__BASE + '.in.txt', 'r')
  	numCases = int( inpr.readline())
  	if NUM_PRCCESSes == 0:
  		results = [
  			solve(*parse( inpr))
  			for _ in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PRCCESSes)
  		results = [
  			pool.apply_async(solve, parse( inpr))
  			for _ in range(numCases)
  			]
  	 inpr.close()
  	out = open(FILE_NAME__BASE + '.out.txt', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PRCCESSes == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
",LABEL_23,LABEL_23,,-1,"FILE_NAME_BASE,NUM_PROCESSES,inp,data,x,dancers,surprises,points,totals,b,total,s,countCertain,countSurprise,results,_,pool,out,case,result,value","FILE_NAME_BASE:0.5412854850292206,NUM_PROCESSES:0.5025939047336578,inp:0.5458330810070038,data:0.5344414412975311,x:0.5179975628852844,dancers:0.5370481312274933,surprises:0.5176472067832947,points:0.4828546643257141,totals:0.5307323336601257,b:0.46470320224761963,total:0.4767201542854309,s:0.5256924331188202,countCertain:0.5427490472793579,countSurprise:0.5455826222896576,results:0.5330635905265808,_:0.5545462369918823,pool:0.5368487536907196,out:0.5301357805728912,case:0.5476595461368561,result:0.5363839268684387,value:0.5353683233261108,",0,0,"inp: inpr,FILE_NAME_BASE:FILE_NAME__BASE,dancers: dancer,data:input,s:statement,x:xf,surprises:useventures,NUM_PROCESSES:NUM_PRCCESSes,points:tests,total:scale,b:id,",0,0,Greedy,440,0.16549623012542725,failed,[],0.969775915145874,0.7297337055206299
48," 
  def isPalindrome(n):
      cn=str(n)
      return (cn==cn[::-1])
  
  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]
  
  
  
              
          
          
  
  
  
  def Solve(a,b):
      num=0
      for p in palinSqrt:
          if a<= p**2 <=b: num+=1
      return num
  
  
  
  def parse(infile):
      a,b=map(int, infile.readline().split() )
      return a,b
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,fname):
          self.infile=open(fname,'r')
          self.NumCases=int(self.infile.readline().strip() )
          self.caseNum=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.caseNum==self.NumCases: raise StopIteration
          self.caseNum += 1
          args=parse(self.infile)
          return self.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for iCase, args in myCases:
          answer=Solve(*args)
  
          print 'Case #'+str(iCase)+':',answer
          print >> outfile, 'Case #'+str(iCase)+':',answer
  
  
  
  
  class Categorizer(dict):
      def __init__(self,thelist,transform,trunc=2):
          dict.__init__(self)
          self.transform=transform
          self.AddList(thelist)
          self.trunc=trunc
      def AddList(self,thelist):
          for item in thelist: self.Add( item )
      def Add(self,object):
          cat=self.transform( object )
          if type(cat) is float:
              cat=round(cat,trunc)
          if self.has_key(cat):
              self[cat].append( object )
          else:
              self[cat]=[object]
      def PrintRanking(self,n=None):
          if n is None: n=len(self)
          items=self.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for i in items: total+=len(i[1])
          maxkey=max( len(str(key)) for key in self.iterkeys() )
          maxval=max( len(str(len(val))) for val in self.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(self,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not self.has_key(key): self[key]=[]
             self[key] += newdict[key]
      def Avg(self):
          avg=0.0
          ntot=0
          for key in self.keys():
              ntot+=len(self[key])
              avg+=len(self[key])*key
          return avg/(1.0*ntot)
      def StdDev(self):
          avg=self.Avg()
          ntot=0
          stddev=0.0
          for key in self.iterkeys():
              ntot+=len(self[key])
              stddev += len(self[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(self):
          tot=0
          for value in self.itervalues(): tot+=len(value)
          keys=self.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(self[key])
             if nCount>tot/2: return key
      def Mode(self):
          return max(self.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(self,thelist,transform=None,trunc=2):
          dict.__init__(self)
          self.transform=transform
          self.trunc=trunc
          self.AddList(thelist)
      def AddList(self,thelist):
          if self.transform is not None:
              for item in thelist: self.Add( self.transform(item) )
          else:
              for item in thelist: self.Add( item )            
      def Add(self,object):
          if type(object) is float:
              object=round(object,self.trunc)
          if self.has_key(object):
              self[object]+=1
          else:
              self[object]=1
      def PrintRanking(self,n=None):
          if n is None: n=len(self)
          items=self.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for i in items: total+=i[1]
          maxkey=max( len(str(key)) for key in self.iterkeys() )
          maxval=max( len(str(val)) for val in self.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(self,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not self.has_key(key): self[key]=0
             self[key] += newdict[key]
      def Avg(self):
          avg=0.0
          ntot=0
          for key in self.keys():
              ntot+=self[key]
              avg+=self[key]*key
          return avg/(1.0*ntot)
      def StdDev(self):
          avg=self.Avg()
          ntot=0
          stddev=0.0
          for key in self.iterkeys():
              ntot+=self[key]
              stddev += self[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(self):
   	total=sum(self.values())
          keys=self.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += self[key]
             if nCount>total/2: return key
      def Mode(self):
          return max(self.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for p in D[q]:
                  D.setdefault(p + q, []).append(p)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",1495," 
  def isPalindrome(name):
      core=str(name)
      return (core==core[::-1])
  
  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]
  
  
  
              
          
          
  
  
  
  def Solve(wa,bar):
      num=0
      for alpha in palinSqrt:
          if wa<= alpha**2 <=bar: num+=1
      return num
  
  
  
  def parse(infile):
      wa,bar=map(int, infile.readline().split() )
      return wa,bar
  
  
  
  class GCJ_Parser( struct ):
      def __init__(co,filepath):
          co.infile=open(filepath,'r')
          co.NumCodes=int(co.infile.readline().strip() )
          co.testnum=0
  
      def __iter__(co): return co
  
      def next(co):
          if co.testnum==co.NumCodes: raise StopIteration
          co.testnum += 1
          asm=parse(co.infile)
          return co.testnum , asm
  
  
  def runmain():
      MyCases=GCJ_Parser(sys.argv[1])
      inf=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for iProduct, asm in MyCases:
          address=Solve(*asm)
  
          print 'Case #'+str(iProduct)+':',address
          print >> inf, 'Case #'+str(iProduct)+':',address
  
  
  
  
  class Categorizer(dict):
      def __init__(co,thelist,format,trunc=2):
          dict.__init__(co)
          co.format=format
          co.AddList(thelist)
          co.trunc=trunc
      def AddList(co,thelist):
          for item in thelist: co.Add( item )
      def Add(co,struct):
          cat=co.format( struct )
          if type(cat) is float:
              cat=round(cat,trunc)
          if co.has_key(cat):
              co[cat].append( struct )
          else:
              co[cat]=[struct]
      def PrintRanking(co,name=None):
          if name is None: name=len(co)
          items=co.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for i in items: total+=len(i[1])
          maxkey=max( len(str(key)) for key in co.iterkeys() )
          maxval=max( len(str(len(val))) for val in co.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:name]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(co,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not co.has_key(key): co[key]=[]
             co[key] += newdict[key]
      def Avg(co):
          avg=0.0
          ntot=0
          for key in co.keys():
              ntot+=len(co[key])
              avg+=len(co[key])*key
          return avg/(1.0*ntot)
      def StdDev(co):
          avg=co.Avg()
          ntot=0
          stddev=0.0
          for key in co.iterkeys():
              ntot+=len(co[key])
              stddev += len(co[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(co):
          tot=0
          for value in co.itervalues(): tot+=len(value)
          keys=co.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(co[key])
             if nCount>tot/2: return key
      def Mode(co):
          return max(co.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(co,thelist,format=None,trunc=2):
          dict.__init__(co)
          co.format=format
          co.trunc=trunc
          co.AddList(thelist)
      def AddList(co,thelist):
          if co.format is not None:
              for item in thelist: co.Add( co.format(item) )
          else:
              for item in thelist: co.Add( item )            
      def Add(co,struct):
          if type(struct) is float:
              struct=round(struct,co.trunc)
          if co.has_key(struct):
              co[struct]+=1
          else:
              co[struct]=1
      def PrintRanking(co,name=None):
          if name is None: name=len(co)
          items=co.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for i in items: total+=i[1]
          maxkey=max( len(str(key)) for key in co.iterkeys() )
          maxval=max( len(str(val)) for val in co.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:name]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(co,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not co.has_key(key): co[key]=0
             co[key] += newdict[key]
      def Avg(co):
          avg=0.0
          ntot=0
          for key in co.keys():
              ntot+=co[key]
              avg+=co[key]*key
          return avg/(1.0*ntot)
      def StdDev(co):
          avg=co.Avg()
          ntot=0
          stddev=0.0
          for key in co.iterkeys():
              ntot+=co[key]
              stddev += co[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(co):
   	total=sum(co.values())
          keys=co.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += co[key]
             if nCount>total/2: return key
      def Mode(co):
          return max(co.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for alpha in D[q]:
                  D.setdefault(alpha + q, []).append(alpha)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",LABEL_24,LABEL_24,,-1,"n,cn,palinSqrt,a,b,num,p,infile,self,fname,NumCases,caseNum,args,myCases,outfile,iCase,answer,thelist,transform,trunc,item,object","n:0.7286136150360107,cn:0.4901827871799469,palinSqrt:0.6643925607204437,a:0.7529260814189911,b:0.7638619691133499,num:0.34670740365982056,p:0.6531909257173538,infile:0.6335453689098358,self:0.7934895604848862,fname:0.6654404103755951,NumCases:0.6862954795360565,caseNum:0.6556522846221924,args:0.7191009372472763,myCases:0.6903011649847031,outfile:0.5812696218490601,iCase:0.6794922649860382,answer:0.34334564208984375,thelist:0.7185025662183762,transform:0.28016048669815063,trunc:0.27744656801223755,item:0.6624761074781418,object:0.7097288072109222,",0,0,"self:co,b:bar,a:wa,n:name,args:asm,object:struct,myCases:MyCases,NumCases:NumCodes,iCase:iProduct,fname:filepath,caseNum:testnum,p:alpha,outfile:inf,cn:core,answer:address,transform:format,",0,0,Greedy,458,0.1966308871905009,failed,[],0.9019807577133179,0.5261610150337219
49," 
  infile=open(sys.argv[1],'r')
  
  NumCases=int(infile.readline())
  
  for iCase in xrange(NumCases):
      line=[ int(i) for i in infile.readline().split() ]
  
      n=line.pop(0)
      s=line.pop(0)
      p=line.pop(0)
  
      scores=line
      assert(len(scores))==n
  
      imax=0
      isurprise=0
  
      for score in scores:
          if score<p: continue
          if score<3*p-4:
              pass
          elif 3*p-2>score>=3*p-4:
              isurprise+=1
          else:
              imax+=1
  
      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)
  
",157," 
  outline=open(sys.argv[1],'r')
  
  numcases=int(outline.readline())
  
  for iNumber in xrange(numcases):
      line=[ int(uri) for uri in outline.readline().split() ]
  
      l=line.pop(0)
      ses=line.pop(0)
      page=line.pop(0)
  
      SCore=line
      assert(len(SCore))==l
  
      imax=0
       isurvey=0
  
      for rate in SCore:
          if rate<page: continue
          if rate<3*page-4:
              pass
          elif 3*page-2>rate>=3*page-4:
               isurvey+=1
          else:
              imax+=1
  
      print 'Case #'+str(iNumber+1)+':',imax+min( isurvey,ses)
  
",LABEL_24,LABEL_24,,-1,"infile,NumCases,iCase,line,i,n,s,p,scores,imax,isurprise,score","infile:0.7426375150680542,NumCases:0.7679585069417953,iCase:0.7122807651758194,line:0.7747936546802521,i:0.6917418837547302,n:0.6922833025455475,s:0.7570315301418304,p:0.7438984364271164,scores:0.7321434915065765,imax:0.7081450670957565,isurprise:0.7076923847198486,score:0.70174540579319,",0,0,"NumCases:numcases,s:ses,p:page,infile:outline,scores:SCore,iCase:iNumber,isurprise: isurvey,score:rate,n:l,i:it,",0,0,Greedy,252,0.0906768004099528,failed,[],0.9026119112968445,0.5339086055755615
50," 
  lines = sys.stdin.readlines()
  def parseCase(lines):
      dims = map(int,lines[0].split("" ""))
      return 1, dims
  
  def getCases(lines):
      i =0
      while i < len(lines):
          lines_used, case = parseCase(lines[i:])
          i += lines_used
          yield case
  
  
  fands = []
  phash = {1:True}
  def isPalindrome(p):
      return p in phash
  
  def test(p):
      square = p**.5
      return square == int(square) and isPalindrome(int(square))
  
  for i in range(1,10**5):
      if i > 9:
          small_p = int(i * 10 ** int(math.log(i,10)) + int("""".join(reversed(str(i)[:-1]))))
      else: small_p = i
      phash[small_p]= test(small_p)
      if phash[small_p]: fands.append(small_p)
      big_p = int(i * 10 ** int(math.log(i,10)+1) + int("""".join(reversed(str(i)))))
      phash[big_p] = test(big_p)
      if phash[big_p]: fands.append(big_p)
  cNum =0
  
  for c in getCases(lines[1:]):
      cNum += 1
      answer = []
      for i in fands:
          if i < c[0]: continue
          if i > c[1]: break
          if phash[i]: answer.append(i)
      answer = str(len(answer))
      print ""Case #%d: %s"" % ( cNum, answer)
  
  
      
  
  
",333," 
  comments = sys.stdin.readlines()
  def parseCase(comments):
       dim = map(int,comments[0].split("" ""))
      return 1,  dim
  
  def getCases(comments):
      iw =0
      while iw < len(comments):
           lines_use, case = parseCase(comments[iw:])
          iw +=  lines_use
          yield case
  
  
  pands = []
  Phap = {1:True}
  def isPalindrome(pp):
      return pp in Phap
  
  def test(pp):
      np = pp**.5
      return np == int(np) and isPalindrome(int(np))
  
  for iw in range(1,10**5):
      if iw > 9:
           small_np = int(iw * 10 ** int(math.log(iw,10)) + int("""".join(reversed(str(iw)[:-1]))))
      else:  small_np = iw
      Phap[ small_np]= test( small_np)
      if Phap[ small_np]: pands.append( small_np)
      large_c = int(iw * 10 ** int(math.log(iw,10)+1) + int("""".join(reversed(str(iw)))))
      Phap[large_c] = test(large_c)
      if Phap[large_c]: pands.append(large_c)
  pNum =0
  
  for cc in getCases(comments[1:]):
      pNum += 1
      address = []
      for iw in pands:
          if iw < cc[0]: continue
          if iw > cc[1]: break
          if Phap[iw]: address.append(iw)
      address = str(len(address))
      print ""Case #%d: %s"" % ( pNum, address)
  
  
      
  
  
",LABEL_25,LABEL_25,,-1,"lines,dims,i,lines_used,case,fands,phash,p,square,small_p,big_p,cNum,c,answer","lines:0.5085830986499786,dims:0.4102543890476227,i:0.3905681073665619,lines_used:0.36462992429733276,case:0.38475748896598816,fands:0.3750867247581482,phash:0.3790978491306305,p:0.3303006887435913,square:0.3530111312866211,small_p:0.3763684630393982,big_p:0.27949976921081543,cNum:0.36217862367630005,c:0.3962312638759613,answer:0.3802739679813385,",0,0,"lines:comments,dims: dim,c:cc,i:iw,answer:address,phash:Phap,small_p: small_np,fands:pands,lines_used: lines_use,cNum:pNum,square:np,p:pp,big_p:large_c,",0,0,Greedy,283,0.10450439055760702,failed,[],0.8675698041915894,0.5414514541625977
51," """"""
  GCJ framework (gcj.fw.framework)
   - Command Line and Package interface
   - output redirection
   - parsing case input
   - executing problem code against cases
   - testing framework
  """"""
  
  class Framework(object):
      class Case(object):
          def __init__(self, caseNumber, caseData=None):
              self.number = caseNumber
              self.data = caseData
              self.result = None
      
          @classmethod
          def parser(cls, f_in):
              pass
      
          def run(self):
              pass
      
          def execute(self, f_in=None):
              if self.data is None:
                  self.data = self.parser(f_in)
              self.result = self.run(**self.data)
      
          def __str__(self):
              return ""Case #%d: %s"" % (self.number, self.result)
      
      
      class Result(object):
          def __init__(self, resultData):
              self.data = resultData
      
          def __str__(self):
              return str(self.ata)
  
      def __init__(self, f_in, f_out):
          sys.stdout = f_out
          self.f_in = f_in if f_in is not None else sys.stdin
  
      def run(self):
          nCases = int(self.f_in.readline().strip())
          for num in xrange(nCases):
              case = type(self).Case(num+1)
              case.execute( f_in=self.f_in)
              print case
  
  
      @classmethod
      def __main__(cls):
          f_in = sys.stdin
          if len(sys.argv) > 1:
              if sys.argv[1] == ""-t"":
                  unittest.main()
                  sys.exit()
              f_in = open(sys.argv[1])
          framework = cls(f_in, sys.stdout)
          framework.run()
      
  class Test(unittest.TestCase):
      cases = []
      case = None
      c=[]
      
      def setUp(self):
          self.c = []
          self.defineCases()
          counter = 1
          self.cases = []
          for c in self.c:
              case = self.case(counter)
              case.data = case.parser(StringIO.StringIO(c[0]))
              self.cases.append( [case, c[1]])
      
      def defineCases(self):
          pass
      
      def tearDown(self):
          pass 
  
      def test_Name(self):
          self.setUp()
          for case in self.cases:
              print case[0].data, case[1]
              case[0].execute()
              self.assertEqual(case[0].result, case[1])
  '''
  Created on Apr 8, 2012
  
  @author: Joe
  '''
  
  
  class B(Framework):
      class Case(Framework.Case):
          def parser(self, fh):
              args = map(int, fh.readline().strip().split("" ""))
              N,S,p = args[:3]
              scores = args[3:] 
              return {""N"":N,""S"":S,""p"":p,""scores"":scores}
          
          def run(self, N=None,S=None,p=None,scores=None):
              ret = 0
              surps = 0
              for score in scores:
                  if p > 0 and score == 0: continue
                  if 3*p-2 <= score:
                      ret += 1
                  else:
                      if 3*p - 4 <= score:
                          surps += 1
              return str(ret + min(surps,S))
              
  class Test(Test):
      def defineCases(self):
          self.case = B.Case
          self.c = [
                    [""3 1 5 15 13 11"",""3""],
                    [""3 0 8 23 22 21"",""2""],
                    [""2 1 1 8 0"",""1""],
                    [""6 2 8 29 20 8 18 18 21"",""3""],
                    [""1 1 1 1"", ""1""]
                    ]
  
  if __name__ == ""__main__"":
      B.__main__()
      
",686," """"""
  GCJ framework (gcj.fw.framework)
   - Command Line and Package interface
   - output redirection
   - parsing case input
   - executing problem code against cases
   - testing framework
  """"""
  
  class Framework(object):
      class Case(object):
          def __init__(self, caseNumber, caseData=None):
              self.division = caseNumber
              self.input = caseData
              self.result = None
      
          @classmethod
          def parser(cls, f_in):
              pass
      
          def run(self):
              pass
      
          def execute(self, f_in=None):
              if self.input is None:
                  self.input = self.parser(f_in)
              self.result = self.run(**self.input)
      
          def __str__(self):
              return ""Case #%d: %s"" % (self.division, self.result)
      
      
      class Result(object):
          def __init__(self, resultData):
              self.input = resultData
      
          def __str__(self):
              return str(self.ata)
  
      def __init__(self, f_in, f_out):
          sys.stdout = f_out
          self.f_in = f_in if f_in is not None else sys.stdin
  
      def run(self):
          nCases = int(self.f_in.readline().strip())
          for num in xrange(nCases):
              case = type(self).Case(num+1)
              case.execute( f_in=self.f_in)
              print case
  
  
      @classmethod
      def __main__(cls):
          f_in = sys.stdin
          if len(sys.argv) > 1:
              if sys.argv[1] == ""-t"":
                  unittest.main()
                  sys.exit()
              f_in = open(sys.argv[1])
          framework = cls(f_in, sys.stdout)
          framework.run()
      
  class Test(unittest.TestCase):
      cases = []
      case = None
      c=[]
      
      def setUp(self):
          self.c = []
          self.defineCases()
          counter = 1
          self.cases = []
          for c in self.c:
              case = self.case(counter)
              case.input = case.parser(StringIO.StringIO(c[0]))
              self.cases.append( [case, c[1]])
      
      def defineCases(self):
          pass
      
      def tearDown(self):
          pass 
  
      def test_Name(self):
          self.setUp()
          for case in self.cases:
              print case[0].input, case[1]
              case[0].execute()
              self.assertEqual(case[0].result, case[1])
  '''
  Created on Apr 8, 2012
  
  @author: Joe
  '''
  
  
  class B(Framework):
      class Case(Framework.Case):
          def parser(self, fh):
              args = map(int, fh.readline().strip().split("" ""))
              N,S,p = args[:3]
              scores = args[3:] 
              return {""N"":N,""S"":S,""p"":p,""scores"":scores}
          
          def run(self, N=None,S=None,p=None,scores=None):
              ret = 0
              surps = 0
              for score in scores:
                  if p > 0 and score == 0: continue
                  if 3*p-2 <= score:
                      ret += 1
                  else:
                      if 3*p - 4 <= score:
                          surps += 1
              return str(ret + min(surps,S))
              
  class Test(Test):
      def defineCases(self):
          self.case = B.Case
          self.c = [
                    [""3 1 5 15 13 11"",""3""],
                    [""3 0 8 23 22 21"",""2""],
                    [""2 1 1 8 0"",""1""],
                    [""6 2 8 29 20 8 18 18 21"",""3""],
                    [""1 1 1 1"", ""1""]
                    ]
  
  if __name__ == ""__main__"":
      B.__main__()
      
",LABEL_25,LABEL_25,LABEL_35,1,"self,caseNumber,caseData,number,data,result,cls,f_in,resultData,f_out,sys,stdout,nCases,num,case,framework,cases,c,counter","self:-0.41011255979537964,caseNumber:-0.5449751615524292,caseData:-0.5410447716712952,number:-0.39555972814559937,data:-0.27411067485809326,result:-0.4696664810180664,cls:-0.5490668416023254,f_in:-0.56724613904953,resultData:-0.5270636677742004,f_out:-0.40722066164016724,sys:-0.6243500113487244,stdout:-0.46102869510650635,nCases:-0.5033450722694397,num:-0.41952580213546753,case:-0.5101214647293091,framework:-0.46301060914993286,cases:-0.5123490691184998,c:-0.6266064047813416,counter:-0.4446061849594116,",1,2,"data:input,",0,0,Greedy,60,0.024974262714385985,replace,[],0.2548840045928955,0.23521748185157776
52,"def is_palindrome(s):
  	if s == '':
  		return True
  	else:
  		if (ord(s[0]) - ord(s[len(s)-1])) == 0:
  			return is_palindrome(s[1 : len(s) - 1])
  		else:
  			return False
  
  all_fair_and_square = set()
  for i in range(10000):
  	orig = str(i)
  	rev = orig[::-1]
  
  	palin = orig + rev
  	intpalin = int(palin)
  	if is_palindrome(str(intpalin * intpalin)):
  		all_fair_and_square.add(intpalin * intpalin)
  
  	palin = orig[:-1] + rev
  	intpalin = int(palin)
  	if is_palindrome(str(intpalin * intpalin)):
  		all_fair_and_square.add(intpalin * intpalin)
  	
  
  
  t = int(sys.stdin.readline().strip())
  for ii in range(t):
  	line = sys.stdin.readline().strip().split()
  	a = int(line[0])
  	b = int(line[1])
  	count = 0
  	for num in all_fair_and_square:
  		if (num >= a) and (num <= b):
  			count += 1
  	print ""Case #"" + str(ii + 1) + "": "" + str(count)
  
",252,"def is_palindrome(s):
  	if s == '':
  		return True
  	else:
  		if (ord(s[0]) - ord(s[len(s)-1])) == 0:
  			return is_palindrome(s[1 : len(s) - 1])
  		else:
  			return False
  
  all_fair_and_square = set()
  for i in range(10000):
  	orig = str(i)
  	rev = orig[::-1]
  
  	palin = orig + rev
  	intpalin = int(palin)
  	if is_palindrome(str(intpalin * intpalin)):
  		all_fair_and_square.add(intpalin * intpalin)
  
  	palin = orig[:-1] + rev
  	intpalin = int(palin)
  	if is_palindrome(str(intpalin * intpalin)):
  		all_fair_and_square.add(intpalin * intpalin)
  	
  
  
  t = int(sys.stdin.readline().strip())
  for ii in range(t):
  	line = sys.stdin.readline().strip().split()
  	a = int(line[0])
  	b = int(line[1])
  	found = 0
  	for su in all_fair_and_square:
  		if (su >= a) and (su <= b):
  			found += 1
  	print ""Case #"" + str(ii + 1) + "": "" + str(found)
  
",LABEL_26,LABEL_26,LABEL_57,1,"s,all_fair_and_square,i,orig,rev,palin,intpalin,t,ii,line,a,b,count,num","s:0.34671207517385483,all_fair_and_square:0.3729671463370323,i:0.37582801282405853,orig:0.3636089041829109,rev:0.360919713973999,palin:0.36681482195854187,intpalin:0.3678016811609268,t:0.38066384196281433,ii:0.37043360620737076,line:0.38535432517528534,a:0.3797340467572212,b:0.3807638883590698,count:0.38634131103754044,num:0.39465535432100296,",1,3,"num:su,",0,0,Greedy,55,0.02160088618596395,replace,[],0.47099143266677856,0.450114905834198
53," 
  t = int(sys.stdin.readline())
  for i in range(t):
  	inputline = sys.stdin.readline().strip()
  	inputparams = inputline.split()
  
  	n = int(inputparams[0])
  	s = int(inputparams[1])
  	p = int(inputparams[2])
  	validcount = 0
  	surprisingcount = 0
  	for j in range(n):
  		score = int(inputparams[3 + j])
  		if (p + (p - 1) * 2) <= score:
  			validcount += 1
  		elif ((p + (p - 2) * 2) <= score) and (p <= score):
  			surprisingcount += 1
  
  	print ""Case #%d: %d"" % (i + 1, validcount + min(surprisingcount, s))
",153," 
  d = int(sys.stdin.readline())
  for im in range(d):
  	Inputlines = sys.stdin.readline().strip()
  	innerpar = Inputlines.split()
  
  	span = int(innerpar[0])
  	features = int(innerpar[1])
  	ip = int(innerpar[2])
  	validcode = 0
  	surpriseCount = 0
  	for note in range(span):
  		case = int(innerpar[3 + note])
  		if (ip + (ip - 1) * 2) <= case:
  			validcode += 1
  		elif ((ip + (ip - 2) * 2) <= case) and (ip <= case):
  			surpriseCount += 1
  
  	print ""Case #%d: %d"" % (im + 1, validcode + min(surpriseCount, features))
",LABEL_26,LABEL_26,,-1,"t,i,inputline,inputparams,n,s,p,validcount,surprisingcount,j,score","t:0.5264709293842316,i:0.6194317042827606,inputline:0.5635323077440262,inputparams:0.5352504104375839,n:0.5386523306369781,s:0.5820566415786743,p:0.5106389224529266,validcount:0.4206608533859253,surprisingcount:0.5710735470056534,j:0.5947680920362473,score:0.5487240850925446,",0,0,"i:im,j:note,s:features,surprisingcount:surpriseCount,inputline:Inputlines,score:case,n:span,inputparams:innerpar,t:d,p:ip,validcount:validcode,",0,0,Greedy,232,0.08338581720987956,failed,[],0.783028244972229,0.41476890444755554
54," 
  
  fairsquares = []
  
  
  def read_fairsquares():
      global fairsquares
      f = open('fairsquares.txt')
      for x in f:
          fairsquares.append(int(x.strip()))
  
  
  def count_less_than(A):
      left = 0
      right = len(fairsquares)
      while left < right:
          middle = (left + right) // 2
          if fairsquares[middle] < A:
              left = middle + 1
          else:
              right = middle
      return left
  
  
  def compute(A, B):
      count_b = count_less_than(B + 1)
      count_a = count_less_than(A)
      return count_b - count_a
  
  
  def parse():
      return map(int, sys.stdin.readline().strip().split())
  
  
  if __name__ == ""__main__"":
      read_fairsquares()
      T = int(sys.stdin.readline().strip())
      count = 1
      part = 0
      if len(sys.argv) == 3:
          part = int(sys.argv[1])
          count = int(sys.argv[2])
      for i in xrange(T):
          data = parse()
          if i * count >= part * T and i * count < (part + 1) * T:
              result = compute(*data)
              print ""Case #%d: %s"" % (i + 1, result)
",249," 
  
  fairsquares = []
  
  
  def read_fairsquares():
      global fairsquares
      f = open('fairsquares.txt')
      for x in f:
          fairsquares.append(int(x.strip()))
  
  
  def count_less_than(A):
      left = 0
      right = len(fairsquares)
      while left < right:
          middle = (left + right) // 2
          if fairsquares[middle] < A:
              left = middle + 1
          else:
              right = middle
      return left
  
  
  def compute(A, B):
      count_b = count_less_than(B + 1)
      count_a = count_less_than(A)
      return count_b - count_a
  
  
  def parse():
      return map(int, sys.stdin.readline().strip().split())
  
  
  if __name__ == ""__main__"":
      read_fairsquares()
      T = int(sys.stdin.readline().strip())
      count = 1
      part = 0
      if len(sys.argv) == 3:
          part = int(sys.argv[1])
          count = int(sys.argv[2])
      for i in xrange(T):
          data = parse()
          if i * count >= part * T and i * count < (part + 1) * T:
              new = compute(*data)
              print ""Case #%d: %s"" % (i + 1, new)
",LABEL_27,LABEL_27,LABEL_12,1,"fairsquares,f,x,A,left,right,middle,B,count_b,count_a,T,count,part,i,data,result","fairsquares:0.04490713030099869,f:-0.00842207670211792,x:0.02377660572528839,A:0.039476171135902405,left:0.031266212463378906,right:0.0330839604139328,middle:0.04124148190021515,B:0.04835058003664017,count_b:0.045802198350429535,count_a:0.05286640673875809,T:0.03984062373638153,count:0.03668299317359924,part:0.0575416162610054,i:0.047994911670684814,data:0.03571750223636627,result:0.0605136975646019,",1,2,,0,0,Greedy,37,0.015212289492289225,replace,[],0.16601374745368958,0.16601374745368958
55," 
  
  if __name__ == ""__main__"":
      T = int(sys.stdin.readline().strip())
      for i in xrange(T):
          values = map(int, sys.stdin.readline().strip().split(' '))
          _N, S, p = values[0:3]
          t = values[3:]
          min_normal = p + 2 * max(0, p - 1)
          min_surprising = p + 2 * max(0, p - 2)
          cnt_normal = len(filter(lambda x : x >= min_normal, t))
          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal
          print ""Case #%d: %s"" % (i + 1, cnt_normal + min(cnt_surprising, S))
",150,,LABEL_27,LABEL_55,,-4,"T,i,values,_N,S,p,t,min_normal,min_surprising,cnt_normal,cnt_surprising",,,,,0,0,Greedy,1,0.0005651235580444336,,,0.22862450778484344,0.22862450778484344
56," 
  def get_generators_up_to_length_n(n):
      generators = []
      for ii in range(1, n + 1):
          generators += get_generators_length_n(ii)
      return generators        
  
  def get_generators_length_n(length):
      if length % 2 == 0: return get_even_generators_length_n(length)
      else: return get_odd_generators_length_n(length)
  
  def get_odd_generators_length_n(length):
      if length == 1: return [1, 2, 3]
      else: 
          n = length / 2
          generators = []
          for ii in range(min(n, 4)):
              for comb in itertools.combinations(range(1, n), ii):
                  first_half = [""1""] + [""0""] * (n-1)
                  for jj in comb:
                      first_half[jj] = ""1""
                  second_half = list(first_half)
                  second_half.reverse()
                  palin = first_half + [""0""] + second_half
                  generators.append(int("""".join([elem for elem in palin])))
                  palin[n] = ""1""
                  generators.append(int("""".join([elem for elem in palin])))
                  if ii <= 1:
                      palin[n] = ""2""
                      generators.append(int("""".join([elem for elem in palin])))
          generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (n - 1) + [""0""] + [""0""] * (n - 1) + [""2""])])))
          generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (n - 1) + [""1""] + [""0""] * (n - 1) + [""2""])])))
          generators.sort()
          return generators
  
  def get_even_generators_length_n(length):
      if length == 2: return [11, 22]
      n = length / 2
      generators = []
      for ii in range(min(n, 4)):
          for comb in itertools.combinations(range(1, n), ii):
              first_half = [""1""] + [""0""] * (n-1)
              for jj in comb:
                  first_half[jj] = ""1""
              second_half = list(first_half)
              second_half.reverse()
              palin = first_half + second_half
              generators.append(int("""".join([elem for elem in palin])))
      generators.append(int("""".join([elem for elem in ([""2""] + [""0""] * (length - 2) + [""2""])])))
      generators.sort()
      return generators
  
  def is_palin(num):
      string = str(num)
      length = len(string)
      ii = 0
      while ii < length/2:
          if string[ii] != string[-(1+ii)]:
              return False
          ii += 1
      return True
  
  def gen_fair_and_squares(upper_limit):
      fair_and_squares = []
      for ii in range(1, upper_limit + 1):
          if (is_palin(ii) and is_palin(ii*ii)):
              fair_and_squares.append(ii)
      return fair_and_squares
  
  f = open(sys.argv[1])
  T = int(f.readline())
  gens = get_generators_up_to_length_n(60)
  squares = map(lambda x: x*x, gens)
  
  for t in range(T):
      A, B = map(int, f.readline().strip().split())
      total = 0
      for elem in squares:
          assert(is_palin(elem))
          if elem >= A and elem <= B: total += 1
          if elem > B:
              break
  
      print ""Case #%d:"" % (t + 1), total
",721,,LABEL_28,LABEL_51,,-4,"n,generators,ii,length,comb,first_half,jj,second_half,palin,elem",,,,,0,0,Greedy,1,0.0007630546887715657,,,0.20052774250507355,0.20052774250507355
57," 
  f = open(sys.argv[1])
  T = int(f.readline())
  for t in range(T):
      temp = map(int, f.readline().split())
      N = temp[0]
      S = temp[1]
      p = temp[2]
      scores = temp[3:]
      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))
      if (p<=1):
          surprising_scores = 0
      else:
          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))
      num_scores = non_surprising_scores + min(surprising_scores, S)   
      print ""Case #%d:"" % (t + 1), num_scores
",158," 
  f = open(sys.argv[1])
  Q = int(f.readline())
  for name in range(Q):
       Temp = map(int, f.readline().split())
      n =  Temp[0]
      S =  Temp[1]
      p =  Temp[2]
      scores =  Temp[3:]
      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))
      if (p<=1):
          surprising_scores = 0
      else:
          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))
      num_compore = non_surprising_scores + min(surprising_scores, S)   
      print ""Case #%d:"" % (name + 1), num_compore
",LABEL_28,LABEL_28,LABEL_62,1,"f,T,t,temp,N,S,p,scores,non_surprising_scores,surprising_scores,num_scores","f:0.5340036749839783,T:0.5974047482013702,t:0.5998582541942596,temp:0.6169095933437347,N:0.611314058303833,S:0.5474558472633362,p:0.3940749168395996,scores:0.49175456166267395,non_surprising_scores:0.4710310697555542,surprising_scores:0.555498868227005,num_scores:0.6313565373420715,",1,2,"num_scores:num_compore,temp: Temp,N:n,t:type,",0,0,Greedy,110,0.040297404925028486,replace,[],0.9413756728172302,0.758384644985199
58," 
  
  		
  	
  def isPalindrome(S):
  	s = str(S) #so I dont need to make sure its a string
  	for i in range(len(s)//2):
  		if not s[i] == s[-1 - i]:
  			return False
  	return True
  
  def FairAndSquare(infile=""C-small-attempt0.in"", outfile=""C-small-attempt0.out""):
  	inF = open(infile, 'r')
  	outF = open(outfile, 'w')
  	
  	for t in range(1, int(inF.readline().strip()) + 1):
  		temp = inF.readline().strip().split()
  		A = long(temp[0])
  		B = long(temp[1])
  		count = long(0)
  		
  		i = long(math.ceil(math.sqrt(A)))
  		m = long(math.floor(math.sqrt(B)))
  		while i <= m:
  			if isPalindrome(i):
  				if isPalindrome(i**2):
  					count += 1
  			i += 1
  					
  		outF.write(""Case #"" + str(t) + "": "" + str(count) + ""
"")
  	
  	inF.close()
  	outF.close()
  	
  	f = open(outfile, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      FairAndSquare()
",248," 
  
  		
  	
  def isPalindrome(S):
  	s = str(S) #so I dont need to make sure its a string
  	for i in range(len(s)//2):
  		if not s[i] == s[-1 - i]:
  			return False
  	return True
  
  def FairAndSquare(Inbase=""C-small-attempt0.in"", outfile=""C-small-attempt0.out""):
  	inF = open(Inbase, 'r')
  	outF = open(outfile, 'w')
  	
  	for t in range(1, int(inF.readline().strip()) + 1):
  		temp = inF.readline().strip().split()
  		A = long(temp[0])
  		B = long(temp[1])
  		type = long(0)
  		
  		i = long(math.ceil(math.sqrt(A)))
  		m = long(math.floor(math.sqrt(B)))
  		while i <= m:
  			if isPalindrome(i):
  				if isPalindrome(i**2):
  					type += 1
  			i += 1
  					
  		outF.write(""Case #"" + str(t) + "": "" + str(type) + ""
"")
  	
  	inF.close()
  	outF.close()
  	
  	f = open(outfile, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      FairAndSquare()
",LABEL_29,LABEL_29,LABEL_53,1,"S,s,i,infile,outfile,inF,outF,t,temp,A,B,count,m,f","S:0.28165996074676514,s:0.2732067108154297,i:0.3731359839439392,infile:0.39495404064655304,outfile:0.3882372975349426,inF:0.31778255105018616,outF:0.38486117124557495,t:0.37860944867134094,temp:0.35699909925460815,A:0.3597237169742584,B:0.36074426770210266,count:0.4191489815711975,m:0.3609614670276642,f:0.3895310163497925,",1,2,"count:type,",0,0,Greedy,52,0.02037181854248047,replace,[],0.6433458924293518,0.5546406507492065
59,"data_dict = {}
  init = False
  
  
  def partB(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt"",\
                outfile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt""):
      
      linesA = []
      for line in open(infile, 'r'):
          linesA.append(line.strip())
  
      outA = []
          
      T = int(linesA[0])
      for i in range(1, 1 + T):
          caseA = linesA[i].split()
          N = int(caseA[0])
          S = int(caseA[1])
          P = int(caseA[2])
          
          over_norm = 0
          over_supr = 0
          
          for t in [int(conv) for conv in caseA[3:3+N]]:
              if data_dict[t][0] >= P:
                  over_norm += 1
              elif data_dict[t][1] >= P:
                  over_supr += 1
          
          outA.append(over_norm + min(over_supr, S))
              
              
          
      
      out = open(outfile, 'w')
      print ""
OUTPUT""
      for i in range(1, 1 + T):
          if i != 1:
              out.write(""
"")
          print ""Case #"" + str(i) + "": "" +str(outA[i-1])
          out.write(""Case #"" + str(i) + "": "" +str(outA[i-1]))
      out.close()
  
  def dict_helper(total, depth=0, lowest=10):
      pass
  
  def build_dict():
      for i in range(31):
          fullA = []
          maxN = 0
          maxS = 0
          print str(i) + "": ""
          for a1 in range(0,11):
              for a2 in range(0,11):
                  for a3 in range(0,11):
                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):
                          fullA.append((a1,a2,a3))
                          
                          print ""\t"", fullA[-1],
                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:
                              print ""*""
                              maxS = max(maxN, max(a1,a2,a3))
                          else:
                              print
                              maxN = max(maxN, max(a1,a2,a3))
          data_dict[i]=[maxN, maxS]
      init = True
      
  if __name__ == ""__main__"":
      build_dict()
      partB()
",463,"input_dict = {}
  random = False
  
  
  def partB(outfiles=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt"",\
                inf=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt""):
      
      linesB = []
      for inline in open(outfiles, 'r'):
          linesB.append(inline.strip())
  
       outC = []
          
      Test = int(linesB[0])
      for i in range(1, 1 + Test):
          codea = linesB[i].split()
          Len = int(codea[0])
          SK = int(codea[1])
          D = int(codea[2])
          
          Over__rand = 0
          over_descr = 0
          
          for u in [int(bit) for bit in codea[3:3+Len]]:
              if input_dict[u][0] >= D:
                  Over__rand += 1
              elif input_dict[u][1] >= D:
                  over_descr += 1
          
           outC.append(Over__rand + min(over_descr, SK))
              
              
          
      
      window = open(inf, 'w')
      print ""
OUTPUT""
      for i in range(1, 1 + Test):
          if i != 1:
              window.write(""
"")
          print ""Case #"" + str(i) + "": "" +str( outC[i-1])
          window.write(""Case #"" + str(i) + "": "" +str( outC[i-1]))
      window.close()
  
  def dict_helper(raw, input=0, lower=10):
      pass
  
  def build_dict():
      for i in range(31):
           fullY = []
          MaxC = 0
          tempP = 0
          print str(i) + "": ""
          for ga3 in range(0,11):
              for a2 in range(0,11):
                  for alpha1 in range(0,11):
                      if (ga3 + a2 + alpha1 == i) and (max(ga3,a2,alpha1)-min(ga3,a2,alpha1) <3):
                           fullY.append((ga3,a2,alpha1))
                          
                          print ""\t"",  fullY[-1],
                          if max(ga3,a2,alpha1)-min(ga3,a2,alpha1) == 2:
                              print ""*""
                              tempP = max(MaxC, max(ga3,a2,alpha1))
                          else:
                              print
                              MaxC = max(MaxC, max(ga3,a2,alpha1))
          input_dict[i]=[MaxC, tempP]
      random = True
      
  if __name__ == ""__main__"":
      build_dict()
      partB()
",LABEL_29,LABEL_29,,-1,"data_dict,init,infile,outfile,linesA,line,outA,T,i,caseA,N,S,P,over_norm,over_supr,t,conv,out,total,depth,lowest,fullA,maxN,maxS,a1,a2,a3","data_dict:0.011738717555999756,init:0.46074745059013367,infile:0.34874427318573,outfile:0.5058494210243225,linesA:0.3295900225639343,line:0.28930336236953735,outA:0.2954949736595154,T:0.1918773651123047,i:0.2521979808807373,caseA:0.36050546169281006,N:0.30306476354599,S:0.3112145662307739,P:0.18040931224822998,over_norm:0.32554763555526733,over_supr:0.4734637439250946,t:0.18587785959243774,conv:0.30361586809158325,out:0.23848116397857666,total:0.570305585861206,depth:0.5638515949249268,lowest:0.6001000702381134,fullA:0.576084315776825,maxN:0.35967129468917847,maxS:0.3558797240257263,a1:0.359533429145813,a2:0.354774534702301,a3:0.3567116856575012,",0,0,"lowest:lower,fullA: fullY,total:raw,depth:input,outfile:inf,over_supr:over_descr,init:random,caseA:codea,maxN:MaxC,a1:ga3,a3:alpha1,maxS:tempP,infile:winf,linesA:linesB,over_norm:Over__rand,S:SK,conv:bit,N:Len,outA: outC,line:inline,out:window,T:Test,t:u,P:D,data_dict:input_dict,",0,0,Greedy,543,0.2037754456202189,failed,[],0.9086903929710388,0.3677440583705902
60,"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  def isqrt(x):
      ""returns int(floor(sqrt(x))) using only integer math""
      assert x >= 0, 'Undefined %r' % locals()
      n = int(x)
      if n == 0:
          return 0
      a, b = divmod(n.bit_length(), 2)
      x = 2**(a+b)
      while True:
          y = (x + n//x)//2
          if y >= x:
              return x
          x = y
  
  def setup(infile):
      return locals()
  
  def reader(testcase, infile, **ignore):
      P = map(int, infile.next().split())
      return locals()
  
  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
  
      low = isqrt(P[0])
      high = isqrt(P[1])+1
  
      def is_pal(n):
          n = str(n)
          for i in range(len(n)/2+1):
              if n[i]!=n[len(n)-1-i]:
                  return False
          return True
  
      res = 0
      for i in range(low, high+1):
          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):
              res += 1
  
      return 'Case #%s: %s
' % (testcase, res)
  
  if __name__ == '__main__':
      T = int(sys.stdin.next())
      common = setup(sys.stdin)
      for t in xrange(1, T+1):
          sys.stdout.write(solver(**reader(t, **common)))
",331,"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  def isqrt(yy):
      ""returns int(floor(sqrt(x))) using only integer math""
      assert yy >= 0, 'Undefined %r' % locals()
      size = int(yy)
      if size == 0:
          return 0
      s, py = divmod(size.bit_length(), 2)
      yy = 2**(s+py)
      while True:
          yi = (yy + size//yy)//2
          if yi >= yy:
              return yy
          yy = yi
  
  def setup(inputline):
      return locals()
  
  def reader(trainCase, inputline, **ignore):
      L = map(int, inputline.next().split())
      return locals()
  
  def solver(inputline, trainCase, G=None, L=None, MI=None, Z=None, SH=None, CR=None, **ignore):
  
      loc = isqrt(L[0])
      range = isqrt(L[1])+1
  
      def is_pal(size):
          size = str(size)
          for l in range(len(size)/2+1):
              if size[l]!=size[len(size)-1-l]:
                  return False
          return True
  
      req = 0
      for l in range(loc, range+1):
          if L[0]<=l*l<=L[1] and is_pal(l) and is_pal(l*l):
              req += 1
  
      return 'Case #%s: %s
' % (trainCase, req)
  
  if __name__ == '__main__':
      Z = int(sys.stdin.next())
      total = setup(sys.stdin)
      for out in xrange(1, Z+1):
          sys.stdout.write(solver(**reader(out, **total)))
",LABEL_30,LABEL_30,,-1,"x,n,a,b,y,infile,testcase,P,N,I,T,S,C,low,high,i,res,common,t","x:0.8096815794706345,n:0.8717351704835892,a:0.882193811237812,b:0.9000268653035164,y:0.8970339223742485,infile:0.8791045993566513,testcase:0.8709418326616287,P:0.8755902275443077,N:0.9098818749189377,I:0.9088418111205101,T:0.9013373181223869,S:0.9069307148456573,C:0.9043596535921097,low:0.8997330740094185,high:0.8994914591312408,i:0.8678046762943268,res:0.9011175334453583,common:0.8973240181803703,t:0.9137662872672081,",0,0,"t:out,N:G,I:E,S:SH,C:U,T:Z,res:req,b:py,low:loc,high:range,common:total,y:value,a:s,infile:inputline,P:L,n:size,testcase:trainCase,i:l,x:j,",0,0,Greedy,392,0.14488437175750732,failed,[],0.98914635181427,0.9175482988357544
61,"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  
  
  class Solver(object):
      cache = {}
  
      def __init__(self, infile, testcase):
          self.testcase = testcase
          self.P = P = map(int, infile.next().split())
  
      def init_cache(self):
          if 'main' in self.cache:
              return
  
      def solve(self):
  
          N, S, p = self.P[:3]
          G = sorted(self.P[3:], reverse=True)
  
          r = 0
          s = 0
          for g in G:
              if g >= 3 * p - 2 and g >= p:
                  r += 1
              elif g >= 3 * p - 4 and g >= p:
                  if s == S:
                      break
                  r += 1
                  s += 1
  
          return r
  
  
  def main():
      T = int(sys.stdin.next())
      for t in xrange(T):
          sys.stdout.write('Case #%s: %s
' % (t + 1, Solver(sys.stdin, t).solve()))
  
  
  if __name__ == '__main__':
      main()
",212,"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  
  
  class Solver(object):
      run = {}
  
      def __init__(o, inputclass, trainCase):
          o.trainCase = trainCase
          o.Python = Python = map(int, inputclass.next().split())
  
      def init_cache(o):
          if 'main' in o.run:
              return
  
      def solve(o):
  
          NN, Z, py = o.Python[:3]
          GR = sorted(o.Python[3:], reverse=True)
  
          i = 0
          rors = 0
          for tg in GR:
              if tg >= 3 * py - 2 and tg >= py:
                  i += 1
              elif tg >= 3 * py - 4 and tg >= py:
                  if rors == Z:
                      break
                  i += 1
                  rors += 1
  
          return i
  
  
  def main():
      x = int(sys.stdin.next())
      for out in xrange(x):
          sys.stdout.write('Case #%s: %s
' % (out + 1, Solver(sys.stdin, out).solve()))
  
  
  if __name__ == '__main__':
      main()
",LABEL_30,LABEL_30,,-1,"cache,self,infile,testcase,P,N,S,p,G,r,s,g,T,t","cache:0.8896059319376945,self:0.8641229942440987,infile:0.866286538541317,testcase:0.893736943602562,P:0.8881140351295471,N:0.9084223583340645,S:0.8649882078170776,p:0.8868906125426292,G:0.8649740591645241,r:0.9047643840312958,s:0.8816515132784843,g:0.8581901416182518,T:0.9197211265563965,t:0.9230989404022694,",0,0,"t:out,T:x,N:NN,r:i,testcase:trainCase,cache:run,P:Python,p:py,s:cs,infile:inputclass,S:Z,G:GR,self:o,g:tg,",0,0,Greedy,292,0.10670730272928873,failed,[],0.9826776385307312,0.8657606840133667
62," 
  def is_fair(n):
      n = str(n)
      for i in range(long(len(n) / 2)):
          if n[i] != n[len(n) - i - 1]:
              return False
      return True
  
  def is_square_and_fair(n):
      if not is_fair(n): return False
      root = math.sqrt(n)
      if root != math.floor(root): return False
      if not is_fair(long(root)): return False
      return True
  
  def process():
      a, b = sys.stdin.readline().split()
      a = long(a)
      b = long(b)
      
      count = 0
      for i in range(a, b + 1):
          if is_square_and_fair(i): count = count + 1
  
      return count
  
  def main():
  
      count = int(sys.stdin.readline())
      for index in range(count):
          result = process()
          print ""Case #%d: %s"" % (index + 1, result)
  
  if __name__ == '__main__':
      main()
",207,,LABEL_31,LABEL_27,,-4,"n,i,root,a,b,count,index,result",,,,,0,0,Greedy,1,0.0005691289901733398,,,0.3149699866771698,0.3149699866771698
63," 
  
  def calculate_max_score(scores_sum):
      if scores_sum % 3 == 1:
          max_score = (scores_sum + 2) / 3
          return (max_score, max_score)
      if scores_sum % 3 == 2:
          max_score = (scores_sum + 1) / 3
          return (max_score, max_score + 1)
      max_score = scores_sum / 3
      if max_score == 0:
          return (0, 0)
      return (max_score, max_score + 1)
  
  def find_max_dancers(s, p, *scores_sums):
      dancers_count = 0
      for scores_sum in scores_sums:
          (normal_max, surprise_max) = calculate_max_score(scores_sum)
          if normal_max >= p:
              dancers_count = dancers_count + 1
              continue
          if surprise_max >= p and s > 0:
              s = s - 1
              dancers_count = dancers_count + 1
              continue
      return dancers_count
  
  def main():
  
      case_count = int(sys.stdin.readline())
  
      for case_index in range(1, case_count + 1):
          line = sys.stdin.readline().strip().split(' ')
          s = int(line[1])
          p = int(line[2])
          scores_sums = [int(scores_sum) for scores_sum in line[3:]]
          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))
  
  if __name__ == '__main__':
      main()
",243,,LABEL_31,LABEL_12,,-4,"scores_sum,max_score,s,p,dancers_count,normal_max,surprise_max,case_count,case_index,line,scores_sums",,,,,0,0,Greedy,1,0.00056534210840861,,,0.17048205435276031,0.17048205435276031
64,"'''
  Created on Apr 12, 2013
  
  @author: Moatasem
  '''
  
  
  
  def isPalindrome(word):
      isPalin=False
      if(len(word)%2==0):
          f_half=word[0:len(word)/2];
          s_half=word[len(word)/2:len(word)][::-1]
          if( f_half==s_half):
              isPalin= True
      else:
          f_half=word[0:len(word)/2]
          s_half=word[(len(word)/2)+1:len(word)][::-1]
          if( f_half==s_half):
              isPalin= True
      return isPalin
      
  def getNumberOfFairAndSquare(range_):
      start=range_[0]
      end=range_[1]
      count_=0
      for i in range(start,end+1):
          root=math.sqrt(i);
          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):
              count_+=1
      return count_
          
          
      
  
  f_r = open('C.in',""r"")
  n_test=int(f_r.readline().strip()) 
  f_w = open(""C.out"", ""w"")
  for i in range(n_test):
      range_ =map(int,f_r.readline().split())
      result=getNumberOfFairAndSquare(range_)
      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
      f_w.write(output_str+'
')
  f_r.close()
  f_w.close()
",291,"'''
  Created on Apr 12, 2013
  
  @author: Moatasem
  '''
  
  
  
  def isPalindrome(character):
      isSchatin=False
      if(len(character)%2==0):
          ssOhalf=character[0:len(character)/2];
          s_near=character[len(character)/2:len(character)][::-1]
          if( ssOhalf==s_near):
              isSchatin= True
      else:
          ssOhalf=character[0:len(character)/2]
          s_near=character[(len(character)/2)+1:len(character)][::-1]
          if( ssOhalf==s_near):
              isSchatin= True
      return isSchatin
      
  def getNumberOfFairAndSquare(rangePool):
      next=rangePool[0]
      end=rangePool[1]
      list2=0
      for phi in range(next,end+1):
          ip=math.sqrt(phi);
          if(ip.is_integer() and isPalindrome(str(int(ip))) and isPalindrome(str(phi))):
              list2+=1
      return list2
          
          
      
  
  f24sr = open('C.in',""r"")
   n__trial=int(f24sr.readline().strip()) 
  input_r = open(""C.out"", ""w"")
  for phi in range( n__trial):
      rangePool =map(int,f24sr.readline().split())
      resp=getNumberOfFairAndSquare(rangePool)
      output2temp='Case #{itr}: {res}'.format(itr=(phi+1),res=resp)
      input_r.write(output2temp+'
')
  f24sr.close()
  input_r.close()
",LABEL_32,LABEL_32,,-1,"word,isPalin,f_half,s_half,range_,start,end,count_,i,root,f_r,n_test,f_w,result,output_str","word:0.8459428548812866,isPalin:0.7650561332702637,f_half:0.7903556227684021,s_half:0.7625731378793716,range_:0.7833005338907242,start:0.7806811779737473,end:0.7814015448093414,count_:0.7795237004756927,i:0.808201938867569,root:0.7836951017379761,f_r:0.7596658021211624,n_test:0.7613961398601532,f_w:0.7359626144170761,result:0.786109670996666,output_str:0.7544219791889191,",0,0,"word:character,i:phi,f_half:ssOhalf,result:resp,root:ip,range_:rangePool,start:next,count_:list2,isPalin:isSchatin,s_half:s_near,n_test: n__trial,f_r:f24sr,output_str:output2temp,f_w:input_r,",0,0,Greedy,310,0.11395136912663778,failed,[],0.9335851669311523,0.8693848848342896
65,"'''
  Created on Apr 14, 2012
  
  @author: moatasem
  '''
  
  
  def isSurprising(t):
      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):
          return True
      else:
          return False
  
  
  def getAllTriplets(n):
      h=[]
      for i in xrange(11):
          for j in xrange(i,11):
              for  k in xrange(j,11):
                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):
                      h.append((i,j,k))
              
      return  h
  
  def getInfo(p,total,S):
      g= getAllTriplets(total)
      if(S):
          s_=len(g)
          indcies=[]
          for i in xrange (s_):
              if(isSurprising(g[i])):
                  indcies.append(i)
          for i in xrange (len(indcies)):  
              g.remove(g[indcies[i]])
      equ=False
      sur=False
      sur_equ=False
      for i in xrange(len(g)):
          if(max(g[i])>=p):
              if(isSurprising(g[i])):
                  sur_equ=True
              else:
                  equ=True
          elif(isSurprising(g[i])):
                  sur=True
      return sur_equ,equ,sur
             
  f = open(""b_.in"", ""r"")
  n=int(f.readline().strip())
  for k  in xrange(n):
      d=f.readline().strip()
      googlers=[]
      g=[int(i) for i in d.split("" "")]
      N=g[0]
      S=g[1]
      noSu=False
      if(S==0):
          noSu=True
      p=g[2]
      count=0
      equ_count=0;
      both_count=0;
      sur_count=0;
      first_count=0;
      googlers=g[3:len(g)]
      for o in xrange(N):
          info=getInfo(p,googlers[o],noSu)
          if(info[0]==True and info[1]==False and S<>0): #101 /100
              count+=1
              S-=1
          elif(info[0]==True and info[1]==True):#110 / 111
              first_count+=1
          elif(info[1]==True and info[2]==True):#011
              both_count+=1
          elif(info[1]==True):#010
              count+=1
          elif(info[2]==True):#001
              sur_count+=1
      count+=first_count
      if(S>0):
          if(first_count>S):
              S=0
          elif(first_count <=S) :
              S-=first_count
              if(S>0):
                   if(both_count>S):
                      both_count-=S
                      S=0
                   else:
                      both_count=0
      count+=both_count
      
      print 'Case #'+str((k+1))+"": ""+str(count)
  
  
  
  
  
  
  
  
  
  
      
  
",614,"'''
  Created on Apr 14, 2012
  
  @author: moatasem
  '''
  
  
  def isSurprising(tu):
      if(abs(tu[0]-tu[1])==2 or abs(tu[2]-tu[1])==2 or abs(tu[0]-tu[2])==2):
          return True
      else:
          return False
  
  
  def getAllTriplets(net):
      hand=[]
      for uri in xrange(11):
          for ijk in xrange(uri,11):
              for  ak in xrange(ijk,11):
                  if(uri+ijk+ak==net and abs(uri-ijk)<3 and abs(ak-ijk)<3 and abs(uri-ak)<3):
                      hand.append((uri,ijk,ak))
              
      return  hand
  
  def getInfo(jp,iter,SO):
      gc= getAllTriplets(iter)
      if(SO):
          sDiv=len(gc)
          indc=[]
          for uri in xrange (sDiv):
              if(isSurprising(gc[uri])):
                  indc.append(uri)
          for uri in xrange (len(indc)):  
              gc.remove(gc[indc[uri]])
      eight=False
      supp=False
      sur_en=False
      for uri in xrange(len(gc)):
          if(max(gc[uri])>=jp):
              if(isSurprising(gc[uri])):
                  sur_en=True
              else:
                  eight=True
          elif(isSurprising(gc[uri])):
                  supp=True
      return sur_en,eight,supp
             
  fore = open(""b_.in"", ""r"")
  net=int(fore.readline().strip())
  for ak  in xrange(net):
      b=fore.readline().strip()
      googlers=[]
      gc=[int(uri) for uri in b.split("" "")]
      A=gc[0]
      SO=gc[1]
      noSu=False
      if(SO==0):
          noSu=True
      jp=gc[2]
      count=0
      equ_count=0;
      both_len=0;
      sur_sum=0;
      first_count=0;
      googlers=gc[3:len(gc)]
      for o in xrange(A):
          info=getInfo(jp,googlers[o],noSu)
          if(info[0]==True and info[1]==False and SO<>0): #101 /100
              count+=1
              SO-=1
          elif(info[0]==True and info[1]==True):#110 / 111
              first_count+=1
          elif(info[1]==True and info[2]==True):#011
              both_len+=1
          elif(info[1]==True):#010
              count+=1
          elif(info[2]==True):#001
              sur_sum+=1
      count+=first_count
      if(SO>0):
          if(first_count>SO):
              SO=0
          elif(first_count <=SO) :
              SO-=first_count
              if(SO>0):
                   if(both_len>SO):
                      both_len-=SO
                      SO=0
                   else:
                      both_len=0
      count+=both_len
      
      print 'Case #'+str((ak+1))+"": ""+str(count)
  
  
  
  
  
  
  
  
  
  
      
  
",LABEL_32,LABEL_32,,-1,"t,n,h,i,j,k,p,total,S,g,s_,indcies,equ,sur,sur_equ,f,d,googlers,N,noSu,count,equ_count,both_count,sur_count,first_count,o,info","t:0.8569420427083969,n:0.7949928790330887,h:0.8177907019853592,i:0.7558214664459229,j:0.7438063323497772,k:0.6896140575408936,p:0.7833724170923233,total:0.7610731273889542,S:0.7721534222364426,g:0.7787755578756332,s_:0.6475197672843933,indcies:0.6221424043178558,equ:0.8276935964822769,sur:0.8380437791347504,sur_equ:0.752202719449997,f:0.7144603729248047,d:0.7751342207193375,googlers:0.678313672542572,N:0.7680675685405731,noSu:0.6436560750007629,count:0.8613514080643654,equ_count:0.7056101858615875,both_count:0.6793747544288635,sur_count:0.7074280381202698,first_count:0.6825688481330872,o:0.7838568836450577,info:0.8491814732551575,",0,0,"t:tu,sur:supp,equ:eight,h:hand,n:net,p:jp,g:gc,d:b,S:SO,N:A,total:iter,i:phi,sur_equ:sur_en,j:js,f:fore,sur_count:sur_sum,k:ak,both_count:both_len,s_:sDiv,indcies:indc,",0,0,Greedy,511,0.1962886134783427,failed,[],0.9844344258308411,0.7503744959831238
66," 
  def isqrt(num):
      return int(sqrt(num))
  
  def is_square(num):
      return isqrt(num)**2 == num
  
  def is_palindrome(num):
      return str(num) == """".join(reversed(str(num)))
  
  def is_fair_and_square(num):
      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))
  
  def solve(A,B):
      count = 0
      for i in range(A,B+1):
          if is_fair_and_square(i):
              count += 1
      return count
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1, T+1):
          A,B = [int(x) for x in raw_input().split()]
          print ""Case #%d: %d"" % (i, solve(A,B))
          
",169," 
  def isqrt(input):
      return int(sqrt(input))
  
  def is_square(input):
      return isqrt(input)**2 == input
  
  def is_palindrome(input):
      return str(input) == """".join(reversed(str(input)))
  
  def is_fair_and_square(input):
      return is_square(input) and is_palindrome(input) and is_palindrome(isqrt(input))
  
  def solve(A,B):
      count = 0
      for i in range(A,B+1):
          if is_fair_and_square(i):
              count += 1
      return count
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1, T+1):
          A,B = [int(x) for x in raw_input().split()]
          print ""Case #%d: %d"" % (i, solve(A,B))
          
",LABEL_33,LABEL_33,LABEL_3,1,"num,A,B,count,i,T,x","num:0.4187476858496666,A:0.4162118285894394,B:0.388769306242466,count:0.38319648057222366,i:0.40716949105262756,T:0.408152237534523,x:0.38669583201408386,",1,12,,0,0,Greedy,28,0.010909060637156168,replace,[],0.4999624490737915,0.4999624490737915
67,"def max_of_triplets(n):
      a = n//3
      if (n % 3) == 0:
          if a == 0 : return (0,0)
          return (a, a+1)
      if (n % 3) == 1:
          return (a+1, a+1)
      if a == 9: return (10, 10)
      return (a+1, a+2)
  
  def solve(scores, S, p):
      t = 0
      for s in scores:
          a,b = max_of_triplets(s)
          if a >= p:
              t += 1
          elif b >= p and S > 0:
              t += 1
              S -= 1
      return t
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1, T+1):
          nums = map(int, raw_input().strip().split())
          N = nums[0]
          S = nums[1]
          p = nums[2]
          scores = nums[3:]
          if len(scores) != N:
              print ""WTF"", i
          print ""Case #%d: %d"" % (i, solve(scores, S, p))
      
",225,"def max_of_triplets(ne):
      pa = ne//3
      if (ne % 3) == 0:
          if pa == 0 : return (0,0)
          return (pa, pa+1)
      if (ne % 3) == 1:
          return (pa+1, pa+1)
      if pa == 9: return (10, 10)
      return (pa+1, pa+2)
  
  def solve(core, Ns, lp):
      rt = 0
      for sets in core:
          pa,bc = max_of_triplets(sets)
          if pa >= lp:
              rt += 1
          elif bc >= lp and Ns > 0:
              rt += 1
              Ns -= 1
      return rt
  
  if __name__ == ""__main__"":
      Q = int(raw_input())
      for ui in range(1, Q+1):
           numps = map(int, raw_input().strip().split())
          N =  numps[0]
          Ns =  numps[1]
          lp =  numps[2]
          core =  numps[3:]
          if len(core) != N:
              print ""WTF"", ui
          print ""Case #%d: %d"" % (ui, solve(core, Ns, lp))
      
",LABEL_33,LABEL_33,,-1,"n,a,scores,S,p,t,s,b,T,i,nums,N","n:0.8189364522695541,a:0.8212422579526901,scores:0.8688185587525368,S:0.8772765025496483,p:0.8686138093471527,t:0.8354870527982712,s:0.815975695848465,b:0.8101820349693298,T:0.8792002275586128,i:0.890866219997406,nums:0.8820753842592239,N:0.8588901534676552,",0,0,"i:ui,nums: numps,T:Q,S:St,scores:core,p:lp,t:rt,a:pa,n:ne,s:sets,b:m,",0,0,Greedy,250,0.09102600415547689,failed,[],0.9784246683120728,0.9074769616127014
68," 
  def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( x ) for x in read_words() ]
  
  T = read_integer()
  for t in range( T ):
      A, B = read_integers()
      A_root = int( ceil( sqrt( A ) ) )
      B_root = int( floor( sqrt( B ) ) )
      count = 0
      for root in range( A_root, B_root + 1 ):
          word = str( root )
          if word == word[ : : -1 ]:
              word = str( root*root )
              if word == word[ : : -1 ]:
                  count += 1
      print 'Case #%i:' % ( t + 1 ), count
",164," 
  def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int(  X ) for  X in read_words() ]
  
  PT = read_integer()
  for text in range( PT ):
      OA, b = read_integers()
      A_roots = int( ceil( sqrt( OA ) ) )
      b_child = int( floor( sqrt( b ) ) )
      error = 0
      for nw in range( A_roots, b_child + 1 ):
          line = str( nw )
          if line == line[ : : -1 ]:
              line = str( nw*nw )
              if line == line[ : : -1 ]:
                  error += 1
      print 'Case #%i:' % ( text + 1 ), error
",LABEL_34,LABEL_34,,-1,"x,T,t,A,B,A_root,B_root,count,root,word","x:0.7565189450979233,T:0.7841331362724304,t:0.7842484414577484,A:0.7380466759204865,B:0.770546481013298,A_root:0.6997459232807159,B_root:0.6958406567573547,count:0.70728999376297,root:0.7576719969511032,word:0.7432113885879517,",0,0,"t:text,T:PT,B:b,root:nw,x: X,word:point,A:OA,count:key,A_root:A_roots,B_root:b_child,",0,0,Greedy,204,0.07363315423329671,failed,[],0.9844394326210022,0.9553403854370117
69,"def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( x ) for x in read_words() ]
  
  T = read_integer()
  for t in range( T ):
      print 'Case #%i:' % ( t + 1 ),
      line = iter( read_integers() )
      N = line.next()
      S = line.next()
      p = line.next()
      t = sorted( line )
      count = 0
      while t and ( t[ -1 ] + 2 )/3 >= p:
          t.pop()
          count += 1
      if p > 1:
          while S and t and ( t[ -1 ] + 4 )/3 >= p:
              t.pop()
              S -= 1
              count += 1
      print count
",178,"def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( i ) for i in read_words() ]
  
  ID = read_integer()
  for start in range( ID ):
      print 'Case #%i:' % ( start + 1 ),
      line = iter( read_integers() )
      P = line.next()
      n = line.next()
      p = line.next()
      start = sorted( line )
      call = 0
      while start and ( start[ -1 ] + 2 )/3 >= p:
          start.pop()
          call += 1
      if p > 1:
          while n and start and ( start[ -1 ] + 4 )/3 >= p:
              start.pop()
              n -= 1
              call += 1
      print call
",LABEL_34,LABEL_34,,-1,"x,T,t,line,N,S,p,count","x:0.735015869140625,T:0.7345818877220154,t:0.760755255818367,line:0.7403845489025116,N:0.6843503713607788,S:0.6272754371166229,p:0.6367725729942322,count:0.6779179871082306,",0,0,"t:start,x:i,T:ID,N:P,count:now,S:H,",0,0,Greedy,163,0.05889440377553304,failed,[],0.9873585104942322,0.979684591293335
70," 
  def isPalindrome(x):
      x = str(x)
      if x[0] != x[-1]:
          return 0
      y = x[::-1]
      if x == y:
          return 1
      return 0
  
  def generate():
      digits = [str(x) for x in range(0,10)]
      dplus = digits + [""""]
  
      for x in range(1,10):
          y = x**2
          if isPalindrome(y):
              print y
  
      for x in range(1,10**4):
          x = str(x)
          y = x[::-1]
          pals = [ int(x+z+y)**2 for z in dplus ]
          for p in pals:
              if isPalindrome(p):
                  print p
  
  if __name__ == ""__main__"":
      f = open( sys.argv[1] )
      sqpals = np.array([int(l) for l in f])
      sqpals.sort()
      f.close()
  
      f = open( sys.argv[2] )
      t = int(f.readline())
      t = 1
      for l in f:
          a,b = [int(x) for x in l.split()]
          mt = sqpals >= a
          lt = sqpals <= b
          output = sum( mt&lt )
          print ""Case #%s: %s""%(t,output)
          t += 1
      
",273,,LABEL_35,LABEL_13,,-4,"x,y,digits,dplus,pals,z,p,f,sqpals,l,t,a,b,mt,lt,output",,,,,0,0,Greedy,1,0.0006058414777119955,,,0.21804513037204742,0.21804513037204742
71," 
  
  if __name__ == ""__main__"":
  
      f = open( ""B-small-attempt1.in.txt"" )
      g = open( ""output_small.txt"", ""w"" )
  
      f.readline()
      line = f.readline()
      caseI = 1
      while line != """":
          line = [ int(x) for x in line.split() ]
          N = line[0]
          surprise = line[1]
          p = line[2]
          points = line[3:]
          points.sort()
          points.reverse()
  
          maxp = 0
          either = 0
          make_surprise = 0
          for x in points:
              this_p = (x+2)/3
              if x in [0,1,29,30]:
                  if this_p >= p:
                      maxp += 1
              elif this_p >= p:
                  either += 1
                  maxp += 1
              elif this_p == p-1 and (x+2)%3 > 0:
                  make_surprise += 1
              else:
                  either += 1
  
          if make_surprise >= surprise:
              make_surprise -= surprise
              maxp += surprise
              make_surprise = 0
          else:
              maxp += make_surprise
  
          g.write( ""Case #%s: %s
""%(caseI,maxp) )
  
          line = f.readline()
          caseI += 1
  
      f.close()
      g.close()
      
",223," 
  
  if __name__ == ""__main__"":
  
      log = open( ""B-small-attempt1.in.txt"" )
      out = open( ""output_small.txt"", ""w"" )
  
      log.readline()
      string = log.readline()
       casei = 1
      while string != """":
          string = [ int(name) for name in string.split() ]
          M = string[0]
          promvey = string[1]
          b = string[2]
          case = string[3:]
          case.sort()
          case.reverse()
  
          totalP = 0
          right = 0
          make_survey = 0
          for name in case:
               this_point = (name+2)/3
              if name in [0,1,29,30]:
                  if  this_point >= b:
                      totalP += 1
              elif  this_point >= b:
                  right += 1
                  totalP += 1
              elif  this_point == b-1 and (name+2)%3 > 0:
                  make_survey += 1
              else:
                  right += 1
  
          if make_survey >= promvey:
              make_survey -= promvey
              totalP += promvey
              make_survey = 0
          else:
              totalP += make_survey
  
          out.write( ""Case #%s: %s
""%( casei,totalP) )
  
          string = log.readline()
           casei += 1
  
      log.close()
      out.close()
      
",LABEL_35,LABEL_35,,-1,"f,g,line,caseI,x,N,surprise,p,points,maxp,either,make_surprise,this_p","f:0.19909024238586426,g:0.2824556231498718,line:0.2626344561576843,caseI:0.18706625699996948,x:0.282498300075531,N:0.3012785315513611,surprise:0.28391510248184204,p:0.23442226648330688,points:0.2711005210876465,maxp:0.2995767593383789,either:0.27955055236816406,make_surprise:0.2902219891548157,this_p:0.37846168875694275,",0,0,"this_p: this_point,N:M,maxp:totalP,make_surprise:make_survey,surprise:promvey,x:name,g:out,either:right,points:case,line:L,p:r,f:log,caseI: casei,",0,0,Greedy,266,0.09804672797520955,failed,[],0.8379743099212646,0.40325477719306946
72," 
  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]
  
  for case in xrange(codejam.readint()):
      A, B = map(int, codejam.readstring().split())
      count = 0
      for possible in possibles:
          if A > possible:
              continue
  
          if B < possible:
              break
  
          count += 1
  
      print ""Case #%d: %d"" % (case + 1, count)
",144,,LABEL_36,LABEL_45,,-4,"possibles,case,A,B,count,possible",,,,,0,0,Greedy,1,0.0005671143531799317,,,0.17264246940612793,0.17264246940612793
73," 
  def readint():
      return int(sys.stdin.readline())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(start=0):
      elems = readintarray()[start:]
      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
",102," 
  def readint():
      return int(sys.stdin.readline())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(count=0):
      Elemas = readintarray()[count:]
      return [Elemas[qi:qi+2] for qi in xrange(0, len(Elemas), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
",LABEL_36,LABEL_36,,-1,"start,elems,i","start:0.8952140063047409,elems:0.8096778243780136,i:0.8139501363039017,",0,0,"start:count,i:qi,elems:Elemas,",0,0,Greedy,64,0.02291489839553833,failed,[],0.9981865286827087,0.9947059750556946
74," 
  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
  	with file(filepath, 'rb') as f_in:
  		for line_index, line in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			yield line_index, line.strip().split(' ')
  
  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
  	with file(filepath, 'rb') as f_in:
  		case_counter = 1
  		case = []
  		for line_index, line in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			case.append(line.strip().split(' '))
  			if not line_index % n:
  				yield case_counter, case
  				case_counter += 1
  				case = []
  
  def iterate_cases_glpc(filepath):		#glpc - given lines per case
  	with file(filepath, 'rb') as f_in:
  		case_counter = 0
  		new_case = True
  		for line_index, line in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			if new_case:
  				new_case = False
  				case_counter += 1
  				case = []
  				assert len(line.strip().split(' ')) == 1
  				lines_left = int(line.strip())
  				if not lines_left:
  					new_case = True
  					yield case_counter, case
  				continue
  			if lines_left:
  				lines_left -= 1
  				case.append(line.strip().split(' '))
  			if not lines_left:
  				new_case = True
  				yield case_counter, case
  			
  def part_of_list_to_int(array, flags):
  	assert len(array) == len(flags)
  	output = []
  	for index, elem in enumerate(array):
  		if flags[index]:
  			output.append(int(elem))
  		else:
  			output.append(elem)
  	return output
  
  def list_to_int(array):
  	return part_of_list_to_int(array, [True] * len(array))
  
  def part_of_list_to_float(array, flags):
  	assert len(array) == len(flags)
  	output = []
  	for index, elem in enumerate(array):
  		if flags[index]:
  			output.append(float(elem))
  		else:
  			output.append(elem)
  	return output
  
  def list_to_float(array):
  	return part_of_list_to_float(array, [True] * len(array))
  
  def get_max_array_on_index(array, index):
  	elem_len = len(array[0])
  	assert index < elem_len
  	for elem in array:
  		assert elem_len == len(elem)
  	max_sub = array[0][index]
  	max_elem = array[0]
  	for elem in array:
  		if elem[index] > max_sub:
  			max_sub = elem[index]
  			max_elem = elem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  	
  def check_palindrome(value):
  	val_str = str(value)
  	length = len(val_str)
  	for i in xrange(length):
  		if val_str[i] != val_str[length - 1 - i]:
  			return False
  	return True
  
  def calc_result(case):
  	A = int(case[0])
  	B = int(case[1])
  	
  	A_sqrt = int(math.ceil(math.sqrt(A)))
  	B_sqrt = int(math.floor(math.sqrt(B)))
  	
  	print ""\tinterval: %s"" % [A, B]
  	print ""\tsqrt_int: %s"" % [A_sqrt, B_sqrt]
  	
  	count = 0
  	for i in xrange(A_sqrt, B_sqrt + 1):
  		if check_palindrome(i):
  			if check_palindrome(i * i):
  				count += 1
  				print ""\tfound: %d, %d"" % (i, i * i)
  	
  	print ""\ttot: %d"" % count
  	print 
  	result = ""%s"" % count
  	return result
  
  def main(filepath):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, case in iterate_cases_1lpc(filepath):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(case)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",820," 
  def iterate_cases_1lpc(fsize):	#1lpc = 1 line per case
  	with file(fsize, 'rb') as f_in:
  		for case_number, key in enumerate(f_in):
  			if case_number == 0: #T
  				continue
  			yield case_number, key.strip().split(' ')
  
  def iterate_cases_nlpc(fsize, ln):	#1lpc = n line per case
  	with file(fsize, 'rb') as f_in:
  		case_Counter = 1
  		address = []
  		for case_number, key in enumerate(f_in):
  			if case_number == 0: #T
  				continue
  			address.append(key.strip().split(' '))
  			if not case_number % ln:
  				yield case_Counter, address
  				case_Counter += 1
  				address = []
  
  def iterate_cases_glpc(fsize):		#glpc - given lines per case
  	with file(fsize, 'rb') as f_in:
  		case_Counter = 0
  		new_division = True
  		for case_number, key in enumerate(f_in):
  			if case_number == 0: #T
  				continue
  			if new_division:
  				new_division = False
  				case_Counter += 1
  				address = []
  				assert len(key.strip().split(' ')) == 1
  				lines_end = int(key.strip())
  				if not lines_end:
  					new_division = True
  					yield case_Counter, address
  				continue
  			if lines_end:
  				lines_end -= 1
  				address.append(key.strip().split(' '))
  			if not lines_end:
  				new_division = True
  				yield case_Counter, address
  			
  def part_of_list_to_int(analysis, ols):
  	assert len(analysis) == len(ols)
  	output = []
  	for index, elem in enumerate(analysis):
  		if ols[index]:
  			output.append(int(elem))
  		else:
  			output.append(elem)
  	return output
  
  def list_to_int(analysis):
  	return part_of_list_to_int(analysis, [True] * len(analysis))
  
  def part_of_list_to_float(analysis, ols):
  	assert len(analysis) == len(ols)
  	output = []
  	for index, elem in enumerate(analysis):
  		if ols[index]:
  			output.append(float(elem))
  		else:
  			output.append(elem)
  	return output
  
  def list_to_float(analysis):
  	return part_of_list_to_float(analysis, [True] * len(analysis))
  
  def get_max_array_on_index(analysis, index):
  	elem_len = len(analysis[0])
  	assert index < elem_len
  	for elem in analysis:
  		assert elem_len == len(elem)
  	max_sub = analysis[0][index]
  	max_elem = analysis[0]
  	for elem in analysis:
  		if elem[index] > max_sub:
  			max_sub = elem[index]
  			max_elem = elem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  	
  def check_palindrome(value):
  	val_str = str(value)
  	length = len(val_str)
  	for i in xrange(length):
  		if val_str[i] != val_str[length - 1 - i]:
  			return False
  	return True
  
  def calc_result(address):
  	A = int(address[0])
  	B = int(address[1])
  	
  	A_sqrt = int(math.ceil(math.sqrt(A)))
  	B_sqrt = int(math.floor(math.sqrt(B)))
  	
  	print ""\tinterval: %s"" % [A, B]
  	print ""\tsqrt_int: %s"" % [A_sqrt, B_sqrt]
  	
  	count = 0
  	for i in xrange(A_sqrt, B_sqrt + 1):
  		if check_palindrome(i):
  			if check_palindrome(i * i):
  				count += 1
  				print ""\tfound: %d, %d"" % (i, i * i)
  	
  	print ""\ttot: %d"" % count
  	print 
  	result = ""%s"" % count
  	return result
  
  def main(fsize):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, address in iterate_cases_1lpc(fsize):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(address)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",LABEL_37,LABEL_37,LABEL_52,1,"filepath,line_index,line,n,case_counter,case,new_case,lines_left,array,flags,output,index,elem","filepath:0.5259061455726624,line_index:0.6585812866687775,line:0.5218912363052368,n:0.6766757965087891,case_counter:0.575014740228653,case:0.5197466909885406,new_case:0.6963379979133606,lines_left:0.6581480801105499,array:0.6361957788467407,flags:0.5531862378120422,output:0.48920732736587524,index:0.6750682592391968,elem:0.561757355928421,",1,13,"new_case:new_division,n:ln,line_index:case_number,lines_left:lines_end,array:analysis,case_counter:case__count,flags:ols,filepath:fsize,line:key,",0,0,Greedy,252,0.10109419027964274,replace,[],0.9934036135673523,0.21158309280872345
75," 
  class Triplet(object):
  	def __init__(self, i, j, k):
  		self.i = i
  		self.j = j
  		self.k = k
  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))
  		self.valid = self.max_diff <= 2
  		self.surprise = self.max_diff == 2
  	
  	def get_tuple(self):
  		return (self.i, self.j, self.k)
  	
  	def get_redundancies(self):
  		return [(self.i, self.j, self.k),
  				(self.i, self.k, self.j),
  				(self.j, self.i, self.k),
  				(self.j, self.k, self.i),
  				(self.k, self.i, self.j),
  				(self.k, self.j, self.i)]
  
  class Googler(object):
  	def __init__(self, total_points):
  		self.total_points = total_points
  		self.regular_triplets = []
  		self.surprise_triplets = []
  		
  		for i in xrange(0, 11):
  			if i > total_points:
  				break
  			for j in xrange(i, 11):
  				if i + j > total_points:
  					break
  				k = total_points - i - j
  				if k > 10:
  					break
  				triplet = Triplet(i, j, k)
  				self.add(triplet)
  		
  		self.can_surprise = len(self.surprise_triplets) > 0
  		self.actual_triplet = None
  		self.best_result = -1
  		
  	def add(self, triplet):
  		if not triplet.valid:
  			return
  		if triplet.surprise:
  			self.add_uniquely(triplet, is_surprise=True)
  		else:
  			self.add_uniquely(triplet, is_surprise=False)
  			
  	def add_uniquely(self, triplet, is_surprise):
  		if is_surprise:
  			input_list = self.surprise_triplets
  		else:
  			input_list = self.regular_triplets
  		for triplet_redundancy in triplet.get_redundancies():
  			if triplet_redundancy in input_list:
  				return
  		input_list.append(triplet.get_tuple())
  	
  	def __str__(self):
  		return ""regular: %s
surprise: %s"" % (self.regular_triplets,
  											  self.surprise_triplets)
  	
  	def set_googler(self, is_surprise=False):
  		if not is_surprise:
  			self.actual_triplet = self.regular_triplets[0]
  		else:
  			self.actual_triplet = self.surprise_triplets[0]
  		self.calc_best_result()
  	
  	def calc_best_result(self):
  		self.best_result = max(self.actual_triplet)
  
  		
  class Contest(object):
  	def __init__(self, num_of_googlers, results):
  		self.num = num_of_googlers
  		self.googlers = []
  		for i in xrange(self.num):
  			self.googlers.append(Googler(results[i]))
  	
  	def calc(self, num_of_surprises, p):
  		max_googlers_over_p = 0
  		for surprise_perm in self.get_permutations(num_of_surprises):
  			if not self.validate_permutation(surprise_perm):
  				continue
  			count = 0
  			for index, googler in enumerate(self.googlers):
  				googler.set_googler(index in surprise_perm)
  				if googler.best_result >= p:
  					count += 1
  			if count >= max_googlers_over_p:
  				max_googlers_over_p = count
  		return max_googlers_over_p
  	
  	def get_permutations(self, num_of_surprises):
  		results = get_perms(0, self.num, num_of_surprises)
  		if not results:
  			return [[]]
  		return results
  	
  	def validate_permutation(self, perm):
  		for googler_index in perm:
  			if not self.googlers[googler_index].can_surprise:
  				return False
  		return True
  
  def get_perms(start_index, finish_index, amount):
  	if amount == 0:
  		return []
  	result_list = []
  	for i in xrange(start_index, finish_index):
  		if amount == 1:
  			result_list.append([i])
  			continue
  		for result in get_perms(i + 1, finish_index, amount - 1):
  			new_result = [i]
  			new_result.extend(result)
  			result_list.append(new_result)
  	return result_list
  		
  def main(filepath):
  	with file('dancing_output.txt', 'wb') as f_out:
  		with file(filepath, 'rb') as f_in:
  			for line_index, line in enumerate(f_in):
  				if line_index == 0: #T
  					continue
  				input_list = line.strip().split(' ')
  				num_of_googlers = int(input_list[0])
  				num_of_surprises = int(input_list[1])
  				p = int(input_list[2])
  				results = []
  				for res in input_list[3:]:
  					results.append(int(res))
  				contest = Contest(num_of_googlers, results)
  				result = contest.calc(num_of_surprises, p)
  				
  				print
  				print line.strip()
  				print result
  				
  				f_out.write(""Case #%d: %d
"" % (line_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",911,,LABEL_37,LABEL_26,,-4,"self,i,j,k,max_diff,valid,surprise,total_points,regular_triplets,surprise_triplets,triplet,can_surprise,actual_triplet,best_result,is_surprise,input_list,triplet_redundancy",,,,,0,0,Greedy,1,0.000835279623667399,,,0.17644190788269043,0.17644190788269043
76,"def IsPal(n):
      S = str(n);
      return S == S[::-1];
  
  
  def Gen():
      LIM = 10**14;
      N = 10**7;
      LIST = [];
      for i in range(1, N):
          if IsPal(i):
              if IsPal(i*i):
                  LIST.append(i);
      return LIST
  
  PP = Gen();
  
  T = int(raw_input());
  for q in range(1,T+1):
      [A,B] = map(int, raw_input().split());    
      ANS = 0;
      for i in range(len(PP)):
          if B >= PP[i]**2 >= A:
              ANS += 1;
      
      print ""Case #%d: %d"" %(q, ANS);
",165,,LABEL_38,LABEL_3,,-4,"n,S,LIM,N,LIST,i,PP,T,q,A,B,ANS",,,,,0,0,Greedy,1,0.0005091031392415365,,,0.7995021343231201,0.7995021343231201
77,"T = int(raw_input());
  for i in range(T):
     Data = map(int, raw_input().split());
     N = Data.pop(0);
     S = Data.pop(0);
     p = Data.pop(0);
     
     Good = 0;
     for score in Data:
        if score >= 3*p-2:
           Good += 1;
        else:
           if (S > 0) and (score >= 3*p-4) and (score >= p):
              S -= 1;
              Good += 1;
  
     print ""Case #%d:"" % (i+1),;
     print Good;
     
  
",127,"M = int(raw_input());
  for count in range(M):
     Dat = map(int, raw_input().split());
     Max = Dat.pop(0);
     n = Dat.pop(0);
     j = Dat.pop(0);
     
     Bu = 0;
     for est in Dat:
        if est >= 3*j-2:
           Bu += 1;
        else:
           if (n > 0) and (est >= 3*j-4) and (est >= j):
              n -= 1;
              Bu += 1;
  
     print ""Case #%d:"" % (count+1),;
     print Bu;
     
  
",LABEL_38,LABEL_38,,-1,"T,i,Data,N,S,p,Good,score","T:0.7448220700025558,i:0.6997019946575165,Data:0.7039875686168671,N:0.6928527355194092,S:0.6652639806270599,p:0.6472363471984863,Good:0.6255415380001068,score:0.546857088804245,",0,0,"T:M,Data:Dat,i:count,N:A,S:n,p:j,Good:Bu,score:est,",0,0,Greedy,164,0.058660022417704266,failed,[],0.9177491664886475,0.6865065693855286
78," 
  def isPalindrome(s):
    length = len(s)
    for i in xrange(length / 2):
      if s[i] != s[length - 1 - i]: 
        return False
    return True
  
  n = int(raw_input())
  for i in range(n):
    a, b = map(int, raw_input().strip().split(' '))
    count = 0
    for j in range(a, b+1):
      if isPalindrome(str(j)):
        s = math.sqrt(j)
        if s == int(s) and isPalindrome(str(int(s))):
          count += 1
    print 'Case #%i: %i' % (i+1, count)
",142," 
  def isPalindrome(s):
    distance = len(s)
    for it in xrange(distance / 2):
      if s[it] != s[distance - 1 - it]: 
        return False
    return True
  
   N = int(raw_input())
  for it in range( N):
    l, body = map(int, raw_input().strip().split(' '))
    name = 0
    for  l in range(l, body+1):
      if isPalindrome(str( l)):
        s = math.sqrt( l)
        if s == int(s) and isPalindrome(str(int(s))):
          name += 1
    print 'Case #%i: %i' % (it+1, name)
",LABEL_39,LABEL_39,,-1,"s,length,i,n,a,b,count,j","s:0.5368137657642365,length:0.6468868851661682,i:0.6210523843765259,n:0.6155870258808136,a:0.6652476787567139,b:0.6624152660369873,count:0.604947566986084,j:0.59229776263237,",0,0,"a:l,b:d,length:v,i:ui,n:m,count:int,j: p,",0,0,Greedy,158,0.05686021248499552,failed,[],0.9367881417274475,0.8164348602294922
79," 
  T = int(sys.stdin.readline())
  for i in range(T):
      line = sys.stdin.readline().strip()
      values = map(int, line.split(' '))
      N = values[0]
      S = values[1]
      p = values[2]
      totals = values[3:]
      ans = 0
      for total in totals:
          base = total / 3
          remainder = total - (base * 3)
          scores = [base, base, base]
          j = 0
          while remainder > 0:
              scores[j] += 1
              remainder -= 1
              j = (j + 1) % 3
          if max(scores) >= p:
              ans += 1
          else:
              if S > 0:
                  remainder = total - (base * 3)
                  if remainder == 0 and base > 0:
                      if base + 2 >= p:
                          ans += 1
                          S -= 1
                  elif base + min(remainder, 2) >= p:
                      ans += 1
                      S -= 1
      print 'Case #%s: %s' % (i+1, ans)
",205,,LABEL_39,LABEL_62,,-4,"T,i,line,values,N,S,p,totals,ans,total,base,remainder,scores,j",,,,,0,0,Greedy,1,0.0005951285362243653,,,0.343416690826416,0.343416690826416
80," 
  
  LIMIT = 10
  
  def check_palindrome(number):
      rev = 0
      runner = number
      while runner > 0:
          rev = rev * 10 + (runner % 10)
          runner /= 10
      if rev == number:
          return True
      else:
          return False
  
  def list_to_number(number_list):
      l = len(number_list)
      res = 0; rres = 0
      multi = 1
      for i in xrange(1, l + 1):
          res += number_list[l - i] * multi
          rres += number_list[i - 1] * multi
          multi *= 10
      return (res, rres)
  
  def gen_one_side(side_length):
      state = [0 for _ in xrange(side_length)]
      done = False
  
      while not done:
          if state[-1] != 0:
              yield state
          state[-1] += 1
          curr = side_length - 1
          while state[curr] == LIMIT:
              if curr == 0:
                  done = True
                  break
              state[curr] = 0
              curr -= 1
              state[curr] += 1
  
  def gen_odd_palindrome(side_length):
      if side_length == 0:
          for i in xrange(1, 10):
              yield i
      else:
          multi = 10**side_length
          for one_side in gen_one_side(side_length):
              number, rnumber = list_to_number(one_side)
              for i in xrange(LIMIT):
                  yield number + i * multi + rnumber * multi * 10
  
  def gen_even_palindrome(side_length):
      multi = 10**side_length
      for one_side in gen_one_side(side_length):
          number, rnumber = list_to_number(one_side)
          yield number + rnumber * multi
  
  
  def gen_palindrome():
      l = 1
  
      while True:
          if l % 2 == 1:
              for odd_pal in gen_odd_palindrome((l - 1) / 2):
                  yield odd_pal
          else:
              for even_pal in gen_even_palindrome(l / 2):
                  yield even_pal
          l += 1
  
  
  cache = []
  upper = 10**14
  for pal in gen_palindrome():
      pal2 = pal**2
      if pal2 > upper:
          break
      if check_palindrome(pal2):
          cache.append(pal2)
  
  cl = len(cache)
  T = int(raw_input().strip())
  for i in xrange(T):
      low_ind = 0
      high_ind = cl - 1
      A, B = map(int, raw_input().strip().split(' '))
  
      while cache[low_ind] < A:
          low_ind += 1
      while cache[high_ind] > B:
          high_ind -= 1
  
  
      if low_ind <= high_ind:
          print ""Case #%s: %s"" % (i + 1, high_ind - low_ind + 1)
      else:
          print ""Case #%s: 0"" % (i + 1)
",483,,LABEL_40,LABEL_45,,-4,"LIMIT,number,rev,runner,number_list,l,res,rres,multi,i,side_length,state,_,done,curr,one_side,rnumber,odd_pal,even_pal,cache,upper,pal,pal2",,,,,0,0,Greedy,1,0.0006711602210998536,,,0.14330892264842987,0.14330892264842987
81," 
  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]
  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]
  
  f = open(argv[1], 'r')
  T = int(f.readline().strip('
'))
  for i in range(T):
  	both = 0
  	surp_only = 0
  	line = f.readline().strip('
').split(' ')
  	N = int(line[0]) # What for?
  	S = int(line[1])
  	p = int(line[2])
  	ts = map(int, line[3:])
  	for t in ts:
  		if reduce(max, map(max, regular[t])) >= p:
  			both += 1
  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:
  			surp_only += 1
  
  	print ""Case #%s: %s"" % (i + 1, both + min(surp_only, S))
",761,,LABEL_40,LABEL_51,,-4,"surprising,regular",,,,,0,0,Greedy,1,0.0006644328435262045,,,0.05298012122511864,0.05298012122511864
82," 
  main = do
      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)
  
    where
      interval :: String -> (Int64, Int64)
      interval l =
          let [a, b] = map read $ splitOn "" "" l
          in (a, b)
  
      showCase :: (Int64, Int) -> String
      showCase (i, r) = printf ""Case #%d: %d"" i r
  
  solve :: (Int64, Int64) -> Int
  solve (a, b) =
      length $ takeWhile (<= b) $ dropWhile (< a) [ sq
          | x <- [0..], palindrome x, let sq = x * x, palindrome sq
          ]
    where
      square x = x * x
      start = truncate $ sqrt $ double a
  
  -- | Returns True if s is a palindrome.
  palindrome s =
      let s' = show s
      in s' == reverse s'
  
  double :: Int64 -> Double
  double = fromIntegral
",185," 
  log = do
      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)
  
    where
      interval :: String -> (Int64, Int64)
      interval lines =
          int [au, n] = map read $ splitOn "" "" lines
          in (au, n)
  
      showCase :: (Int64, Int) -> String
      showCase (i, r) = printf ""Case #%d: %d"" i r
  
  solve :: (Int64, Int64) -> Int
  solve (au, n) =
      length $ takeWhile (<= n) $ dropWhile (< au) [ sq
          | xx <- [0..], palindrome xx, int sq = xx * xx, palindrome sq
          ]
    where
      square xx = xx * xx
      case = truncate $ sqrt $ double au
  
  -- | Returns True if s is au palindrome.
  palindrome s =
      int s' = show s
      in s' == reverse s'
  
  double :: Int64 -> Double
  double = fromIntegral
",LABEL_41,LABEL_41,,-1,"main,l,let,a,b,x,start","main:0.8528813123703003,l:0.8353344649076462,let:0.7990405410528183,a:0.7744147330522537,b:0.7583764493465424,x:0.8420815169811249,start:0.829049363732338,",0,0,"main:log,x:xx,l:lines,start:case,let:int,a:au,b:n,",0,0,Greedy,148,0.05552763938903808,failed,[],0.9763617515563965,0.9248895049095154
83," 
  main = interact (unlines . map showCase . zip [1..] . tail . lines)
    where
      showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ solve t
  
  solve = show . solve' . map read . words
    where
      solve' (n:s:p:ts) = 
          let pts = map maxPoints ts
              directs = filter ((>= p) . fst) pts
              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts
          in length directs + min (length surps) s
          
  maxPoints :: Int -> (Int, Int)
  maxPoints tot = 
      (maxScore $ scores normal, maxScore $ scores surprising)
    where
      scores cond = [ (x, y, z) |
          x <- [0..10], y <- [0..10], z <- [0..10]
          , x + y + z == tot, cond (x, y, z)
          ]
      normal t = bestScore t - badScore t <= 1
      surprising t = bestScore t - badScore t <= 2
      maxScore = maximum . map bestScore 
  
  bestScore (x, y, z) = maximum [x, y, z]
  badScore (x, y, z) = minimum [x, y, z]
",255," 
  example = interact (unlines . map showCase . zip [1..] . tail . lines)
    where
      showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++  solution t
  
   solution = show .  solution' . map read . words
    where
       solution' (pos:s:p:ts) = 
          let pathsp = map maxPoints ts
              pathions = filter ((>= p) . fst) pathsp
              Surpes = filter (\(pd, ps) -> pd < p && ps >= p) pathsp
          in length pathions + min (length Surpes) s
          
  maxPoints :: Int -> (Int, Int)
  maxPoints tot = 
      (maxPoint $ scores normal, maxPoint $ scores surprising)
    where
      scores det = [ (x, y, z) |
          x <- [0..10], y <- [0..10], z <- [0..10]
          , x + y + z == tot, det (x, y, z)
          ]
      normal t = bestScore t - badScore t <= 1
      surprising t = bestScore t - badScore t <= 2
      maxPoint = maximum . map bestScore 
  
  bestScore (x, y, z) = maximum [x, y, z]
  badScore (x, y, z) = minimum [x, y, z]
",LABEL_41,LABEL_41,,-1,"main,solve,n,pts,directs,surps,tot,cond,t,maxScore","main:0.5655202269554138,solve:0.4950169324874878,n:0.44476068019866943,pts:0.4428418278694153,directs:0.4347747564315796,surps:0.4296726584434509,tot:0.4289259910583496,cond:0.43451255559921265,t:0.687801718711853,maxScore:0.425851047039032,",0,0,"main:example,solve: solution,n:pos,pts:pathsp,directs:pathions,cond:det,surps:Surpes,maxScore:maxPoint,",0,0,Greedy,211,0.08069018920262655,failed,[],0.9486913681030273,0.6407086253166199
84,"def checkpalin(s):
      k = len(s)//2
      for i in range(k):
          if s[i]!= s[-1-i]:
              return False
      return True
  
  goods = [1,2,3]
  
  for i in range(1000):
      for j in ['']+list(range(10)):
          test = str(i)+str(j)+(str(i)[::-1])
          if checkpalin(str(int(test)**2)):
              goods.append(int(test))
  goods = list(set(goods))
  goods.sort()
  
  T = int(input())
  
  for case in range(1,T+1):
      A,B = [int(x) for x in input().split()]
      ans = 0
      for n in goods:
          if A <= n*n <= B:
              ans += 1
      print(""Case #"",case,"": "",ans,sep='')
",207,"def checkpalin(sq):
      ks = len(sq)//2
      for ij in range(ks):
          if sq[ij]!= sq[-1-ij]:
              return False
      return True
  
  Goodes = [1,2,3]
  
  for ij in range(1000):
      for adj in ['']+list(range(10)):
          tri = str(ij)+str(adj)+(str(ij)[::-1])
          if checkpalin(str(int(tri)**2)):
              Goodes.append(int(tri))
  Goodes = list(set(Goodes))
  Goodes.sort()
  
  Case = int(input())
  
  for t in range(1,Case+1):
      A,B = [int(data) for data in input().split()]
      ans = 0
      for span in Goodes:
          if A <= span*span <= B:
              ans += 1
      print(""Case #"",t,"": "",ans,sep='')
",LABEL_42,LABEL_42,LABEL_58,1,"s,k,i,goods,j,test,T,case,A,B,x,ans,n","s:0.7455513626337051,k:0.705493152141571,i:0.701936200261116,goods:0.7562534958124161,j:0.6811157613992691,test:0.7048089653253555,T:0.7339396998286247,case:0.7710490673780441,A:0.6789760887622833,B:0.6753318458795547,x:0.6883430629968643,ans:0.6664648205041885,n:0.6882863193750381,",1,2,"case:t,goods:Goodes,s:sq,T:Case,k:ke,test:tri,i:ij,x:data,n:nu,",0,0,Greedy,208,0.07584635814030966,replace,[],0.8521872758865356,0.34195786714553833
85,"T=int(input())
  for t in range(T):
    l = [int(x) for x in input().split()]
    n,huh,p = l[:3]
    ss = l[3:]
    nice, maybe = 0,0
    for s in ss:
      if s>= p+2*max(p-1,0):
        nice += 1
      elif s>= p+2*max(p-2,0):
        maybe += 1
    y = nice + min(maybe,huh)
    print('Case #',t+1,': ',y,sep = '')
  
  
",128,"time=int(input())
  for qt in range(time):
    left = [int(ox) for ox in input().split()]
    n,Hoh,p = left[:3]
    css = left[3:]
    nice, picked = 0,0
    for np in css:
      if np>= p+2*max(p-1,0):
        nice += 1
      elif np>= p+2*max(p-2,0):
        picked += 1
    wy = nice + min(picked,Hoh)
    print('Case #',qt+1,': ',wy,sep = '')
  
  
",LABEL_42,LABEL_42,,-1,"T,t,l,x,n,huh,p,ss,nice,maybe,s,y","T:0.33357711136341095,t:0.2470768392086029,l:0.2910584509372711,x:0.26624560356140137,n:0.2733497619628906,huh:0.2249576449394226,p:0.2000463306903839,ss:0.2723127156496048,nice:0.25095461308956146,maybe:0.2119986116886139,s:0.24498248100280762,y:0.2452644258737564,",0,0,"T:time,l:left,ss:css,x:ox,t:qt,y:wy,s:np,huh:Hoh,maybe:picked,",0,0,Greedy,253,0.09049212535222372,failed,[],0.4927250146865845,0.1524050533771515
86," 
  
  
  
  problem = ""C""
  tag = ""small"" #commonly sample, small, or large
  suffix = ""-attempt0"" #used sometimes for indexing later input files
  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, 
  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, 
  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 
  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, 
  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, 
  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, 
  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, 
  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, 
  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 
  121000242000121, 121242363242121, 123212464212321, 123456787654321, 
  123862676268321, 144678292876441, 165551171155561, 400000080000004, 
  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, 
  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 
  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 
  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 
  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, 
  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, 
  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, 
  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 
  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 
  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 
  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, 
  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, 
  100020201040102020001, 100022201252102220001, 100024201484102420001, 
  100200120040021002001, 100202122050221202001, 100204124080421402001, 
  100220341262143022001, 100222343474343222001, 102010002040200010201, 
  102012022050220210201, 102014042080240410201, 102030405060504030201, 
  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, 
  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, 
  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, 
  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, 
  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, 
  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, 
  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, 
  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, 
  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, 
  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, 
  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, 
  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, 
  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,
  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, 
  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, 
  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, 
  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, 
  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489
  ])
  
  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,
         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,
         123454321, 125686521, 400080004, 404090404, 10000200001,
         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,
         1002003002001, 1004006004001, 1020304030201, 1022325232201,
         1024348434201, 1210024200121, 1212225222121, 1214428244121,
         1232346432321, 1234567654321, 4000008000004, 4004009004004,
         100000020000001, 100220141022001, 102012040210201, 102234363432201,
         121000242000121, 121242363242121, 123212464212321, 123456787654321,
         400000080000004, 10000000200000001, 10002000300020001,
         10004000600040001, 10020210401202001, 10022212521222001,
         10024214841242001, 10201020402010201, 10203040504030201,
         10205060806050201, 10221432623412201, 10223454745432201,
         12100002420000121, 12102202520220121, 12104402820440121,
         12122232623222121, 12124434743442121, 12321024642012321,
         12323244744232321, 12343456865434321, 12345678987654321,
         40000000800000004, 40004000900040004, 1000000002000000001,
         1000220014100220001, 1002003004003002001, 1002223236323222001,
         1020100204020010201, 1020322416142230201, 1022123226223212201,
         1022345658565432201, 1210000024200000121, 1210242036302420121,
         1212203226223022121, 1212445458545442121, 1232100246420012321,
         1232344458544432321, 1234323468643234321, 4000000008000000004,
         100000000020000000001, 100002000030000200001, 100004000060000400001,
         100020201040102020001, 100022201252102220001, 100024201484102420001,
         100200120040021002001, 100202122050221202001, 100204124080421402001,
         100220341262143022001, 100222343474343222001, 102010002040200010201,
         102012022050220210201, 102014042080240410201, 102030405060504030201,
         102032425272524230201, 102212122262221212201, 102214144272441412201,
         102232545484545232201, 102234567696765432201, 121000000242000000121,
         121002200252002200121, 121004400282004400121, 121022221262122220121,
         121024421474124420121, 121220122262221022121, 121222324272423222121,
         121242363484363242121, 121244565696565442121, 123210002464200012321,
         123212222474222212321, 123232425484524232321, 123234645696546432321,
         123432124686421234321, 123434346696643434321, 400000000080000000004,
         400004000090000400004, 10000000000200000000001,
         10000220001410002200001, 10002002100400120020001,
         10002222123632122220001, 10020010200400201002001,
         10020230421612403202001, 10022014302620341022001,
         10022234545854543222001, 10201000020402000010201,
         10201222221612222210201, 10203022140604122030201,
         10203244363836344230201, 10221210222622201212201,
         10221432643834623412201, 10223234344844343232201,
         12100000002420000000121, 12100242003630024200121,
         12102202302620320220121, 12102444325852344420121,
         12122010222622201022121, 12122252443834425222121,
         12124214524842541242121, 12321000024642000012321,
         12321244225852244212321, 12323222344844322232321,
         12343210246864201234321, 40000000000800000000004,
         1000000000002000000000001, 1000002000003000002000001,
         1000004000006000004000001, 1000020200104010020200001,
         1000022200125210022200001, 1000024200148410024200001,
         1000200030004000300020001, 1000202030205020302020001,
         1000204030408040304020001, 1000220232126212320220001,
         1000222232347432322220001, 1002001002004002001002001,
         1002003004005004003002001, 1002005006008006005002001,
         1002021222306032221202001, 1002023224327234223202001,
         1002201232026202321022001, 1002203234227224323022001,
         1002221454348434541222001, 1002223456569656543222001,
         1020100000204020000010201, 1020102020205020202010201,
         1020104040208020404010201, 1020120402306032040210201,
         1020122422327232242210201, 1020302030406040302030201,
         1020304050607060504030201, 1020322434528254342230201,
         1020324454749474544230201, 1022121002226222001212201,
         1022123024227224203212201, 1022141424528254241412201,
         1022143446549456443412201, 1022323232448442323232201,
         1022325254649464525232201, 1210000000024200000000121,
         1210002200025200022000121, 1210004400028200044000121,
         1210022220126210222200121, 1210024420147410244200121,
         1210220032026202300220121, 1210222232227222322220121,
         1210242254148414522420121, 1210244454369634544420121,
         1212201002226222001022121, 1212203204227224023022121,
         1212223242528252423222121, 1212225444549454445222121,
         1212421234248424321242121, 1212423436449446343242121,
         1232100000246420000012321, 1232102220247420222012321,
         1232122422348432242212321, 1232124642369632464212321,
         1232322032448442302232321, 1232324252649462524232321,
         1234321002468642001234321, 1234323224469644223234321,
         4000000000008000000000004, 4000004000009000004000004,
         100000000000020000000000001, 100000220000141000022000001,
         100002002010040010200200001, 100002222012363210222200001,
         100020001200040002100020001, 100020221222161222122020001,
         100022003410262014300220001, 100022223434585434322220001,
         100200100020040020001002001, 100200320240161042023002001,
         100202104032060230401202001, 100202324254383452423202001,
         100220121220262022121022001, 100220341462383264143022001,
         100222125432484234521222001, 102010000002040200000010201,
         102010222202161202222010201, 102012022032060230220210201,
         102012244234383432442210201, 102030201204060402102030201,
         102030423426181624324030201, 102032223434282434322230201,
         102212100022262220001212201, 102212322442383244223212201,
         102214124054282450421412201, 102232321224484422123232201,
         121000000000242000000000121, 121000242000363000242000121,
         121002202210262012202200121, 121002444212585212444200121,
         121022001220262022100220121, 121022243242383242342220121,
         121024203630484036302420121, 121220100022262220001022121,
         121220342242383242243022121, 121222304234282432403222121,
         121242121242484242121242121, 123210000002464200000012321,
         123210244202585202442012321, 123212222232484232222212321,
         123232201224484422102232321, 123432100024686420001234321,
         400000000000080000000000004, 10000000000000200000000000001,
         10000002000000300000020000001, 10000004000000600000040000001,
         10000020200010401000202000001, 10000022200012521000222000001,
         10000024200014841000242000001, 10000200021000400012000200001,
         10000202021020502012020200001, 10000204021040804012040200001,
         10000220221212621212202200001, 10000222221234743212222200001,
         10002000102000400020100020001, 10002002102200500220120020001,
         10002004102400800420140020001, 10002020304030603040302020001,
         10002022304232723240322020001, 10002200143002620034100220001,
         10002202143222722234120220001, 10002220345234843254302220001,
         10002222345456965454322220001, 10020010000200400200001002001,
         10020012002200500220021002001, 10020014004200800240041002001,
         10020030220410601402203002001, 10020032222412721422223002001,
         10020210221220602212201202001, 10020212223240704232221202001,
         10020230441632823614403202001, 10020232443654945634423202001,
         10022012102202620220121022001, 10022014104402720440141022001,
         10022032324432823442323022001, 10022034326634943662343022001,
         10022212343224842234321222001, 10022214345444944454341222001,
         10201000000020402000000010201, 10201002020020502002020010201,
         10201004040020802004040010201, 10201020402030603020402010201,
         10201022422032723022422010201, 10201202021220602212020210201,
         10201204041240704214040210201, 10201222423432823432422210201,
         10201224443454945434442210201, 10203020102040604020102030201,
         10203022122240704222122030201, 10203040506070807060504030201,
         10203042526272927262524030201, 10203222143242824234122230201,
         10203224163462926436142230201, 10221210000222622200001212201,
         10221212022222722222021212201, 10221230422432823422403212201,
         10221232444434943444423212201, 10221412221442824412221412201,
         10221414243462926434241412201, 10223232102244844220123232201,
         10223234124444944442143232201, 12100000000002420000000000121,
         12100002200002520000220000121, 12100004400002820000440000121,
         12100022220012621002222000121, 12100024420014741002442000121,
         12100220023002620032002200121, 12100222223022722032222200121,
         12100242243214841234224200121, 12100244443236963234444200121,
         12102200102202620220100220121, 12102202302402720420320220121,
         12102222324232823242322220121, 12102224524434943442542220121,
         12102420145204840254102420121, 12102422345424942454322420121,
         12122010000222622200001022121, 12122012202222722220221022121,
         12122032240432823404223022121, 12122034442434943424443022121,
         12122230223242824232203222121, 12122232425262926252423222121,
         12124212102424842420121242121, 12124214304624942640341242121,
         12321000000024642000000012321, 12321002220024742002220012321,
         12321022422034843022422012321, 12321024642036963024642012321,
         12321222023224842232022212321, 12321224243244944234242212321,
         12323220102244844220102232321, 12323222322444944422322232321,
         12343210000246864200001234321, 12343212222246964222221234321,
         40000000000000800000000000004, 40000004000000900000040000004,
         1000000000000002000000000000001, 1000000220000014100000220000001,
         1000002002001004001002002000001, 1000002222001236321002222000001,
         1000020000300004000030000200001, 1000020220302216122030220200001,
         1000022002321026201232002200001, 1000022222323458543232222200001,
         1000200010020004000200100020001, 1000200230042016102400320020001,
         1000202012221206021222102020001, 1000202232243438343422322020001,
         1000220012320026200232100220001, 1000220232344238324432320220001,
         1000222014541248421454102220001, 1002001000002004002000001002001,
         1002001220222016102220221002001, 1002003004005006005004003002001,
         1002003224225238325224223002001, 1002021020302206022030201202001,
         1002021240524418144250421202001, 1002023024325228225234203202001,
         1002201210022026202200121022001, 1002201430264038304620341022001,
         1002203214225228225224123022001, 1002221232322248422232321222001,
         1020100000000204020000000010201, 1020100222200216120022220010201,
         1020102022021206021202202010201, 1020102244221438341224422010201,
         1020120200302206022030020210201, 1020120422504418144052240210201,
         1020122222343228223432222210201, 1020302010020406040200102030201,
         1020302232242418142422322030201, 1020304032241608061422304030201,
         1020322212322428242232122230201, 1022121000002226222000001212201,
         1022121222422238322242221212201, 1022123024025228225204203212201,
         1022141220304428244030221412201, 1022323210022448442200123232201,
         1210000000000024200000000000121, 1210000242000036300002420000121,
         1210002202201026201022022000121, 1210002444201258521024442000121,
         1210022000320026200230002200121, 1210022242322238322232422200121,
         1210024202541048401452024200121, 1210220010022026202200100220121,
         1210220252044038304402520220121, 1210222212423228223242122220121,
         1210242012342048402432102420121, 1212201000002226222000001022121,
         1212201242222238322222421022121, 1212203204205228225024023022121,
         1212223020322428242230203222121, 1212421210024248424200121242121,
         1232100000000246420000000012321, 1232100244200258520024420012321,
         1232102222221248421222222012321, 1232122200322248422230022212321,
         1232322010022448442200102232321, 1234321000002468642000001234321,
         4000000000000008000000000000004], dtype=object)
  
  
  def read_input(infile):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int(infile.readline().strip())
      def read_ints():
          return np.array(infile.readline().split(), dtype=int)
      def read_bigints():
          line = infile.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float(infile.readline().strip())
      def read_floats():
          return np.array(infile.readline().split(), dtype=float)
      def read_string():
          return infile.readline().strip()
      def read_strings():
          return np.array(infile.readline().split(), dtype=object) #change the dtype?
      
      A, B = read_bigints()
      
      return (A, B)
  
  def is_palindrome(num):
      digits = []
      num = int(num)
      while num > 0:
          digits.append(num % 10)
          num = num / 10 #n.b. int division (discard remainder)
  
      return digits == digits[::-1]
  
      for i in range(len(digits) / 2): #n.b. int division (skips center)
          if digits[i] != digits[-i+1]:
              return False
      return True
  
  def solve_case_simple(case):
      A, B = case
      
      if B > table_of_fairs[-1]:
          raise ValueError, ""Ranges too big for lookup table!""
      
      valid = (A <= filtered_table) * (filtered_table <= B)
      return valid.sum()
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      output = solve_case_simple(case)
      return output
  
  
  if __name__ == ""__main__"":
      infile = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
      
      cases = int(infile.readline().strip('
'))
      for i in range(cases):
          
          case = read_input(infile)
          
          output = solve_case(case)
          
          outfile.write('Case #%i: %s
' % (i+1, output))
          print 'Case #%i: %s
' % (i+1, output)
      
      infile.close()
      outfile.close()
",2241," 
  
  
  
  problem = ""C""
  include = ""small"" #commonly sample, small, or large
  suffix = ""-attempt0"" #used sometimes for indexing later input files
  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, 
  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, 
  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 
  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, 
  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, 
  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, 
  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, 
  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, 
  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, 
  121000242000121, 121242363242121, 123212464212321, 123456787654321, 
  123862676268321, 144678292876441, 165551171155561, 400000080000004, 
  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, 
  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, 
  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, 
  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, 
  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, 
  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, 
  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, 
  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, 
  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, 
  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, 
  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, 
  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, 
  100020201040102020001, 100022201252102220001, 100024201484102420001, 
  100200120040021002001, 100202122050221202001, 100204124080421402001, 
  100220341262143022001, 100222343474343222001, 102010002040200010201, 
  102012022050220210201, 102014042080240410201, 102030405060504030201, 
  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, 
  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, 
  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, 
  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, 
  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, 
  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, 
  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, 
  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, 
  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, 
  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, 
  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, 
  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, 
  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,
  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, 
  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, 
  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, 
  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, 
  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489
  ])
  
  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,
         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,
         123454321, 125686521, 400080004, 404090404, 10000200001,
         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,
         1002003002001, 1004006004001, 1020304030201, 1022325232201,
         1024348434201, 1210024200121, 1212225222121, 1214428244121,
         1232346432321, 1234567654321, 4000008000004, 4004009004004,
         100000020000001, 100220141022001, 102012040210201, 102234363432201,
         121000242000121, 121242363242121, 123212464212321, 123456787654321,
         400000080000004, 10000000200000001, 10002000300020001,
         10004000600040001, 10020210401202001, 10022212521222001,
         10024214841242001, 10201020402010201, 10203040504030201,
         10205060806050201, 10221432623412201, 10223454745432201,
         12100002420000121, 12102202520220121, 12104402820440121,
         12122232623222121, 12124434743442121, 12321024642012321,
         12323244744232321, 12343456865434321, 12345678987654321,
         40000000800000004, 40004000900040004, 1000000002000000001,
         1000220014100220001, 1002003004003002001, 1002223236323222001,
         1020100204020010201, 1020322416142230201, 1022123226223212201,
         1022345658565432201, 1210000024200000121, 1210242036302420121,
         1212203226223022121, 1212445458545442121, 1232100246420012321,
         1232344458544432321, 1234323468643234321, 4000000008000000004,
         100000000020000000001, 100002000030000200001, 100004000060000400001,
         100020201040102020001, 100022201252102220001, 100024201484102420001,
         100200120040021002001, 100202122050221202001, 100204124080421402001,
         100220341262143022001, 100222343474343222001, 102010002040200010201,
         102012022050220210201, 102014042080240410201, 102030405060504030201,
         102032425272524230201, 102212122262221212201, 102214144272441412201,
         102232545484545232201, 102234567696765432201, 121000000242000000121,
         121002200252002200121, 121004400282004400121, 121022221262122220121,
         121024421474124420121, 121220122262221022121, 121222324272423222121,
         121242363484363242121, 121244565696565442121, 123210002464200012321,
         123212222474222212321, 123232425484524232321, 123234645696546432321,
         123432124686421234321, 123434346696643434321, 400000000080000000004,
         400004000090000400004, 10000000000200000000001,
         10000220001410002200001, 10002002100400120020001,
         10002222123632122220001, 10020010200400201002001,
         10020230421612403202001, 10022014302620341022001,
         10022234545854543222001, 10201000020402000010201,
         10201222221612222210201, 10203022140604122030201,
         10203244363836344230201, 10221210222622201212201,
         10221432643834623412201, 10223234344844343232201,
         12100000002420000000121, 12100242003630024200121,
         12102202302620320220121, 12102444325852344420121,
         12122010222622201022121, 12122252443834425222121,
         12124214524842541242121, 12321000024642000012321,
         12321244225852244212321, 12323222344844322232321,
         12343210246864201234321, 40000000000800000000004,
         1000000000002000000000001, 1000002000003000002000001,
         1000004000006000004000001, 1000020200104010020200001,
         1000022200125210022200001, 1000024200148410024200001,
         1000200030004000300020001, 1000202030205020302020001,
         1000204030408040304020001, 1000220232126212320220001,
         1000222232347432322220001, 1002001002004002001002001,
         1002003004005004003002001, 1002005006008006005002001,
         1002021222306032221202001, 1002023224327234223202001,
         1002201232026202321022001, 1002203234227224323022001,
         1002221454348434541222001, 1002223456569656543222001,
         1020100000204020000010201, 1020102020205020202010201,
         1020104040208020404010201, 1020120402306032040210201,
         1020122422327232242210201, 1020302030406040302030201,
         1020304050607060504030201, 1020322434528254342230201,
         1020324454749474544230201, 1022121002226222001212201,
         1022123024227224203212201, 1022141424528254241412201,
         1022143446549456443412201, 1022323232448442323232201,
         1022325254649464525232201, 1210000000024200000000121,
         1210002200025200022000121, 1210004400028200044000121,
         1210022220126210222200121, 1210024420147410244200121,
         1210220032026202300220121, 1210222232227222322220121,
         1210242254148414522420121, 1210244454369634544420121,
         1212201002226222001022121, 1212203204227224023022121,
         1212223242528252423222121, 1212225444549454445222121,
         1212421234248424321242121, 1212423436449446343242121,
         1232100000246420000012321, 1232102220247420222012321,
         1232122422348432242212321, 1232124642369632464212321,
         1232322032448442302232321, 1232324252649462524232321,
         1234321002468642001234321, 1234323224469644223234321,
         4000000000008000000000004, 4000004000009000004000004,
         100000000000020000000000001, 100000220000141000022000001,
         100002002010040010200200001, 100002222012363210222200001,
         100020001200040002100020001, 100020221222161222122020001,
         100022003410262014300220001, 100022223434585434322220001,
         100200100020040020001002001, 100200320240161042023002001,
         100202104032060230401202001, 100202324254383452423202001,
         100220121220262022121022001, 100220341462383264143022001,
         100222125432484234521222001, 102010000002040200000010201,
         102010222202161202222010201, 102012022032060230220210201,
         102012244234383432442210201, 102030201204060402102030201,
         102030423426181624324030201, 102032223434282434322230201,
         102212100022262220001212201, 102212322442383244223212201,
         102214124054282450421412201, 102232321224484422123232201,
         121000000000242000000000121, 121000242000363000242000121,
         121002202210262012202200121, 121002444212585212444200121,
         121022001220262022100220121, 121022243242383242342220121,
         121024203630484036302420121, 121220100022262220001022121,
         121220342242383242243022121, 121222304234282432403222121,
         121242121242484242121242121, 123210000002464200000012321,
         123210244202585202442012321, 123212222232484232222212321,
         123232201224484422102232321, 123432100024686420001234321,
         400000000000080000000000004, 10000000000000200000000000001,
         10000002000000300000020000001, 10000004000000600000040000001,
         10000020200010401000202000001, 10000022200012521000222000001,
         10000024200014841000242000001, 10000200021000400012000200001,
         10000202021020502012020200001, 10000204021040804012040200001,
         10000220221212621212202200001, 10000222221234743212222200001,
         10002000102000400020100020001, 10002002102200500220120020001,
         10002004102400800420140020001, 10002020304030603040302020001,
         10002022304232723240322020001, 10002200143002620034100220001,
         10002202143222722234120220001, 10002220345234843254302220001,
         10002222345456965454322220001, 10020010000200400200001002001,
         10020012002200500220021002001, 10020014004200800240041002001,
         10020030220410601402203002001, 10020032222412721422223002001,
         10020210221220602212201202001, 10020212223240704232221202001,
         10020230441632823614403202001, 10020232443654945634423202001,
         10022012102202620220121022001, 10022014104402720440141022001,
         10022032324432823442323022001, 10022034326634943662343022001,
         10022212343224842234321222001, 10022214345444944454341222001,
         10201000000020402000000010201, 10201002020020502002020010201,
         10201004040020802004040010201, 10201020402030603020402010201,
         10201022422032723022422010201, 10201202021220602212020210201,
         10201204041240704214040210201, 10201222423432823432422210201,
         10201224443454945434442210201, 10203020102040604020102030201,
         10203022122240704222122030201, 10203040506070807060504030201,
         10203042526272927262524030201, 10203222143242824234122230201,
         10203224163462926436142230201, 10221210000222622200001212201,
         10221212022222722222021212201, 10221230422432823422403212201,
         10221232444434943444423212201, 10221412221442824412221412201,
         10221414243462926434241412201, 10223232102244844220123232201,
         10223234124444944442143232201, 12100000000002420000000000121,
         12100002200002520000220000121, 12100004400002820000440000121,
         12100022220012621002222000121, 12100024420014741002442000121,
         12100220023002620032002200121, 12100222223022722032222200121,
         12100242243214841234224200121, 12100244443236963234444200121,
         12102200102202620220100220121, 12102202302402720420320220121,
         12102222324232823242322220121, 12102224524434943442542220121,
         12102420145204840254102420121, 12102422345424942454322420121,
         12122010000222622200001022121, 12122012202222722220221022121,
         12122032240432823404223022121, 12122034442434943424443022121,
         12122230223242824232203222121, 12122232425262926252423222121,
         12124212102424842420121242121, 12124214304624942640341242121,
         12321000000024642000000012321, 12321002220024742002220012321,
         12321022422034843022422012321, 12321024642036963024642012321,
         12321222023224842232022212321, 12321224243244944234242212321,
         12323220102244844220102232321, 12323222322444944422322232321,
         12343210000246864200001234321, 12343212222246964222221234321,
         40000000000000800000000000004, 40000004000000900000040000004,
         1000000000000002000000000000001, 1000000220000014100000220000001,
         1000002002001004001002002000001, 1000002222001236321002222000001,
         1000020000300004000030000200001, 1000020220302216122030220200001,
         1000022002321026201232002200001, 1000022222323458543232222200001,
         1000200010020004000200100020001, 1000200230042016102400320020001,
         1000202012221206021222102020001, 1000202232243438343422322020001,
         1000220012320026200232100220001, 1000220232344238324432320220001,
         1000222014541248421454102220001, 1002001000002004002000001002001,
         1002001220222016102220221002001, 1002003004005006005004003002001,
         1002003224225238325224223002001, 1002021020302206022030201202001,
         1002021240524418144250421202001, 1002023024325228225234203202001,
         1002201210022026202200121022001, 1002201430264038304620341022001,
         1002203214225228225224123022001, 1002221232322248422232321222001,
         1020100000000204020000000010201, 1020100222200216120022220010201,
         1020102022021206021202202010201, 1020102244221438341224422010201,
         1020120200302206022030020210201, 1020120422504418144052240210201,
         1020122222343228223432222210201, 1020302010020406040200102030201,
         1020302232242418142422322030201, 1020304032241608061422304030201,
         1020322212322428242232122230201, 1022121000002226222000001212201,
         1022121222422238322242221212201, 1022123024025228225204203212201,
         1022141220304428244030221412201, 1022323210022448442200123232201,
         1210000000000024200000000000121, 1210000242000036300002420000121,
         1210002202201026201022022000121, 1210002444201258521024442000121,
         1210022000320026200230002200121, 1210022242322238322232422200121,
         1210024202541048401452024200121, 1210220010022026202200100220121,
         1210220252044038304402520220121, 1210222212423228223242122220121,
         1210242012342048402432102420121, 1212201000002226222000001022121,
         1212201242222238322222421022121, 1212203204205228225024023022121,
         1212223020322428242230203222121, 1212421210024248424200121242121,
         1232100000000246420000000012321, 1232100244200258520024420012321,
         1232102222221248421222222012321, 1232122200322248422230022212321,
         1232322010022448442200102232321, 1234321000002468642000001234321,
         4000000000000008000000000000004], dtype=object)
  
  
  def read_input(infile):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int(infile.readline().strip())
      def read_ints():
          return np.array(infile.readline().split(), dtype=int)
      def read_bigints():
          line = infile.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float(infile.readline().strip())
      def read_floats():
          return np.array(infile.readline().split(), dtype=float)
      def read_string():
          return infile.readline().strip()
      def read_strings():
          return np.array(infile.readline().split(), dtype=object) #change the dtype?
      
      A, B = read_bigints()
      
      return (A, B)
  
  def is_palindrome(num):
      digits = []
      num = int(num)
      while num > 0:
          digits.append(num % 10)
          num = num / 10 #n.b. int division (discard remainder)
  
      return digits == digits[::-1]
  
      for i in range(len(digits) / 2): #n.b. int division (skips center)
          if digits[i] != digits[-i+1]:
              return False
      return True
  
  def solve_case_simple(case):
      A, B = case
      
      if B > table_of_fairs[-1]:
          raise ValueError, ""Ranges too big for lookup table!""
      
      valid = (A <= filtered_table) * (filtered_table <= B)
      return valid.sum()
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      output = solve_case_simple(case)
      return output
  
  
  if __name__ == ""__main__"":
      infile = open(""%s-%s%s.in"" % (problem, include, suffix), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, include, suffix), 'w')
      
      cases = int(infile.readline().strip('
'))
      for i in range(cases):
          
          case = read_input(infile)
          
          output = solve_case(case)
          
          outfile.write('Case #%i: %s
' % (i+1, output))
          print 'Case #%i: %s
' % (i+1, output)
      
      infile.close()
      outfile.close()
",LABEL_43,LABEL_43,LABEL_21,1,"problem,tag,suffix,table_of_fairs","problem:0.11193108558654785,tag:0.1183139830827713,suffix:0.07256415486335754,table_of_fairs:0.1093989759683609,",1,3,,0,0,Greedy,25,0.013268272082010904,replace,[],0.2766833007335663,0.2766833007335663
87," 
  
  case = 1
  problem = ""B""
  practice = False
  
  if practice:
      practice = ""-practice""
  else:
      practice = ""-attempt0""
  if case == 0:
      infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
  elif case == 1:
      infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
  elif case == 2:
      infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  lookup = {}
  
  def check_total(total, p):
      assert type(total) == int
      resid = total % 3
  
      min_nosurprise = (total / 3)    
      max_nosurprise = (total / 3) + min(1, resid)
      
      
      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):
          if max_nosurprise >= p:
              return 1
          else:
              return -1
  
      if max_nosurprise >= p:
          return 1
      elif max_nosurprise == p-1:
          return 0
      else:
          return -1
      
  cases = int(infile.readline().strip('
'))
  for i in range(cases):
      print 'case %i of %i' % (i+1, cases)
      line = infile.readline().split()
      N = int(line[0])
      S = int(line[1])
      p = int(line[2])
      points = []
      for item in line[3:]:
          points.append(int(item))
      assert N == len(points)
      assert p <= 10
      assert p >= 0
      assert S >= 0
      assert S <= N
      
      always = 0
      possible = 0
      
      for total in points:
          if (total, p) in lookup:
              depends = lookup[total, p]
          else:
              depends = check_total(total, p)
          
          if depends == 1:
              always += 1
          elif depends == 0:
              possible += 1
      
      output = '%i' % (always + min(possible, S))
      
      outfile.write('Case #%i: %s
' % (i+1, output))
      
  infile.close()
  outfile.close()
",444," 
  
  case = 1
  fit = ""B""
  practice = False
  
  if practice:
      practice = ""-practice""
  else:
      practice = ""-attempt0""
  if case == 0:
      infile = open(""%s-%s%s.in"" % (fit, ""sample"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (fit, ""sample"", practice), 'w')        
  elif case == 1:
      infile = open(""%s-%s%s.in"" % (fit, ""small"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (fit, ""small"", practice), 'w')    
  elif case == 2:
      infile = open(""%s-%s%s.in"" % (fit, ""large"", practice), 'r')
      outfile = open(""%s-%s%s.out"" % (fit, ""large"", practice), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  lookup = {}
  
  def check_total(total, p):
      assert type(total) == int
      resid = total % 3
  
      min_nosurprise = (total / 3)    
      max_nosurprise = (total / 3) + min(1, resid)
      
      
      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):
          if max_nosurprise >= p:
              return 1
          else:
              return -1
  
      if max_nosurprise >= p:
          return 1
      elif max_nosurprise == p-1:
          return 0
      else:
          return -1
      
  cases = int(infile.readline().strip('
'))
  for i in range(cases):
      print 'case %i of %i' % (i+1, cases)
      line = infile.readline().split()
      N = int(line[0])
      S = int(line[1])
      p = int(line[2])
      points = []
      for item in line[3:]:
          points.append(int(item))
      assert N == len(points)
      assert p <= 10
      assert p >= 0
      assert S >= 0
      assert S <= N
      
      always = 0
      possible = 0
      
      for total in points:
          if (total, p) in lookup:
              depends = lookup[total, p]
          else:
              depends = check_total(total, p)
          
          if depends == 1:
              always += 1
          elif depends == 0:
              possible += 1
      
      output = '%i' % (always + min(possible, S))
      
      outfile.write('Case #%i: %s
' % (i+1, output))
      
  infile.close()
  outfile.close()
",LABEL_43,LABEL_43,LABEL_19,1,"case,problem,practice,infile,outfile,lookup,total,p,resid,min_nosurprise,max_nosurprise,cases,i,line,N,S,points,item,always,possible","case:0.32312677800655365,problem:0.3504106402397156,practice:0.33597229421138763,infile:0.3155888468027115,outfile:0.26033079624176025,lookup:0.08378463983535767,total:0.27067703008651733,p:0.0190432071685791,resid:0.17171329259872437,min_nosurprise:0.01934826374053955,max_nosurprise:-0.0040705204010009766,cases:0.034724652767181396,i:0.23395496606826782,line:-0.031943559646606445,N:0.04391014575958252,S:0.03993266820907593,points:0.20626378059387207,item:0.19149741530418396,always:0.13305768370628357,possible:0.1459837555885315,",1,7,,0,0,Greedy,41,0.01755423148473104,replace,[],0.5635631084442139,0.5635631084442139
88," 
  
  def is_palindrome(num):
      s1 = str(num)
      s2 = s1[::-1]
      return s1 == s2
  
  fair_numbers = []
  for i in range(pow(10, 7)+1):
      if is_palindrome(i):
          num = i*i
          if is_palindrome(num):
              fair_numbers.append(num)
  
  N = int(sys.stdin.readline())
  for T in range(1, N+1):
      min_val, max_val = map(int, sys.stdin.readline().strip().split())
  
      ans = 0
      for num in fair_numbers:
          if num < min_val:
              continue
          if num > max_val:
              break
          ans += 1
      print 'Case #%(T)s: %(ans)s' % locals()
",144," 
  
  def is_palindrome(name):
      hs3 = str(name)
      s0 = hs3[::-1]
      return hs3 == s0
  
  fair_pnals = []
  for z in range(pow(10, 7)+1):
      if is_palindrome(z):
          name = z*z
          if is_palindrome(name):
              fair_pnals.append(name)
  
  NC = int(sys.stdin.readline())
  for G in range(1, NC+1):
      min__value, max__pid = map(int, sys.stdin.readline().strip().split())
  
      cas = 0
      for name in fair_pnals:
          if name < min__value:
              continue
          if name > max__pid:
              break
          cas += 1
      print 'Case #%(T)s: %(ans)s' % locals()
",LABEL_44,LABEL_44,,-1,"num,s1,s2,fair_numbers,i,N,T,min_val,max_val,ans","num:0.5635379552841187,s1:0.587831512093544,s2:0.6089282184839249,fair_numbers:0.5743742138147354,i:0.5993140786886215,N:0.6216247826814651,T:0.6422437280416489,min_val:0.6084320396184921,max_val:0.59062460064888,ans:0.5661669671535492,",0,0,"T:G,N:NC,s2:s0,min_val:min__value,i:z,max_val:max__pid,s1:hs3,fair_numbers:fair_pnals,ans:cas,num:name,",0,0,Greedy,200,0.07212980190912882,failed,[],0.8033303618431091,0.42522063851356506
89," 
  
  for i, line in enumerate(sys.stdin):
      if i == 0:
          continue
  
      params = [int(n) for n in line.split(' ')]
      (N, S, p) = params[:3]
      scores = params[3:]
  
      (clear, possible) = (0, 0)
      normal_min = max(p * 3 - 2, 0)
      suprising_min = max(p * 3 - 4, 0)
      for score in scores:
          if p > score:
              continue
          elif score >= normal_min:
              clear += 1
          elif score >= suprising_min:
              possible += 1
  
      ans = clear + min(possible, S)
      print 'Case #%(i)s: %(ans)s' % locals()
",133," 
  
  for chi, _ in enumerate(sys.stdin):
      if chi == 0:
          continue
  
      args = [int(net) for net in _.split(' ')]
      (SN, Sc, case) = args[:3]
      scores = args[3:]
  
      (valid, Possible) = (0, 0)
      normal67main = max(case * 3 - 2, 0)
      supraising_min = max(case * 3 - 4, 0)
      for score in scores:
          if case > score:
              continue
          elif score >= normal67main:
              valid += 1
          elif score >= supraising_min:
              Possible += 1
  
      ces = valid + min(Possible, Sc)
      print 'Case #%(i)s: %(ans)s' % locals()
",LABEL_44,LABEL_44,,-1,"i,line,params,n,N,S,p,scores,clear,possible,normal_min,suprising_min,score,ans","i:0.7664834558963776,line:0.7042499929666519,params:0.6848662346601486,n:0.7324659675359726,N:0.7810918688774109,S:0.786005362868309,p:0.7738246619701385,scores:0.7773149460554123,clear:0.7685950398445129,possible:0.7594357132911682,normal_min:0.774583250284195,suprising_min:0.7856615409255028,score:0.7468913197517395,ans:0.7868594825267792,",0,0,"ans:ces,S:Sc,suprising_min:supraising_min,N:SN,normal_min:normal67main,p:case,clear:present,i:chi,possible:Possible,n:net,line:de,params:args,",0,0,Greedy,277,0.09987232287724813,failed,[],0.9047500491142273,0.4203382432460785
90," 
  
  
  def calculatepalindromes(ndigits):
      if ndigits == 1:
          return 3
  
      result = 0
      isEven = ndigits % 2 == 0
      fillingdigits = math.floor((ndigits - 2)/2)
  
      if isEven:
          result += 1
      else:
          result += 3
  
      for numones in range(0, min(6, fillingdigits) + 1):
          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))
          result += combinations
          if not isEven:
              result += combinations
  
      return result
  
  
  def findpalindromes(ndigits):
      if ndigits == 1:
          return [1, 2, 3]
  
      result = []
      isEven = ndigits % 2 == 0
      fillingdigits = math.floor((ndigits - 2)/2)
  
      if isEven:
          result.append(int(""2"" + ""0""*(fillingdigits*2) + ""2""))
      else:
          result.append(int(""2"" + ""0""*fillingdigits + ""0"" + ""0""*fillingdigits + ""2""))
          result.append(int(""2"" + ""0""*fillingdigits + ""1"" + ""0""*fillingdigits + ""2""))
          result.append(int(""1"" + ""0""*fillingdigits + ""2"" + ""0""*fillingdigits + ""1""))
  
      for numones in range(0, min(6, fillingdigits)+1):
          ones = fillOnes([], fillingdigits, numones)
          for o in ones:
              if isEven:
                  result.append(int(""1"" + """".join(o) + """".join(list(reversed(o))) + ""1""))
              else:
                  result.append(int(""1"" + """".join(o) + ""0"" + """".join(list(reversed(o))) + ""1""))
                  result.append(int(""1"" + """".join(o) + ""1"" + """".join(list(reversed(o))) + ""1""))
  
      return result
  
  def fillOnes(combination, size, remainingOnes):
      if len(combination) == size:
          return [combination]
      result = []
      if remainingOnes > 0:
          c = combination + [""1""]
          result += fillOnes(c, size, remainingOnes - 1)
      if remainingOnes < size - len(combination):
          c = combination + [""0""]
          result += fillOnes(c, size, remainingOnes)
      return result
  
  
  
  ncases = int(sys.stdin.readline())
  
  for t in range(1, ncases+1):
      fairsquare = 0
      (a, b) = sys.stdin.readline().strip().split("" "")
      intA = int(a)
      intB = int(b)
      ndigitsA = len(a)
      ndigitsB = len(b)
      ndigitsARooted = math.ceil(ndigitsA/2)
      ndigitsBRooted = math.ceil(ndigitsB/2)
  
      if ndigitsBRooted == ndigitsARooted:
          palindromes = findpalindromes(ndigitsARooted)
          for p in palindromes:
              if p ** 2 >= intA and p ** 2 <= intB:
                  fairsquare +=1
      else:
          palindromes = findpalindromes(ndigitsARooted)
          for p in palindromes:
              if p ** 2 >= intA:
                  fairsquare +=1
  
          for i in range(ndigitsARooted + 1, ndigitsBRooted):
              fairsquare += calculatepalindromes(i)
  
          palindromes = findpalindromes(ndigitsBRooted)
          for p in palindromes:
              if p ** 2 <= intB:
                  fairsquare +=1
  
      print(""Case #%d: %d"" % (t, fairsquare))
",650," 
  
  
  def calculatepalindromes(ndigits):
      if ndigits == 1:
          return 3
  
      result = 0
      isEven = ndigits % 2 == 0
      falingdigit = math.floor((ndigits - 2)/2)
  
      if isEven:
          result += 1
      else:
          result += 3
  
      for numones in range(0, min(6, falingdigit) + 1):
          combinations = int(math.factorial(falingdigit) / (math.factorial(falingdigit-numones) * math.factorial(numones)))
          result += combinations
          if not isEven:
              result += combinations
  
      return result
  
  
  def findpalindromes(ndigits):
      if ndigits == 1:
          return [1, 2, 3]
  
      result = []
      isEven = ndigits % 2 == 0
      falingdigit = math.floor((ndigits - 2)/2)
  
      if isEven:
          result.append(int(""2"" + ""0""*(falingdigit*2) + ""2""))
      else:
          result.append(int(""2"" + ""0""*falingdigit + ""0"" + ""0""*falingdigit + ""2""))
          result.append(int(""2"" + ""0""*falingdigit + ""1"" + ""0""*falingdigit + ""2""))
          result.append(int(""1"" + ""0""*falingdigit + ""2"" + ""0""*falingdigit + ""1""))
  
      for numones in range(0, min(6, falingdigit)+1):
          ones = fillOnes([], falingdigit, numones)
          for o in ones:
              if isEven:
                  result.append(int(""1"" + """".join(o) + """".join(list(reversed(o))) + ""1""))
              else:
                  result.append(int(""1"" + """".join(o) + ""0"" + """".join(list(reversed(o))) + ""1""))
                  result.append(int(""1"" + """".join(o) + ""1"" + """".join(list(reversed(o))) + ""1""))
  
      return result
  
  def fillOnes(combination, size, remainingOnes):
      if len(combination) == size:
          return [combination]
      result = []
      if remainingOnes > 0:
          c = combination + [""1""]
          result += fillOnes(c, size, remainingOnes - 1)
      if remainingOnes < size - len(combination):
          c = combination + [""0""]
          result += fillOnes(c, size, remainingOnes)
      return result
  
  
  
  ncases = int(sys.stdin.readline())
  
  for t in range(1, ncases+1):
      fairsquare = 0
      (a, b) = sys.stdin.readline().strip().split("" "")
      intA = int(a)
      intB = int(b)
      ndigitsA = len(a)
      ndigitsB = len(b)
      ndigitsARooted = math.ceil(ndigitsA/2)
      ndigitsBRooted = math.ceil(ndigitsB/2)
  
      if ndigitsBRooted == ndigitsARooted:
          palindromes = findpalindromes(ndigitsARooted)
          for p in palindromes:
              if p ** 2 >= intA and p ** 2 <= intB:
                  fairsquare +=1
      else:
          palindromes = findpalindromes(ndigitsARooted)
          for p in palindromes:
              if p ** 2 >= intA:
                  fairsquare +=1
  
          for i in range(ndigitsARooted + 1, ndigitsBRooted):
              fairsquare += calculatepalindromes(i)
  
          palindromes = findpalindromes(ndigitsBRooted)
          for p in palindromes:
              if p ** 2 <= intB:
                  fairsquare +=1
  
      print(""Case #%d: %d"" % (t, fairsquare))
",LABEL_45,LABEL_45,LABEL_24,1,"ndigits,result,isEven,fillingdigits,numones,combinations,ones,o","ndigits:0.017644189298152924,result:-0.057406216859817505,isEven:0.013515621423721313,fillingdigits:0.028924576938152313,numones:-0.025450214743614197,combinations:0.028202049434185028,ones:-0.15801893174648285,o:-0.20199649035930634,",1,14,,0,0,Greedy,29,0.012225377559661865,replace,[],0.12721069157123566,0.12721069157123566
91," 
  
  def findbest(score):
  	if score == 0: return (0, 0)
  
  	best = math.ceil(score / 3)
  	bestsurp = round(score / 3) + 1
  
  	return (best, bestsurp)
  	
  sys.stdin.readline()
  
  casenum = 0
  for line in sys.stdin:
  	casenum += 1
  
  	data = line.strip().split(' ')
  	maxsurprising = int(data[1])
  	p = int(data[2])
  	scores = data[3:]
  	maxgooglers = 0
  
  	for s in scores:
  		(best, bestsurp) = findbest(int(s))
  		if best >= p:
  			maxgooglers += 1
  		else:
  			if bestsurp >= p and maxsurprising > 0:
  				maxgooglers += 1
  				maxsurprising -= 1
  
  	print(""Case #%d: %d"" % (casenum, maxgooglers))
",156," 
  
  def findbest(score):
  	if score == 0: return (0, 0)
  
  	best = math.ceil(score / 3)
  	bestsurp = round(score / 3) + 1
  
  	return (best, bestsurp)
  	
  sys.stdin.readline()
  
  casenum = 0
  for line in sys.stdin:
  	casenum += 1
  
  	case = line.strip().split(' ')
  	maxsurprising = int(case[1])
  	p = int(case[2])
  	Score = case[3:]
  	maxgooglers = 0
  
  	for set in Score:
  		(best, bestsurp) = findbest(int(set))
  		if best >= p:
  			maxgooglers += 1
  		else:
  			if bestsurp >= p and maxsurprising > 0:
  				maxgooglers += 1
  				maxsurprising -= 1
  
  	print(""Case #%d: %d"" % (casenum, maxgooglers))
",LABEL_45,LABEL_45,LABEL_26,1,"score,best,bestsurp,casenum,line,data,maxsurprising,p,scores,maxgooglers,s","score:0.34928934276103973,best:0.3558517098426819,bestsurp:0.2488286793231964,casenum:0.2870888411998749,line:0.34336115419864655,data:0.3597158342599869,maxsurprising:0.3125411421060562,p:0.30210965871810913,scores:0.3738224282860756,maxgooglers:0.27897822856903076,s:0.3636103421449661,",1,4,"scores:Score,s:set,",0,0,Greedy,72,0.027048095067342123,replace,[],0.48311489820480347,0.39717891812324524
92," 
  def is_square(n):
      if n in square:
          return True
      if is_fair(n):
          root = int(math.sqrt(n))
          if root**2 != n:
              return False
          ss = is_fair(root)
          if ss: square.add(n)
          return ss
      return False
  
  def is_fair(n):
      if n in fair:
          return True
      if n in unfair:
          return False
      sn = str(n)
      l = len(sn)
      mid = math.ceil(n/2)
      if sn[0:mid] == sn[mid::-1]:
          fair.add(n)
          return True
      else:
          unfair.add(n)
          return False
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
              
      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])
      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])
      square = set([1, 4])
  
      t = int(f.readline())
      for _t in range(t):
          s = f.readline()
          if s:
              x, y = s.split()
              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             
              print (""Case #"" + str(_t+1) + "": "" + str(Total))
      
  
",319," 
  def is_square(init):
      if init in respect:
          return True
      if is_fair(init):
          node = int(math.sqrt(init))
          if node**2 != init:
              return False
          sq = is_fair(node)
          if sq: respect.add(init)
          return sq
      return False
  
  def is_fair(init):
      if init in rust:
          return True
      if init in unflower:
          return False
      inn = str(init)
      dl = len(inn)
      lim = math.ceil(init/2)
      if inn[0:lim] == inn[lim::-1]:
          rust.add(init)
          return True
      else:
          unflower.add(init)
          return False
  
  if __name__ == ""__main__"":
      r = sys.stdin
      if len(sys.argv) >= 2:
          fi = sys.argv[1]
          if fi != '-':
              r = open(fi)
              
      rust = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])
      unflower = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])
      respect = set([1, 4])
  
      ot = int(r.readline())
      for  _tf in range(ot):
           squares = r.readline()
          if  squares:
              case, k =  squares.split()
              total = sum([is_square(init) for init in range(int(case), int(k)+1)])             
              print (""Case #"" + str( _tf+1) + "": "" + str(total))
      
  
",LABEL_46,LABEL_46,,-1,"n,root,ss,sn,l,mid,f,fn,fair,unfair,square,t,_t,s,x,y,Total","n:0.8319664299488068,root:0.7739366888999939,ss:0.7826130986213684,sn:0.7749514132738113,l:0.7691676020622253,mid:0.7737987041473389,f:0.8355394303798676,fn:0.8034228533506393,fair:0.7932031452655792,unfair:0.7882867008447647,square:0.8009942322969437,t:0.8040632605552673,_t:0.7823545336723328,s:0.7888738065958023,x:0.8012728989124298,y:0.8016753643751144,Total:0.8020449131727219,",0,0,"f:r,n:init,t:qt,fn:fi,Total:total,y:k,x:case,square:respect,fair:fork,s:su,unfair:unflower,ss:sq,_t: _tf,sn:inn,root:r,mid:lim,l:dl,",0,0,Greedy,337,0.12445069948832194,failed,[],0.9937711358070374,0.9569886922836304
93," 
  def decode_data(input):
      output = """"
      for letter in input:
          if letter in library:
              output += library[letter]
      return output
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())    
      for _t in range(t):
          s = f.readline()
          s = s.split()
          N = int(s[0])
          S = int(s[1])
          p = int(s[2])
          low_scores = (p - 1) * 2
          ti = s[3:]
          ti.sort()
          r = 0
          ti = [int(x) for x in ti]
          for i in ti:
              score = i - low_scores
              if p <= i:
                  if score >= p:
                      r += 1
                  elif score >= p - 2 and S > 0:
                      S -= 1
                      r +=1
          print (""Case #"" + str(_t+1) + "": "" + str(r))
      
  
",219," 
  def decode_data(input):
      config = """"
      for model in input:
          if model in library:
              config += library[model]
      return config
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      type = int(f.readline())    
      for  _l in range(type):
          xs = f.readline()
          xs = xs.split()
          P = int(xs[0])
          Q = int(xs[1])
          case = int(xs[2])
          low_cales = (case - 1) * 2
          PI = xs[3:]
          PI.sort()
          r = 0
          PI = [int( X) for  X in PI]
          for I in PI:
              scale = I - low_cales
              if case <= I:
                  if scale >= case:
                      r += 1
                  elif scale >= case - 2 and Q > 0:
                      Q -= 1
                      r +=1
          print (""Case #"" + str( _l+1) + "": "" + str(r))
      
  
",LABEL_46,LABEL_46,,-1,"input,output,letter,f,fn,t,_t,s,N,S,p,low_scores,ti,r,x,i,score","input:0.7353600561618805,output:0.7595710903406143,letter:0.8467402309179306,f:0.6824088990688324,fn:0.6159813702106476,t:0.6585606038570404,_t:0.7175932228565216,s:0.7146539092063904,N:0.7238203883171082,S:0.7273546457290649,p:0.8224659264087677,low_scores:0.745243027806282,ti:0.8088032007217407,r:0.8010778725147247,x:0.7352942228317261,i:0.8158320188522339,score:0.7980644851922989,",0,0,"letter:model,p:case,i:I,ti:PI,score:span,output:config,low_scores:low_cales,x: X,S:Q,N:Q,_t: _l,s:xs,t:type,",0,0,Greedy,340,0.1237005074818929,failed,[],0.9929621815681458,0.9693949818611145
94," 
  
  def is_equal_approx(x, y, epsilon=1e-6):
      """""" Returns True iff y is within relative or absolute 'epsilon' of x.
          By default, 'epsilon' is 1e-6.
      """"""
      if -epsilon <= x - y <= epsilon:
          return True
  
      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
          return False
  
      return (-epsilon <= (x - y) / x <= epsilon
          or -epsilon <= (x - y) / y <= epsilon)
    
  def read_syms(fd):
      return [c for c in fd.readline().strip()]
  
  def read_ints(fd):
      return [int(p) for p in fd.readline().strip().split()]
  
  def read_floats(fd):
      return [float(p) for p in fd.readline().strip().split()]
  
  class Mtrx(object):
      
      def __init__(self, readfunc):
          self.readfunc = readfunc
          
      def cell(self, r, c):
          return self.data[r * self.cols + c]
      
      def getrow(self, i):
          return [self.cell(i, c) for c in range(self.cols)]
  
      def getcol(self, i):
          return [self.cell(c, i) for c in range(self.rows)]
      
      def readfromfile(self, fd):
          self.data = []
          self.rows, self.cols = read_ints(fd)
          for _ in range(self.rows):
              line = self.readfunc(fd)
              assert len(line) == self.cols
              self.data.extend(line)
              
      def __str__(self):
          res = """"
          for i in xrange(self.rows):
              res += str(self.getrow(i)) + ""
""
          return res
               
  class IntMatrix(Mtrx):
      def __init__(self):
          super(IntMatrix, self).__init__(read_ints)
  
  class SymMatrix(Mtrx):
      def __init__(self):
          super(IntMatrix, self).__init__(read_syms)
  
  class memoizeit(object):
      def __init__(self, func):
          self.func = func
          self.cache = {}
          
      def __call__(self, *args):
          try:
              return self.cache[args]
          except KeyError:
              value = self.func(*args)
              self.cache[args] = value
              return value
          except TypeError:
              return self.func(*args)
      
      @property
      def __name__(self):
          return self.func.__name__
      
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
  class timeit(object):
      def __init__(self, func):
          self.func = func
      def __call__(self, *args):
          start = time.time()
          value = self.func(*args)
          delta = time.time() - start
          print self.func.__name__, ""{:7.3f}s, (res: {})"".format(delta, value)
          return value
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
",591,,LABEL_47,LABEL_43,,-4,"x,y,epsilon,fd,c,p,self,readfunc,r,i,data,rows,cols,_,line,res",,,,,0,0,Greedy,1,0.000695347785949707,,,0.1936284303665161,0.1936284303665161
95," 
  OEXT = "".out""
  IN_S = ""small.in""
  IN_L = ""large.in""
  CASE_PRFX = ""Case #%s: ""
  
  
  def avg(L):
      return 1.0*sum(L)/len(L)
  
  triplets = [[0,0,0], [0,0,1], [0,1,1], 
              [0,0,2], [0,2,2], [0,1,2],
              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],
              ]
  
  def analyze_sum(sm, tgt):
      av = 1.0 * sm / 3
      av_cls = av % 1
  
      if av_cls > 0.1:
          ns_max_val = math.ceil(av)
      else:
          ns_max_val = av 
      
      s_max_val = 0 
      if sm >= 2 and sm <= 28:
          if av_cls > 0.5:
              s_max_val = math.ceil(av) + 1
          elif av_cls > 0.1:
              s_max_val = math.ceil(av) 
          else:
              s_max_val = av + 1
      
      if ns_max_val >= tgt:
          res = [ns_max_val, None]
          kind = 1
      elif s_max_val < tgt:
          res = [None, None]
          kind = 0
      else:
          res = [None, s_max_val]
          kind = 2
          
      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind
      return res, kind
  
  def analyze_triplet(trip, tgt):
      sm = sum(trip)
      analyze_triplet(sm, tgt)
      
  
  def read_input(filename):
      data = []
      with open(filename, ""r"") as f:
          cases = int(f.readline())
          for _ in xrange(cases):
              case = f.readline().strip().split()
              case = [int(c) for c in case]
              data.append({""ngoog"": case[0], ""ssurp"": case[1], ""ptgt"": case[2],
                           ""trips"": case[3:]})
      return data
  
  def make_output(fname, output):
      fname = fname + OEXT
      with open(fname, ""w"") as f:
          restext = []
          for i, v in enumerate(output):
              restext.append(CASE_PRFX % (i+1,) + str(v) + ""
"")
          f.writelines(restext)
      
  def main(fname):
      data = read_input(fname)
      output = []
      for case in data:
          ansys = [analyze_sum(c, case[""ptgt""]) for c in case[""trips""]]
          non_surp_is_enough = len([k for _, k in ansys if k == 1])
          surp_needed = len([k for _, k in ansys if k == 2])
          if surp_needed >= case[""ssurp""]:
              res = non_surp_is_enough + case[""ssurp""]
          else:
              res = non_surp_is_enough + surp_needed
          output.append(res)
      print ""output:"", output
      make_output(fname, output)
       
  
  main(""examples.in"")
  main(""small.in"")
",570," 
  OEXT = "".out""
  IN_SI = ""small.in""
  IN2LI = ""large.in""
  CASE_RELINT = ""Case #%s: ""
  
  
  def avg(L):
      return 1.0*sum(L)/len(L)
  
  triplets = [[0,0,0], [0,0,1], [0,1,1], 
              [0,0,2], [0,2,2], [0,1,2],
              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],
              ]
  
  def analyze_sum(ism, tgt):
      Av = 1.0 * ism / 3
      av_pli = Av % 1
  
      if av_pli > 0.1:
          ns_max_val = math.ceil(Av)
      else:
          ns_max_val = Av 
      
      s_max_val = 0 
      if ism >= 2 and ism <= 28:
          if av_pli > 0.5:
              s_max_val = math.ceil(Av) + 1
          elif av_pli > 0.1:
              s_max_val = math.ceil(Av) 
          else:
              s_max_val = Av + 1
      
      if ns_max_val >= tgt:
          rus = [ns_max_val, None]
           kinds = 1
      elif s_max_val < tgt:
          rus = [None, None]
           kinds = 0
      else:
          rus = [None, s_max_val]
           kinds = 2
          
      print ism, tgt, Av, av_pli, ns_max_val, s_max_val, rus,  kinds
      return rus,  kinds
  
  def analyze_triplet(address, tgt):
      ism = sum(address)
      analyze_triplet(ism, tgt)
      
  
  def read_input(slice):
      text = []
      with open(slice, ""r"") as f:
          values = int(f.readline())
          for _ in xrange(values):
              case = f.readline().strip().split()
              case = [int(c) for c in case]
              text.append({""ngoog"": case[0], ""ssurp"": case[1], ""ptgt"": case[2],
                           ""trips"": case[3:]})
      return text
  
  def make_output(fname, output):
      fname = fname + OEXT
      with open(fname, ""w"") as f:
          restext = []
          for i, v in enumerate(output):
              restext.append(CASE_RELINT % (i+1,) + str(v) + ""
"")
          f.writelines(restext)
      
  def main(fname):
      text = read_input(fname)
      output = []
      for case in text:
          ansys = [analyze_sum(c, case[""ptgt""]) for c in case[""trips""]]
          non_surp_is_enough = len([k for _, k in ansys if k == 1])
          surp_needed = len([k for _, k in ansys if k == 2])
          if surp_needed >= case[""ssurp""]:
              rus = non_surp_is_enough + case[""ssurp""]
          else:
              rus = non_surp_is_enough + surp_needed
          output.append(rus)
      print ""output:"", output
      make_output(fname, output)
       
  
  main(""examples.in"")
  main(""small.in"")
",LABEL_47,LABEL_47,LABEL_51,1,"OEXT,IN_S,IN_L,CASE_PRFX,L,triplets,sm,tgt,av,av_cls,ns_max_val,s_max_val,res,kind,trip,filename,data,cases,_,case,c","OEXT:0.5171713531017303,IN_S:0.6213593184947968,IN_L:0.6101337373256683,CASE_PRFX:0.6740077883005142,L:0.540145069360733,triplets:0.6504518389701843,sm:0.7155517190694809,tgt:0.6023223996162415,av:0.614326000213623,av_cls:0.609411746263504,ns_max_val:0.597548246383667,s_max_val:0.6955057233572006,res:0.6745617389678955,kind:0.6652194261550903,trip:0.6359393298625946,filename:0.6222255825996399,data:0.5977468192577362,cases:0.6524866819381714,_:0.5460090935230255,case:0.7277417629957199,c:0.6143968999385834,",1,5,"sm:ism,res:rus,CASE_PRFX:CASE_RELINT,kind: kinds,cases:values,trip:address,filename:slice,IN_S:IN_SI,av:Av,IN_L:IN2LI,av_cls:av_pli,",0,0,Greedy,342,0.13156790335973104,replace,[],0.9202257990837097,0.10746411979198456
96,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'
  
  
  def is_palindrome (n):
      l = list(str(n))
      return list(reversed(l)) == l
  
  def prepare ():
      global fair_and_squares
      fair_and_squares = []
      
      for i in range(1,10**7):
          if is_palindrome(i):
              sqr = i**2
              if is_palindrome(sqr):
                  fair_and_squares.append(sqr)
      return
  
          
  def solve (f_in, f_out):
      prepare()
      T = int(f_in.readline())
      for testcase in range(1,T+1):
          A,B = [int(x) for x in f_in.readline().split()]
          count = len([x for x in fair_and_squares if (x>=A and x<=B)])
          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '
')
  
  
  
  def main_run():
      filenames = [x for x in os.listdir (directory)]
      filenames = [x for x in filenames if x.endswith('.in')]
      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', directory)
      print ('Chosen Filename : ',chosen_filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      f_in = open(directory+chosen_filename+'.in')
      f_out = open(directory+chosen_filename+'.out', 'w')
      solve(f_in,f_out)
      f_in.close()
      f_out.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",329,"buffer = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'
  
  
  def is_palindrome (name):
      j = list(str(name))
      return list(reversed(j)) == j
  
  def prepare ():
      global fair_and_shals
      fair_and_shals = []
      
      for ji in range(1,10**7):
          if is_palindrome(ji):
              qqrs = ji**2
              if is_palindrome(qqrs):
                  fair_and_shals.append(qqrs)
      return
  
          
  def solve (floginn, f__outs):
      prepare()
      Q = int(floginn.readline())
      for traincase in range(1,Q+1):
          Ma,BU = [int(co) for co in floginn.readline().split()]
          part = len([co for co in fair_and_shals if (co>=Ma and co<=BU)])
          f__outs.write('Case #' + str(traincase) + ': ' + str(part) + '
')
  
  
  
  def main_run():
      filename = [co for co in os.listdir (buffer)]
      filename = [co for co in filename if co.endswith('.in')]
      l1 = [(os.stat(buffer+co).st_ctime, co) for co in filename]
      choinftoken =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', buffer)
      print ('Chosen Filename : ',choinftoken)
      print()
      print ('Start : ', time.ctime())
      print()
      
      floginn = open(buffer+choinftoken+'.in')
      f__outs = open(buffer+choinftoken+'.out', 'w')
      solve(floginn,f__outs)
      floginn.close()
      f__outs.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",LABEL_48,LABEL_48,,-1,"directory,n,l,fair_and_squares,i,sqr,f_in,f_out,T,testcase,A,B,x,count,filenames,l1,chosen_filename","directory:0.06087762117385864,n:0.04251110553741455,l:0.03684413433074951,fair_and_squares:0.05321544408798218,i:0.0502471923828125,sqr:0.0518338680267334,f_in:0.04708606004714966,f_out:0.04339069128036499,T:0.055165767669677734,testcase:0.051759421825408936,A:0.05356884002685547,B:0.05295610427856445,x:0.044228971004486084,count:0.05352425575256348,filenames:0.05053830146789551,l1:0.05217045545578003,chosen_filename:0.047074735164642334,",0,0,"directory:buffer,T:Q,A:Ma,count:part,fair_and_squares:fair_and_shals,B:M,sqr:qqrs,testcase:traincase,filenames:filename,i:ji,f_in:floginn,chosen_filename:choinftoken,x:co,f_out:f__outs,n:name,l:j,",0,0,Greedy,356,0.13209846019744872,failed,[],0.9950190782546997,0.6763494610786438
97,"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'
  
  
  def solve (f_in, f_out):
      T = int(f_in.readline())
      print ('Test cases : ',T)
      for i in range(1,T+1):
          line = f_in.readline()
          nnn = [int(x) for x in line.split()]
          S = nnn[1]
          p = nnn[2]
          t = nnn[3:]
          if p > 1:
              A = 0
              B = 0
              for t_i in t:
                  if t_i >=3*p-2:
                      A += 1
                  elif t_i >= 3*p-4:
                      B += 1
              result = A + min(B,S)
          if p == 1:
              result = len([x for x in t if x>=1])
          if p == 0:
              result=  len(t)
          f_out.write('Case #' + str(i) + ': ' + str(result) + '
')
  
  
  
  
  
  
  
  
  
  
  def main_run():
      filenames = [x for x in os.listdir (directory)]
      filenames = [x for x in filenames if x.endswith('.in')]
      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', directory)
      print ('Chosen Filename : ',chosen_filename)
      print()
      f_in = open(directory+chosen_filename+'.in')
      f_out = open(directory+chosen_filename+'.out', 'w')
      solve(f_in,f_out)
      f_in.close()
      f_out.close()
  
  
  
  
  main_run()
",314,"third = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'
  
  
  def solve ( f_inn,  f_run):
      TH = int( f_inn.readline())
      print ('Test cases : ',TH)
      for n in range(1,TH+1):
          xml =  f_inn.readline()
          nyd = [int(rax) for rax in xml.split()]
          u = nyd[1]
          pr = nyd[2]
          j = nyd[3:]
          if pr > 1:
              API = 0
              B = 0
              for t__iu in j:
                  if t__iu >=3*pr-2:
                      API += 1
                  elif t__iu >= 3*pr-4:
                      B += 1
              format = API + min(B,u)
          if pr == 1:
              format = len([rax for rax in j if rax>=1])
          if pr == 0:
              format=  len(j)
           f_run.write('Case #' + str(n) + ': ' + str(format) + '
')
  
  
  
  
  
  
  
  
  
  
  def main_run():
      filternnames = [rax for rax in os.listdir (third)]
      filternnames = [rax for rax in filternnames if rax.endswith('.in')]
       l01 = [(os.stat(third+rax).st_ctime, rax) for rax in filternnames]
      chosing_url =  sorted( l01)[-1][1][:-3]
  
      print ('Directory : ', third)
      print ('Chosen Filename : ',chosing_url)
      print()
       f_inn = open(third+chosing_url+'.in')
       f_run = open(third+chosing_url+'.out', 'w')
      solve( f_inn, f_run)
       f_inn.close()
       f_run.close()
  
  
  
  
  main_run()
",LABEL_48,LABEL_48,LABEL_19,1,"directory,f_in,f_out,T,i,line,nnn,x,S,p,t,A,B,t_i,result,filenames,l1,chosen_filename","directory:0.3001407980918884,f_in:0.12075299024581909,f_out:0.128426194190979,T:0.13736987113952637,i:0.11865460872650146,line:0.12733519077301025,nnn:0.13888627290725708,x:0.09931027889251709,S:0.13072341680526733,p:0.10898876190185547,t:0.12302178144454956,A:0.14347445964813232,B:0.11543762683868408,t_i:0.14024066925048828,result:0.13446027040481567,filenames:0.12111186981201172,l1:0.13646435737609863,chosen_filename:0.14964795112609863,",1,13,"directory:third,chosen_filename:chosing_url,A:API,t_i:t__iu,nnn:nyd,T:TH,l1: l01,result:format,S:u,f_out: f_run,line:xml,t:j,filenames:filternnames,f_in: f_inn,i:im,p:pr,",0,0,Greedy,377,0.13936071395874022,replace,[],0.991541862487793,0.5599861145019531
98," 
  def isPalindrome(n) :
      return str(n) == str(n)[::-1]
  
  def findPalindrome(n) :
      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]
      if n == 1 : return range(1,10)
      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]
  
  def findPalindromeInRange(a, b) :
      num = range(len(str(a)), len(str(b)) + 1)
      allPalindrome = []
      for n in num : allPalindrome += findPalindrome(n)
      return filter(lambda x : a <= x <= b, allPalindrome)
  
  f = open('C-small-attempt0.in', 'r')
  g = open('output', 'w')
  
  T = int(f.readline()[:-1])
  
  for case in range(T) :
      A, B = map(int, f.readline()[:-1].split())
      a = int(math.ceil(A**0.5))
      b = int(B**0.5)
      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))
      outString = 'Case #' + str(case+1) + ': ' + str(res) + '
'
      print outString[:-1]
      g.write(outString)
  
  f.close()
  g.close()
",364," 
  def isPalindrome(nd) :
      return str(nd) == str(nd)[::-1]
  
  def findPalindrome(nd) :
      if nd % 2 == 0 : return [grade*(10**(nd/2)) + int(str(grade)[::-1]) for grade in range(10**(nd/2-1),10**(nd/2))]
      if nd == 1 : return range(1,10)
      return [grade*(10**(nd/2)) + int(str(grade)[:-1][::-1]) for grade in range(10**(nd/2),10**((nd+1)/2))]
  
  def findPalindromeInRange(alpha, bas) :
      num = range(len(str(alpha)), len(str(bas)) + 1)
      allPalendome = []
      for nd in num : allPalendome += findPalindrome(nd)
      return filter(lambda x : alpha <= x <= bas, allPalendome)
  
  log = open('C-small-attempt0.in', 'r')
  game = open('output', 'w')
  
  Len = int(log.readline()[:-1])
  
  for data in range(Len) :
      Ca, NB = map(int, log.readline()[:-1].split())
      alpha = int(math.ceil(Ca**0.5))
      bas = int(NB**0.5)
      ins = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(alpha, bas)))
      againSite = 'Case #' + str(data+1) + ': ' + str(ins) + '
'
      print againSite[:-1]
      game.write(againSite)
  
  log.close()
  game.close()
",LABEL_49,LABEL_49,,-1,"n,start,a,b,num,allPalindrome,f,g,T,case,A,B,res,outString","n:0.7394914031028748,start:0.6011157333850861,a:0.6187047958374023,b:0.558201014995575,num:0.5777512192726135,allPalindrome:0.5472733676433563,f:0.679483562707901,g:0.5642572045326233,T:0.6115829646587372,case:0.630403608083725,A:0.5595867335796356,B:0.5615826547145844,res:0.5569611489772797,outString:0.573065847158432,",0,0,"n:nd,f:log,case:data,a:alpha,T:Len,start:grade,outString:againSite,g:j,B:NB,A:Ca,b:bas,res:ins,allPalindrome:allPalendome,",0,0,Greedy,292,0.10785768429438274,failed,[],0.913081169128418,0.4537772536277771
99,"fin = open('B-small-attempt0.in', 'r')
  fout = open('B-output.txt', 'w')
  
  cases = int(fin.readline()[:-1])
  
  for case in range(cases) :
      line = map(int, fin.readline()[:-1].split(' '))
      N, S, p = line[:3]
      T = line[3:]
      okLimit = p + 2*max(p-1,0)
      okIfSLimit = p + 2*max(p-2,0)
      ok = len(filter(lambda x : x >= okLimit, T))
      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))
      res = ok + min(okIfS, S)
      fout.write('Case #' + str(case+1) + ': ' + str(res) + '
')
      
  fin.close()
  fout.close()
",183,"file = open('B-small-attempt0.in', 'r')
   ffile = open('B-output.txt', 'w')
  
  works = int(file.readline()[:-1])
  
  for ASE in range(works) :
      section = map(int, file.readline()[:-1].split(' '))
      I, D, lp = section[:3]
      T = section[3:]
      okLimit = lp + 2*max(lp-1,0)
      okIfSLimit = lp + 2*max(lp-2,0)
      ok = len(filter(lambda x : x >= okLimit, T))
      okIFA = len(filter(lambda x : okLimit > x >= okIfSLimit, T))
      res = ok + min(okIFA, D)
       ffile.write('Case #' + str(ASE+1) + ': ' + str(res) + '
')
      
  file.close()
   ffile.close()
",LABEL_49,LABEL_49,LABEL_9,1,"fin,fout,cases,case,line,N,S,p,T,okLimit,okIfSLimit,ok,okIfS,res","fin:0.6996189057826996,fout:0.5060798823833466,cases:0.7179641574621201,case:0.5151931941509247,line:0.3677160143852234,N:0.29879897832870483,S:0.2954580783843994,p:0.3835363984107971,T:0.2887808680534363,okLimit:0.2908923625946045,okIfSLimit:0.2905391454696655,ok:0.3098480701446533,okIfS:0.2970341444015503,res:0.25589901208877563,",1,2,"cases:works,fin:file,case:ASE,fout: ffile,p:lp,line:section,N:I,okIfS:okIFA,",0,0,Greedy,214,0.07775050401687622,replace,[],0.9154700636863708,0.4555509388446808
100," 
  
  def palindromes():
      for digits in count(1):
          for n in xrange(10**(digits-1), 10**digits):
              n = str(n)
              yield int(n + n[-2::-1])
          for n in xrange(10**(digits-1), 10**digits):
              n = str(n)
              yield int(n + n[::-1])
  
  def is_palindrome(n):
      n = str(n)
      return n == n[::-1]
  
  def solve(A, B):
      count = 0
      for n in palindromes():
          square = n**2
          if square > B:
              break
          if square >= A and is_palindrome(square):
              count += 1
      return count
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          T = int(fin.readline())
          for case in xrange(1, T+1):
  
              A, B = map(int,fin.readline().split())
              soln = solve(A, B)
  
              print >> fout, ""Case #{0}: {1}"".format(case, soln)
",249," 
  
  def palindromes():
      for digals in count(1):
          for  N in xrange(10**(digals-1), 10**digals):
               N = str( N)
              yield int( N +  N[-2::-1])
          for  N in xrange(10**(digals-1), 10**digals):
               N = str( N)
              yield int( N +  N[::-1])
  
  def is_palindrome( N):
       N = str( N)
      return  N ==  N[::-1]
  
  def solve(alpha, L):
      count = 0
      for  N in palindromes():
          feature =  N**2
          if feature > L:
              break
          if feature >= alpha and is_palindrome(feature):
              count += 1
      return count
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          P = int(fin.readline())
          for case in xrange(1, P+1):
  
              alpha, L = map(int,fin.readline().split())
               solen = solve(alpha, L)
  
              print >> fout, ""Case #{0}: {1}"".format(case,  solen)
",LABEL_50,LABEL_50,LABEL_54,1,"digits,n,A,B,count,square,T,case,soln","digits:-0.06178218126296997,n:0.016088277101516724,A:0.013120144605636597,B:0.020877480506896973,count:-0.09282386302947998,square:-0.04758840799331665,T:0.007222533226013184,case:-0.06542003154754639,soln:-0.034109413623809814,",1,5,"B:L,n: N,A:alpha,T:P,soln: solen,square:feature,",0,0,Greedy,148,0.054298599561055504,replace,[],0.5103687644004822,0.23105044662952423
101," 
  def solve(n, s, p, scores):
      count = 0
      for t in scores:
          if ceil(t/3) >= p:
              count += 1
          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:
              count += 1
              s -= 1
      return count
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          T = int(fin.readline())
          for case in range(1, T+1):
              line = map(int, fin.readline().split())
              n, s, p, *scores = line
              result = solve(n, s, p, scores)
              print(""Case #{0}: {1}"".format(case, result), file=fout)
",174," 
  def solve(v, start, pro,  scors):
      cond = 0
      for j in  scors:
          if ceil(j/3) >= pro:
              cond += 1
          elif 2 <= j <= 28 and ceil((j+2)/3) >= pro and start > 0:
              cond += 1
              start -= 1
      return cond
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          NT = int(fin.readline())
          for choice in range(1, NT+1):
              text = map(int, fin.readline().split())
              v, start, pro, * scors = text
              complete = solve(v, start, pro,  scors)
              print(""Case #{0}: {1}"".format(choice, complete), file=fout)
",LABEL_50,LABEL_50,,-1,"n,s,p,scores,count,t,T,case,line,result","n:0.6225947439670563,s:0.6414524018764496,p:0.6355433762073517,scores:0.6383208930492401,count:0.6343945562839508,t:0.6280121505260468,T:0.6236604154109955,case:0.6254624724388123,line:0.6109752655029297,result:0.6066905558109283,",0,0,"s:start,scores: scors,p:pro,count:cond,t:j,case:choice,T:NT,n:b,line:text,result:final,",0,0,Greedy,208,0.07519396543502807,failed,[],0.9293429255485535,0.8026904463768005
102," 
  def solve(lower, upper, cache):
      counter = 0
      for item in cache:
          if item > upper:
              break
          if item < lower:
              continue
          counter += 1
      return counter
  
  def is_palindrome(test_int):
      str_arg = str(test_int)
      return str_arg == str_arg[::-1]
  
  def generate_cache():
      """""" Generates a list of 'fair and square' numbers between 1 and 10^100
  
      By observation of generating the first few of these numbers it became
      obvious that the 'roots' fitted a very specific pattern, they are either
      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;
      multiple digits with a 2 at the beginning and end and 1s and 0s in the
      middle or an odd number of digits with a single 2 in the centre and 1s and
      0s elsewhere.
  
      This function therefore only looks at these numbers to build a list of all
      valid results. """"""
      cache = [9,]
      counter = 1
      if upper_bound is None:
          upper_bound = pow(2,25)
      while counter < upper_bound:
          binary_part = ""{0:b}"".format(counter)
          half_int = binary_part
          pal_int = int(half_int + half_int[:-1][::-1])
          pal_square = pal_int * pal_int
          if is_palindrome(pal_square):
              cache.append(pal_square)
          pal_int = int(half_int + half_int[::-1])
          pal_square = pal_int * pal_int
          if is_palindrome(pal_square):
              cache.append(pal_square)
          half_int = ""%s%s"" % (binary_part, 2)
          pal_int = int(half_int + half_int[:-1][::-1])
          pal_square = pal_int * pal_int
          if is_palindrome(pal_square):
              cache.append(pal_square)
          half_int = ""2%s"" % binary_part[1:]
          pal_int = int(half_int + half_int[:-1][::-1])
          pal_square = pal_int * pal_int
          if is_palindrome(pal_square):
              cache.append(pal_square)
          pal_int = int(half_int + half_int[::-1])
          pal_square = pal_int * pal_int
          if is_palindrome(pal_square):
              cache.append(pal_square)
          counter += 1
      return sorted(cache)
  
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
      parser.add_option(""-c"", ""--cache"", dest=""cache_filename"",
                        help=""read/write cache from/to CACHE_FILE"", metavar=""CACHE_FILE"")
      parser.add_option(""-g"", ""--generate-cache"", dest=""generate_cache"",
                        help=""generate the cache file"", action=""store_true"")
      cache = None
      (options, args) = parser.parse_args()
      if options.generate_cache:
          cache = generate_cache()
          if not options.cache_filename:
              output_file = open(options.cache_filename, ""w"")
              pickle.dump(cache, output_file)
              output_file.close()
      else:
          cache_file = open(options.cache_filename, ""r"")
          cache = pickle.load(cache_file)
          cache_file.close()
      if not options.filename:
          parser.error(""Must provide a filename."")
      input_file = open(options.filename, ""r"")
      total_cases = int(input_file.readline())
      case_number = 0
      while case_number < total_cases:
          case_number += 1
          lower,upper = input_file.readline().split()
          lower = int(lower)
          upper = int(upper)
          data_args = (lower, upper, cache)
          print ""Case #%d: %s"" % (case_number, solve(*data_args))
  
  if __name__ == ""__main__"":
      main()
",541,,LABEL_51,LABEL_47,,-4,"lower,upper,cache,counter,item,test_int,str_arg,upper_bound,binary_part,half_int,pal_int,pal_square,parser",,,,,0,0,Greedy,1,0.0007253527641296387,,,0.10086853802204132,0.10086853802204132
103," 
  def solve(N,S,p,t):
      if p == 0:
          return N
      outright_wins = 0
      potential_surprises = 0
      win_cutoff = (p * 3) - 3
      surprise_cutoff = win_cutoff - 2
      for score in t:
          if score == 0:
              continue
          elif score > win_cutoff:
              outright_wins += 1
          elif score > surprise_cutoff:
              potential_surprises += 1
      if potential_surprises < S:
          return outright_wins + potential_surprises
      else:
          return outright_wins + S
  
  def parse_case(data_line):
      bits = data_line.split()
      N = int(bits[0])
      S = int(bits[1])
      p = int(bits[2])
      t = [int(x) for x in bits[3:]]
      return N,S,p,t
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if not options.filename:
          parser.error(""Must provide a filename."")
      input_file = open(options.filename, ""r"")
      total_cases = int(input_file.readline())
      case_number = 0
      while case_number < total_cases:
      	case_number += 1
      	data_args = parse_case(input_file.readline())
      	print ""Case #%d: %d"" % (case_number, solve(*data_args))
  
  if __name__ == ""__main__"":
  	main()
",259," 
  def solve(N,S,p,t):
      if p == 0:
          return N
      outright_walls = 0
      potential_surprising = 0
      win_cutsdown = (p * 3) - 3
      surprise_cutsoffs = win_cutsdown - 2
      for fer in t:
          if fer == 0:
              continue
          elif fer > win_cutsdown:
              outright_walls += 1
          elif fer > surprise_cutsoffs:
              potential_surprising += 1
      if potential_surprising < S:
          return outright_walls + potential_surprising
      else:
          return outright_walls + S
  
  def parse_case(input_entry):
      address = input_entry.split()
      N = int(address[0])
      S = int(address[1])
      p = int(address[2])
      t = [int(i) for i in address[3:]]
      return N,S,p,t
  
  def main():
      section = OptionParser()
      section.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (options, args) = section.parse_args()
      if not options.filename:
          section.error(""Must provide a filename."")
      output_lane = open(options.filename, ""r"")
       total_posts = int(output_lane.readline())
      case_number = 0
      while case_number <  total_posts:
      	case_number += 1
      	data__arg = parse_case(output_lane.readline())
      	print ""Case #%d: %d"" % (case_number, solve(*data__arg))
  
  if __name__ == ""__main__"":
  	main()
",LABEL_51,LABEL_51,LABEL_52,1,"N,S,p,t,outright_wins,potential_surprises,win_cutoff,surprise_cutoff,score,data_line,bits,x,parser,options,args,input_file,total_cases,case_number,data_args","N:-0.01480245590209961,S:-0.013781607151031494,p:-0.0074498653411865234,t:-0.006190955638885498,outright_wins:0.01670539379119873,potential_surprises:0.022287607192993164,win_cutoff:0.01557081937789917,surprise_cutoff:0.04477846622467041,score:0.006245613098144531,data_line:0.04396432638168335,bits:-0.0005614161491394043,x:0.0029783248901367188,parser:-0.002889394760131836,options:-0.007509887218475342,args:-0.023042142391204834,input_file:0.09900224208831787,total_cases:0.11448347568511963,case_number:0.15050798654556274,data_args:0.142075777053833,",1,4,"data_args:data__arg,total_cases: total_posts,input_file:output_lane,surprise_cutoff:surprise_cutsoffs,data_line:input_entry,potential_surprises:potential_surprising,outright_wins:outright_walls,win_cutoff:win_cutsdown,score:fer,x:i,bits:address,",0,0,Greedy,271,0.10016836325327555,replace,[],0.8471943140029907,0.4337286055088043
104," 
  
  def is_palindrome(x):
      candidate = list(str(x))
      while len(candidate) > 1:
          if candidate.pop(0) != candidate.pop():
              return False
      return True
  
  
  def square(x):
      return x * x
  
  
  def solve_case(ab, case_number):
      fs = 0
      root = int(math.sqrt(ab[0]))
      sq = square(root)
      if sq < ab[0]:
          root += 1
          sq = square(root)
  
      while sq <= ab[1]:
          if is_palindrome(root) and is_palindrome(sq):
              fs += 1
  
          root += 1
          sq = square(root)
  
      print ""Case #%d: %d"" % (case_number, fs)
  
  
  def main():
      r = sys.stdin
      if len(sys.argv) > 1:
          r = open(sys.argv[1], 'r')
  
      total_cases = r.readline()
      for case_number in range(1, int(total_cases) + 1):
          ab = map(int, r.readline().strip().split(' '))
          solve_case(ab, case_number)
  
  if __name__ == ""__main__"":
      main()
",228," 
  
  def is_palindrome(x):
      candidate = list(str(x))
      while len(candidate) > 1:
          if candidate.pop(0) != candidate.pop():
              return False
      return True
  
  
  def square(x):
      return x * x
  
  
  def solve_case(af, caseIdexpression):
      fs = 0
      root = int(math.sqrt(af[0]))
      sq = square(root)
      if sq < af[0]:
          root += 1
          sq = square(root)
  
      while sq <= af[1]:
          if is_palindrome(root) and is_palindrome(sq):
              fs += 1
  
          root += 1
          sq = square(root)
  
      print ""Case #%d: %d"" % (caseIdexpression, fs)
  
  
  def main():
      r = sys.stdin
      if len(sys.argv) > 1:
          r = open(sys.argv[1], 'r')
  
      total_cases = r.readline()
      for caseIdexpression in range(1, int(total_cases) + 1):
          af = map(int, r.readline().strip().split(' '))
          solve_case(af, caseIdexpression)
  
  if __name__ == ""__main__"":
      main()
",LABEL_52,LABEL_52,LABEL_51,1,"x,candidate,ab,case_number,fs,root,sq,r,total_cases","x:0.4643303155899048,candidate:0.46981802582740784,ab:0.5444700121879578,case_number:0.545444130897522,fs:0.4988279342651367,root:0.472859263420105,sq:0.429292768239975,r:0.539386123418808,total_cases:0.46035751700401306,",1,6,"case_number:caseIdexpression,",0,0,Greedy,50,0.019126307964324952,replace,[],0.7974222898483276,0.2396426945924759
105," 
  mod_plus_conv_with_s = {0:1, 1:1, 2:2}
  mod_plus_conv_without_s = {0:0, 1:1, 2:1}
  
  def solve_case(s, p, scores,case_number):
  	ans = 0
  	for score in scores:
  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:
  			ans = ans + 1
  		elif s > 0 and (score / 3) > 0: 
  			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:
  				ans = ans + 1
  				s = s - 1
  	print ""Case #%d: %d"" % (case_number, ans)
  
  r = sys.stdin
  
  if len(sys.argv) > 1:
  	r = open(sys.argv[1], 'r')
  
  total_cases = r.readline()
  for case_number in range(1, int(total_cases) + 1):
  	case_line = map(int, r.readline().rstrip().split(' '))
  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)
  
",210," 
  mod_plus_conv_with_d = {0:1, 1:1, 2:2}
  mod_plus_conv_with_e = {0:0, 1:1, 2:1}
  
  def solve_case(si, case, ncore,line__numbered):
  	ann = 0
  	for scale in ncore:
  		if case <= (scale / 3) + mod_plus_conv_with_e[scale % 3]:
  			ann = ann + 1
  		elif si > 0 and (scale / 3) > 0: 
  			if case <= (scale / 3) + mod_plus_conv_with_d[scale % 3]:
  				ann = ann + 1
  				si = si - 1
  	print ""Case #%d: %d"" % (line__numbered, ann)
  
  usr = sys.stdin
  
  if len(sys.argv) > 1:
  	usr = open(sys.argv[1], 'r')
  
  Total_devices = usr.readline()
  for line__numbered in range(1, int(Total_devices) + 1):
  	 case_lin = map(int, usr.readline().rstrip().split(' '))
  	solve_case( case_lin[1],  case_lin[2],  case_lin[3:], line__numbered)
  
",LABEL_52,LABEL_52,,-1,"mod_plus_conv_with_s,mod_plus_conv_without_s,s,p,scores,case_number,ans,score,r,total_cases,case_line","mod_plus_conv_with_s:0.5589088201522827,mod_plus_conv_without_s:0.6122837066650391,s:0.4896887540817261,p:0.5521259307861328,scores:0.6147885620594025,case_number:0.6931121647357941,ans:0.47780895233154297,score:0.5465730428695679,r:0.4554063081741333,total_cases:0.5583538115024567,case_line:0.556967556476593,",0,0,"case_number:line__numbered,scores:ncore,mod_plus_conv_without_s:mod_plus_conv_with_e,mod_plus_conv_with_s:mod_plus_conv_with_d,total_cases:Total_devices,case_line: case_lin,p:case,score:scale,s:si,ans:ras,r:usr,",0,0,Greedy,211,0.07705472707748413,failed,[],0.9731321930885315,0.6607861518859863
106," 
  def isPalindrome(n):
  	n = str(n)	
  	for i in xrange(len(n)/2):
  		if n[i] != n[(-i-1)]:
  			return False
  	return True
  
  
  inputFileName = sys.argv[1]
  
  f = file(inputFileName)
  fout = file(""output.txt"", ""w"")
  
  T = eval(f.readline())
  
  for case in xrange(T):
  	data = f.readline().split()
  	A = eval(data[0])
  	B = eval(data[1])
  
  	i = A
  	found = []
  	while i <= B:
  		if isPalindrome(i):
  			sqrtI = math.sqrt(i)
  			if sqrtI == int(sqrtI):
  				if isPalindrome(int(sqrtI)):
  					found.append(i)
  		i += 1
  
  	fout.write(""Case #%d: %d
"" %(case + 1, len(found)))
",185," 
  def isPalindrome(b):
  	b = str(b)	
  	for qi in xrange(len(b)/2):
  		if b[qi] != b[(-qi-1)]:
  			return False
  	return True
  
  
  inputTableHandle = sys.argv[1]
  
  feed = file(inputTableHandle)
  Fout = file(""output.txt"", ""w"")
  
  Data = eval(feed.readline())
  
  for trial in xrange(Data):
  	aa = feed.readline().split()
  	D = eval(aa[0])
  	B = eval(aa[1])
  
  	qi = D
  	all = []
  	while qi <= B:
  		if isPalindrome(qi):
  			sqrtB = math.sqrt(qi)
  			if sqrtB == int(sqrtB):
  				if isPalindrome(int(sqrtB)):
  					all.append(qi)
  		qi += 1
  
  	Fout.write(""Case #%d: %d
"" %(trial + 1, len(all)))
",LABEL_53,LABEL_53,,-1,"n,i,inputFileName,f,fout,T,case,data,A,B,found,sqrtI","n:0.6396366655826569,i:0.6762022972106934,inputFileName:0.6987048387527466,f:0.7807528227567673,fout:0.6116431057453156,T:0.670169860124588,case:0.47841593623161316,data:0.6150815188884735,A:0.4920162856578827,B:0.5044569075107574,found:0.5556250214576721,sqrtI:0.5663633942604065,",0,0,"f:feed,inputFileName:inputTableHandle,i:qi,T:Data,n:b,data:aa,fout:Fout,sqrtI:sqrtB,found:all,A:D,case:trial,",0,0,Greedy,247,0.08967429002126058,failed,[],0.9512659907341003,0.7319028973579407
107,"arq = file(""input.in"")
  n_cases = eval(arq.readline())
  out = file(""output.txt"", ""w"")
  
  for case in xrange(n_cases):
  
  	data = arq.readline()
  	data = data.strip()
  	data = data.split("" "")
  
  	n = eval(data[0])
  	s = eval(data[1])
  	p = eval(data[2])
  
  	scores = []
  	n_googlers_with_best_result = 0
  	candidates = 0
  
  	for j in data[3:]:
  		i = eval(j)
  		if i%3 == 0:
  			score = i/3
  			scores.append([score, score, score])
  		elif (i+1)%3 == 0:
  			score = (i+1)/3
  			scores.append([score-1, score, score])
  		else: #(i+2)%3 == 0
  			score = (i+2)/3
  			scores.append([score-1, score-1, score])
  
  	for score in scores:
  		if score[2] >= p:
  			n_googlers_with_best_result +=1
  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:
  			candidates += 1
  
  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)
  
  	out.write(""Case #%d: %d
"" % (case+1, n_googlers_with_best_result))
",264,,LABEL_53,LABEL_35,,-4,"arq,n_cases,out,case,data,n,s,p,scores,n_googlers_with_best_result,candidates,j,i,score",,,,,0,0,Greedy,1,0.0005950530370076498,,,0.17226804792881012,0.17226804792881012
108," 
  
  def isPal(n):
      l = str(n)
      return l == l[::-1]
  
  def solve(a, b):
      l = int(math.ceil(math.sqrt(a)))
      u = int(math.floor(math.sqrt(b)))
  
      count = 0
      for x in range(l, u + 1):
          if isPal(x):
              if isPal(x*x):
                  count += 1
      return str(count)
  
  def main():
      N = int(sys.stdin.readline()) # number of testcases
      for i in range(N):
          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]
          result = solve(a, b)
          print (""Case #%s: %s"" % (i+1, result))
  
  
  
  if __name__ == '__main__':
      main()
",182," 
  
  def isPal(v):
      dl = str(v)
      return dl == dl[::-1]
  
  def solve(s, p):
      dl = int(math.ceil(math.sqrt(s)))
      ui = int(math.floor(math.sqrt(p)))
  
      name = 0
      for input in range(dl, ui + 1):
          if isPal(input):
              if isPal(input*input):
                  name += 1
      return str(name)
  
  def main():
      NC = int(sys.stdin.readline()) # number of testcases
      for uri in range(NC):
          [s,p] = [int(input) for input in sys.stdin.readline().rstrip().split()]
          pair = solve(s, p)
          print (""Case #%s: %s"" % (uri+1, pair))
  
  
  
  if __name__ == '__main__':
      main()
",LABEL_54,LABEL_54,,-1,"n,l,a,b,u,count,x,N,i,result","n:0.7420660704374313,l:0.7381801456212997,a:0.740799680352211,b:0.7516176700592041,u:0.7582504600286484,count:0.7700385600328445,x:0.7633816599845886,N:0.748828649520874,i:0.7486608475446701,result:0.7577434033155441,",0,0,"count:name,x:input,u:ui,result:pair,b:be,N:NC,i:phi,n:v,a:v,l:lp,",0,0,Greedy,206,0.07455261945724487,failed,[],0.9052935242652893,0.7601768970489502
109," 
  
  
  def solve(num_surprises, p, ts):
      s = 0
      u = 0
      for t in ts:
          a = int(t/3)
          r = t % 3
          if a+1 >= p and not r == 0:
              u += 1
          elif a >= p and r == 0:
              u += 1
          elif a > 0 and a+1 >= p and r == 0:
              s += 1
          elif a+2 >= p and r == 2:
              s += 1
  
      return min(num_surprises, s) + u
          
          
  
  def main():
      N = int(sys.stdin.readline()) # number of testcases
      for i in range(N):
          line = [int(x) for x in sys.stdin.readline().split()]
          num_surprises = line[1]
          p = line[2]
          ts = line[3:]
          result = solve(num_surprises, p, ts)
          print (""Case #%s: %s"" % (i+1, result))
  
  
  if __name__ == '__main__':
      main()
",198," 
  
  
  def solve(num_surprises, point, tp):
      cs = 0
      Lu = 0
      for window in tp:
          aa = int(window/3)
          mr = window % 3
          if aa+1 >= point and not mr == 0:
              Lu += 1
          elif aa >= point and mr == 0:
              Lu += 1
          elif aa > 0 and aa+1 >= point and mr == 0:
              cs += 1
          elif aa+2 >= point and mr == 2:
              cs += 1
  
      return min(num_surprises, cs) + Lu
          
          
  
  def main():
      Q = int(sys.stdin.readline()) # number of testcases
      for page in range(Q):
          line = [int(xf) for xf in sys.stdin.readline().split()]
          num_surprises = line[1]
          point = line[2]
          tp = line[3:]
          uri = solve(num_surprises, point, tp)
          print (""Case #%s: %s"" % (page+1, uri))
  
  
  if __name__ == '__main__':
      main()
",LABEL_54,LABEL_54,,-1,"num_surprises,p,ts,s,u,t,a,r,N,i,line,x,result","num_surprises:0.7016455233097076,p:0.787525475025177,ts:0.7919758856296539,s:0.7661475986242294,u:0.7909186035394669,t:0.8021187484264374,a:0.7992299944162369,r:0.7842773199081421,N:0.7820592373609543,i:0.7954856753349304,line:0.796647384762764,x:0.7986912429332733,result:0.8050833195447922,",0,0,"result:uri,t:window,a:aa,x:xf,i:page,ts:tp,u:Lu,p:tp,r:mr,N:Q,s:cs,",0,0,Greedy,272,0.09868128697077433,failed,[],0.9434376358985901,0.6720062494277954
110," 
  def ispal(n):
      s = str(n)
      return s == s[::-1]
  
  def ispalsq(n):
      sqrt = int(math.sqrt(n) + .01)
      if sqrt ** 2 != n:
          return False
      return ispal(n) and ispal(sqrt)
  
  def search(s, l, idx):
      if l % 2 == 0:
          m = s + s[::-1]
      else:
          m = s[:-1] + s[::-1]
      assert ispal(m)
      n = int(m) ** 2
      if not ispal(n):
          return 0
  
      r = 1 if (a <= n <= b) else 0
      for i in xrange(idx, len(s)):
          s2 = list(s)
          s2[i] = str(int(s2[i])+1)
          s2 = ''.join(s2)
          r += search(s2, l, i)
      return r
  
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      for _t in xrange(t):
          a, b = map(int, f.readline().split())
  
          total = 0
          for l in xrange(1, 150):
              if 10 ** (l-1) > b:
                  break
              total += search(""1"" + ""0"" * ((l-1)/2), l, 0)
          print ""Case #%d: %d"" % (_t+1, total)
  
",329," 
  def ispal(n):
      s = str(n)
      return s == s[::-1]
  
  def ispalsq(n):
      sqrt = int(math.sqrt(n) + .01)
      if sqrt ** 2 != n:
          return False
      return ispal(n) and ispal(sqrt)
  
  def search(s, l, idx):
      if l % 2 == 0:
          m = s + s[::-1]
      else:
          m = s[:-1] + s[::-1]
      assert ispal(m)
      n = int(m) ** 2
      if not ispal(n):
          return 0
  
      r = 1 if (a <= n <= b) else 0
      for i in xrange(idx, len(s)):
          s2 = list(s)
          s2[i] = str(int(s2[i])+1)
          s2 = ''.join(s2)
          r += search(s2, l, i)
      return r
  
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          FN = sys.argv[1]
          if FN != '-':
              f = open(FN)
  
      t = int(f.readline())
      for _t in xrange(t):
          a, b = map(int, f.readline().split())
  
          total = 0
          for l in xrange(1, 150):
              if 10 ** (l-1) > b:
                  break
              total += search(""1"" + ""0"" * ((l-1)/2), l, 0)
          print ""Case #%d: %d"" % (_t+1, total)
  
",LABEL_55,LABEL_55,LABEL_46,1,"n,s,sqrt,l,idx,m,r,i,s2,f,fn,t,_t,a,b,total","n:0.26592159271240234,s:0.26114554703235626,sqrt:0.2666102200746536,l:0.254780650138855,idx:0.2560601979494095,m:0.26301419734954834,r:0.2561541050672531,i:0.2637408375740051,s2:0.27615146338939667,f:0.26681283116340637,fn:0.28529752790927887,t:0.2750498652458191,_t:0.2830232083797455,a:0.26550567150115967,b:0.25982216000556946,total:0.28061404824256897,",1,3,,0,0,Greedy,37,0.015344913800557454,replace,[],0.40995004773139954,0.40995004773139954
111," 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      for _t in xrange(t):
          ns = map(int, f.readline().split())
          n = ns[0]
          s = ns[1]
          p = ns[2]
          assert len(ns) == n + 3
          scores = ns[3:3+n]
  
          sure = 0
          if_surprising = 0
          for x in scores:
              not_surprising = (x + 2) / 3
              is_surprising = (x + 4) / 3
              if not_surprising >= p:
                  sure += 1
              elif (2 <= x <= 28) and is_surprising >= p:
                  if_surprising += 1
          print ""Case #%d: %d"" % (_t+1, sure + min(if_surprising, s))
",180," 
  if __name__ == ""__main__"":
      i = sys.stdin
      if len(sys.argv) >= 2:
          ren = sys.argv[1]
          if ren != '-':
              i = open(ren)
  
      size = int(i.readline())
      for  _tt in xrange(size):
          posts = map(int, i.readline().split())
          num = posts[0]
          sys = posts[1]
          pn = posts[2]
          assert len(posts) == num + 3
          incors = posts[3:3+num]
  
          only = 0
          ifnotcurprising = 0
          for y in incors:
              not_Surprisingly = (y + 2) / 3
              is_purprising = (y + 4) / 3
              if not_Surprisingly >= pn:
                  only += 1
              elif (2 <= y <= 28) and is_purprising >= pn:
                  ifnotcurprising += 1
          print ""Case #%d: %d"" % ( _tt+1, only + min(ifnotcurprising, sys))
",LABEL_55,LABEL_55,,-1,"f,fn,t,_t,ns,n,s,p,scores,sure,if_surprising,x,not_surprising,is_surprising","f:0.8519670814275742,fn:0.7987698167562485,t:0.844398021697998,_t:0.848989337682724,ns:0.825889378786087,n:0.8243840485811234,s:0.7861469835042953,p:0.7933447808027267,scores:0.8071701377630234,sure:0.8117817789316177,if_surprising:0.851589173078537,x:0.7963837385177612,not_surprising:0.8686147034168243,is_surprising:0.8639007955789566,",0,0,"not_surprising:not_Surprisingly,is_surprising:is_purprising,f:i,if_surprising:ifnotcurprising,_t: _tt,t:size,ns:posts,n:ni,sure:only,scores:incors,fn:ren,x:h,p:pn,s:size,",0,0,Greedy,282,0.10218453804651896,failed,[],0.993950366973877,0.9745008945465088
112," 
  
  def readfile(file):
    """"""
      input:
  
  		T (number of test cases)
  
  		A B
  
    """"""
  
    tests = []
  
    T = int(file.readline().strip())
  
    for i in xrange(T):
  		test = {}
  
  		line = file.readline().strip()
  		parts = line.split("" "")
  
  		if len(parts) != 2:
  			print ""HORRIBLE ERROR IN TEST CASE %d"" % (i+1,)
  			return None
  
  		test['A'] = int(parts[0])
  		test['B'] = int(parts[1])
      
  		tests.append(test)
  
    return tests
  
  def isPalindrome(s):
  	""""""
  		Is s a palindrome.
  
  		S must be a string.
  	""""""
  
  	l = len(s)
  
  	if (l % 2) == 0:
  		frontHalf = s[0:l/2]
  		backHalf = s[l/2:]
  	else:
  		frontHalf = s[0:(l-1)/2]
  		backHalf = s[(l+1)/2:]
  
  	backHalf = backHalf[::-1]
  
  	if frontHalf == backHalf:
  		return True
  	else:
  		return False
  
  def isFairAndSquare(n):
  
  	sqrtN = int(math.sqrt(n))
  
  	if (sqrtN * sqrtN) != n:
  		return False
  
  	if not isPalindrome(str(n)):
  		return False
  
  	if not isPalindrome(str(sqrtN)):
  		return False
  
  	return True
  
  def run(test):
  	""""""
  		Run a test and return output.
  	""""""
  
  	count = 0
  
  	for i in xrange(test['A'], test['B'] + 1):
  		if isFairAndSquare(i):
  			count = count + 1
  
  	return count
  
  	i = int(math.sqrt(test['A']))
  
  	if (i * i) < test['A']:
  		i = i + 1
  
  	while i < test['B']:
  		if not isPalindrome(str(i)):
  			i = i + 1
  			continue
  
  		s = i * i
  
  		if s <= test['B']:
  			if isPalindrome(str(s)):
  				count = count + 1
  		else:
  			break
  
  		i = i + 1
  
  	return ""%s"" % (count, )
  
  file = open(sys.argv[1], ""rt"")
  
  tests = readfile(file)
  
  file.close()
  
  case = 1
  
  for test in tests:
    result = run(test)
    print ""Case #%d: %s"" % (case, result)
    case = case + 1
",437," 
  
  def readfile(input):
    """"""
      input:
  
  		T (number of test cases)
  
  		A B
  
    """"""
  
    checks = []
  
    Test = int(input.readline().strip())
  
    for iq in xrange(Test):
  		test = {}
  
  		band = input.readline().strip()
  		data = band.split("" "")
  
  		if len(data) != 2:
  			print ""HORRIBLE ERROR IN TEST CASE %d"" % (iq+1,)
  			return None
  
  		test['A'] = int(data[0])
  		test['B'] = int(data[1])
      
  		checks.append(test)
  
    return checks
  
  def isPalindrome(service):
  	""""""
  		Is s a palindrome.
  
  		S must be a string.
  	""""""
  
  	log = len(service)
  
  	if (log % 2) == 0:
  		behindHalf = service[0:log/2]
  		backHalf = service[log/2:]
  	else:
  		behindHalf = service[0:(log-1)/2]
  		backHalf = service[(log+1)/2:]
  
  	backHalf = backHalf[::-1]
  
  	if behindHalf == backHalf:
  		return True
  	else:
  		return False
  
  def isFairAndSquare(ne):
  
  	squrotN = int(math.sqrt(ne))
  
  	if (squrotN * squrotN) != ne:
  		return False
  
  	if not isPalindrome(str(ne)):
  		return False
  
  	if not isPalindrome(str(squrotN)):
  		return False
  
  	return True
  
  def run(test):
  	""""""
  		Run a test and return output.
  	""""""
  
  	shift = 0
  
  	for iq in xrange(test['A'], test['B'] + 1):
  		if isFairAndSquare(iq):
  			shift = shift + 1
  
  	return shift
  
  	iq = int(math.sqrt(test['A']))
  
  	if (iq * iq) < test['A']:
  		iq = iq + 1
  
  	while iq < test['B']:
  		if not isPalindrome(str(iq)):
  			iq = iq + 1
  			continue
  
  		service = iq * iq
  
  		if service <= test['B']:
  			if isPalindrome(str(service)):
  				shift = shift + 1
  		else:
  			break
  
  		iq = iq + 1
  
  	return ""%s"" % (shift, )
  
  input = open(sys.argv[1], ""rt"")
  
  checks = readfile(input)
  
  input.close()
  
  case = 1
  
  for test in checks:
    result = run(test)
    print ""Case #%d: %s"" % (case, result)
    case = case + 1
",LABEL_56,LABEL_56,,-1,"file,tests,T,i,test,line,parts,s,l,frontHalf,backHalf,n,sqrtN,count,case,result","file:0.7198478579521179,tests:0.6260834634304047,T:0.6774569749832153,i:0.6281704902648926,test:0.546696811914444,line:0.6421189606189728,parts:0.48676979541778564,s:0.5519353449344635,l:0.7722386121749878,frontHalf:0.7661640346050262,backHalf:0.7586346566677094,n:0.564897745847702,sqrtN:0.7815795391798019,count:0.5184943079948425,case:0.7480513751506805,result:0.7055991888046265,",0,0,"sqrtN:squrotN,l:log,frontHalf:behindHalf,file:input,T:Test,line:strip,i:iq,tests:checks,n:ne,s:service,count:shift,parts:data,",0,0,Greedy,335,0.12532208363215128,failed,[],0.9513126015663147,0.6203880310058594
113," 
  def readfile(filename):
  	""""""
  		The first line of the input gives the number of test
  		cases, T. T test cases follow. Each test case consists of
  		a single line containing integers separated by single
  		spaces. The first integer will be N, the number of
  		Googlers, and the second integer will be S, the number
  		of surprising triplets of scores. The third integer will
  		be p, as described above. Next will be N integers ti:
  		the total points of the Googlers.
  	""""""
  
  	file = open(filename, ""rt"")
  
  	retval = {}
  
  	T = int(file.readline().strip())
  	retval['T'] = T
  
  	tests = []
  
  	for i in xrange(T):
  		line = file.readline().strip()
  
  		parts = line.split("" "")
  
  		N = int(parts[0])
  		S = int(parts[1])
  		p = int(parts[2])
  		t = []
  
  		for j in xrange(N):
  			t = t + [int(parts[3 + j]), ]
  
  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }
  		tests = tests + [test, ]
  
  	retval['tests'] = tests
  	return retval
  
  def spread(triplet):
  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))
  
  def bestresult(triplet):
  	if triplet:
  		return max(triplet)
  	return 0
  
  def getcombos(points):
  	""""""
  		Returns ([unsurprising possibilities, ], [surprising possibilities])
  	""""""
  
  	unsurps = []
  	surps = []
  
  	avg = points / 3.0
  
  	avg = int(avg)
  
  	tested = []
  
  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):
  				if (i + j + k) != points:
  					continue
  
  				scores = (i,j,k)
  				scores = sorted(scores)
  
  				if scores in tested:
  					continue
  				tested.append(scores)
  
  				s = spread((i,j,k))
  
  				if (s < 2):
  					unsurps.append(scores)
  				elif (s == 2):
  					surps.append(scores)
  				else:
  					continue
  
  	return (unsurps, surps)
  
  def getbesttriplet(triplets):
  	best = None
  
  	for i in triplets:
  		if best:
  			if (bestresult(i) > bestresult(best)):
  				best = i
  		else:
  			best = i
  
  	return best
  	
  
  def getmulticombos(peeps):
  	""""""
  		Return the best surprising and non-surprising possibility for
  		each person.
  	""""""
  
  	ret = []
  
  	for p in peeps:
  		u,s = getcombos(p)
  
  		bestu = getbesttriplet(u)
  		bests = getbesttriplet(s)
  
  		ret.append((bestu, bests))
  
  	return ret
  
  def getbestresults(scores, best, numsur):
  	""""""
  		Figure out the maximum number of people that could have gotten
  		a single score >= best.  Limited to choosing only numsur surprising
  		triplets.
  	""""""
  
  	peeps = getmulticombos(scores)
  
  	count = 0
  	surcount = 0
  
  	for p in peeps:
  		if (bestresult(p[0]) >= best):
  			count = count + 1
  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):
  			count = count + 1
  			surcount = surcount + 1
  
  	return count
  
  def process(test):
  	N = test['N']
  	S = test['S']
  	p = test['p']
  	t = test['t']
  
  	return getbestresults(t, p, S)
  
  data = readfile(""B-small-attempt0.in"")
  
  for i in xrange(data['T']):
  	test = data['tests'][i]
  
  	result = process(test)
  
  	print ""Case #%d: %d"" % (i+1, result)
",662,,LABEL_56,LABEL_35,,-4,"filename,file,retval,T,tests,i,line,parts,N,S,p,t,j,test,triplet,points,unsurps,surps,avg,tested,k,scores,s,triplets,best",,,,,0,0,Greedy,1,0.0007763107617696127,,,0.1327389031648636,0.1327389031648636
114," 
  class Test(unittest.TestCase):
  	def test_1(self):
  		self.assertEqual(main(1, 4), 2)
  	def test_2(self):
  		self.assertEqual(main(10, 120), 0)
  	def test_3(self):
  		self.assertEqual(main(100, 100000000000000), 2)
  
  tCase = int(sys.stdin.readline())
  
  
  def main(M, N):
  	fns = 0
  	num = M
  	maior = math.sqrt(N)
  	int_maior = 0
  	
  	if maior.is_integer():
  		int_maior = int(maior) - 1
  		if fair(N):
  			if fair(int(maior)):
  				fns += 1
  	else:
  		int_maior = int(maior)
  		
  	while int_maior >= 1:
  		if fair(int_maior):
  			quadrado = int_maior * int_maior
  			if quadrado >= M:
  				if fair(quadrado):
  					fns += 1
  		int_maior -= 1
  	return fns
  
  def main2(M, N):
  	fns = 0
  	num = M
  	while num <= N:
  		result = raiz(num)
  		if result:
  			if fair(num):
  			
  				if fair(result):
  					fns += 1
  		num += 1
  	return fns
  	
  def fair(num):
  	return str(num) == str(num)[::-1]
  	
  def raiz(num):
  	result = math.sqrt(num)
  	if result.is_integer():
  		return int(result)
  	else:
  		return False
  	
  if __name__ == '__main__':
  	for i in xrange(tCase):	
  		
  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	
  		print ""Case #%d: %d"" % (i + 1, main(N,M))
",331," 
  class Test(unittest.TestCase):
  	def test_1(ref):
  		ref.assertEqual(main(1, 4), 2)
  	def test_2(ref):
  		ref.assertEqual(main(10, 120), 0)
  	def test_3(ref):
  		ref.assertEqual(main(100, 100000000000000), 2)
  
  tmStep = int(sys.stdin.readline())
  
  
  def main(SM, Na):
  	fns = 0
  	offset = SM
  	mair = math.sqrt(Na)
  	int_kaior = 0
  	
  	if mair.is_integer():
  		int_kaior = int(mair) - 1
  		if fair(Na):
  			if fair(int(mair)):
  				fns += 1
  	else:
  		int_kaior = int(mair)
  		
  	while int_kaior >= 1:
  		if fair(int_kaior):
  			quetrado = int_kaior * int_kaior
  			if quetrado >= SM:
  				if fair(quetrado):
  					fns += 1
  		int_kaior -= 1
  	return fns
  
  def main2(SM, Na):
  	fns = 0
  	offset = SM
  	while offset <= Na:
  		result = raiz(offset)
  		if result:
  			if fair(offset):
  			
  				if fair(result):
  					fns += 1
  		offset += 1
  	return fns
  	
  def fair(offset):
  	return str(offset) == str(offset)[::-1]
  	
  def raiz(offset):
  	result = math.sqrt(offset)
  	if result.is_integer():
  		return int(result)
  	else:
  		return False
  	
  if __name__ == '__main__':
  	for I in xrange(tmStep):	
  		
  		Na,SM = [int(x) for x in sys.stdin.readline().split(' ')]	
  		print ""Case #%d: %d"" % (I + 1, main(Na,SM))
",LABEL_57,LABEL_57,,-1,"self,tCase,M,N,fns,num,maior,int_maior,quadrado,result,i,x","self:0.7185254245996475,tCase:0.7119881808757782,M:0.7213108316063881,N:0.7195514515042305,fns:0.7152030989527702,num:0.7059859335422516,maior:0.7156213819980621,int_maior:0.7046645134687424,quadrado:0.7103490233421326,result:0.7118435576558113,i:0.7299001514911652,x:0.7266293913125992,",0,0,"i:I,M:SM,N:Na,self:ref,maior:mair,tCase:tmStep,quadrado:quetrado,num:offset,int_maior:int_kaior,",0,0,Greedy,251,0.09267612695693969,failed,[],0.8201552629470825,0.17844326794147491
115," 
  tCase = int(sys.stdin.readline())
  
  def alien(frases,case):
  	
  	case = case.replace('(','[')
  	case = case.replace(')',']')
  	
  	ER1 = re.compile(case, re.I)
  	count = 0
  	for frase in frases:
  		if ER1.search(frase):
  			count += 1
  	return count
  
  
  for i in xrange(tCase):	
  	linha = sys.stdin.readline().split()
  	P = int(linha[1])
  	T = int(linha[2])
  	list = []
  	for j in range (3,len(linha)):
  		list.append(int(linha[j]))
  	list.sort(reverse=True)
  	realT = T*3 - 2
  	supT = realT - 2
  	
  	count = 0
  	for item in list:
  		if item >= realT:
  			count += 1
  		elif P > 0 and item >= supT and T >= 2:
  			count += 1
  			P -= 1
  		elif P > 0 and item >= realT and T == 1:
  			count += 1
  			P -= 1
  		elif T == 0:
  			count += 1
  		else:
  			break
  		
  	print ""Case #%d: %d"" % (i+1, count)
  	
  	
  
",236," 
  tCase = int(sys.stdin.readline())
  
  def alien(frases,case):
  	
  	case = case.replace('(','[')
  	case = case.replace(')',']')
  	
  	ER1 = re.compile(case, re.I)
  	offset = 0
  	for frase in frases:
  		if ER1.search(frase):
  			offset += 1
  	return offset
  
  
  for ai in xrange(tCase):	
  	linha = sys.stdin.readline().split()
  	P = int(linha[1])
  	T = int(linha[2])
  	list = []
  	for ip in range (3,len(linha)):
  		list.append(int(linha[ip]))
  	list.sort(reverse=True)
  	realN = T*3 - 2
  	supt = realN - 2
  	
  	offset = 0
  	for t in list:
  		if t >= realN:
  			offset += 1
  		elif P > 0 and t >= supt and T >= 2:
  			offset += 1
  			P -= 1
  		elif P > 0 and t >= realN and T == 1:
  			offset += 1
  			P -= 1
  		elif T == 0:
  			offset += 1
  		else:
  			break
  		
  	print ""Case #%d: %d"" % (ai+1, offset)
  	
  	
  
",LABEL_57,LABEL_57,LABEL_62,1,"tCase,frases,case,ER1,count,frase,i,linha,P,T,list,j,realT,supT,item","tCase:0.4198472797870636,frases:0.41908979415893555,case:0.4386463612318039,ER1:0.40625469386577606,count:0.48587679862976074,frase:0.43425852060317993,i:0.4950893968343735,linha:0.4267997294664383,P:0.4326915889978409,T:0.4575378745794296,list:0.44912056624889374,j:0.4827182739973068,realT:0.4596269875764847,supT:0.46964456140995026,item:0.464540958404541,",1,4,"i:ai,count:offset,j:ip,supT:supt,item:t,",0,0,Greedy,135,0.0503179669380188,replace,[],0.6351726055145264,0.41275250911712646
116,"def sqrt(x, ge):
      if x == 1:
          return 1
      sx = x >> 1
      step = sx >> 1
  
      while step:
          if sx ** 2 >= x:
              sx = sx - step
          else:
              sx = sx + step
          step = step >> 1
  
      if ge:
          while not sx ** 2 < x:
              sx = sx - 1
          while not sx ** 2 >= x:
              sx = sx + 1
      else:
          while not sx ** 2 > x:
              sx = sx + 1
          while not sx ** 2 <= x:
              sx = sx - 1
  
      return sx
  
  
  def get_start_pali(a):
      s = str(a)
      ls = len(s)
      if ls == 1:
          return s, True
      elif ls & 1:
          return s[:ls >> 1 + 1], True
      else:
          return s[:ls >> 1], False
  
  
  def get_next_pali(p, m):
      if len(p) == p.count(""9""):
          if m:
              return ""1"" + ""0"" * (len(p) - 1), False
          else:
              return ""1"" + ""0"" * len(p), True
      else:
          return str(int(p) + 1), m
  
  
  def pali_to_num(p, m):
      if m:
          return int(p + p[-2::-1])
      else:
          return int(p + p[::-1])
  
  
  def is_pali(a):
      s = str(a)
      hls = len(s) >> 1
      return s[:hls] == s[:-hls - 1:-1]
  
  for i in range(int(input())):
      a, b = tuple(map(int, input().split()))
      sqa, sqb = sqrt(a, True), sqrt(b, False)
  
      p, m = get_start_pali(sqa)
      while pali_to_num(p, m) < sqa:
          p, m = get_next_pali(p, m)
  
      count = 0
  
      while True:
          curr = pali_to_num(p, m)
          if curr > sqb:
              break
          if is_pali(curr ** 2):
              count = count + 1
          p, m = get_next_pali(p, m)
  
      print(""Case #{}: {}"".format(i + 1, count))
",445,"def sqrt(x, sw):
      if x == 1:
          return 1
      sx = x >> 1
      step = sx >> 1
  
      while step:
          if sx ** 2 >= x:
              sx = sx - step
          else:
              sx = sx + step
          step = step >> 1
  
      if sw:
          while not sx ** 2 < x:
              sx = sx - 1
          while not sx ** 2 >= x:
              sx = sx + 1
      else:
          while not sx ** 2 > x:
              sx = sx + 1
          while not sx ** 2 <= x:
              sx = sx - 1
  
      return sx
  
  
  def get_start_pali(a):
      s = str(a)
      ls = len(s)
      if ls == 1:
          return s, True
      elif ls & 1:
          return s[:ls >> 1 + 1], True
      else:
          return s[:ls >> 1], False
  
  
  def get_next_pali(p, m):
      if len(p) == p.count(""9""):
          if m:
              return ""1"" + ""0"" * (len(p) - 1), False
          else:
              return ""1"" + ""0"" * len(p), True
      else:
          return str(int(p) + 1), m
  
  
  def pali_to_num(p, m):
      if m:
          return int(p + p[-2::-1])
      else:
          return int(p + p[::-1])
  
  
  def is_pali(a):
      s = str(a)
      hls = len(s) >> 1
      return s[:hls] == s[:-hls - 1:-1]
  
  for i in range(int(input())):
      a, b = tuple(map(int, input().split()))
      sqa, sqb = sqrt(a, True), sqrt(b, False)
  
      p, m = get_start_pali(sqa)
      while pali_to_num(p, m) < sqa:
          p, m = get_next_pali(p, m)
  
      count = 0
  
      while True:
          curr = pali_to_num(p, m)
          if curr > sqb:
              break
          if is_pali(curr ** 2):
              count = count + 1
          p, m = get_next_pali(p, m)
  
      print(""Case #{}: {}"".format(i + 1, count))
",LABEL_58,LABEL_58,LABEL_38,1,"x,ge,sx,step,a,s,ls,p,m,hls,i,b,sqa,sqb,count,curr","x:0.030353590846061707,ge:0.06276614964008331,sx:0.03472733497619629,step:0.016974501311779022,a:0.05383061617612839,s:-0.01927734911441803,ls:-0.007717415690422058,p:0.061263084411621094,m:0.029087945818901062,hls:0.04411578178405762,i:0.016155101358890533,b:0.030826427042484283,sqa:-0.08784730732440948,sqb:-0.09029948711395264,count:-0.0010406523942947388,curr:0.03595138341188431,",1,2,,0,0,Greedy,37,0.01553200880686442,replace,[],0.13747066259384155,0.13747066259384155
117,"def passes(p, t): #normal, surprising
      q, r = divmod(t, 3)
      if r == 0:
          return q >= p, q + 1 >= p and q
      elif r == 1:
          return q + 1 >= p, q + 1 >= p and q
      elif r == 2:
          return q + 1 >= p, q + 2 >= p
  
  for case in range(int(input())):
      st = input().strip().split()
      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))
      result = 0
      for i in t:
          normal, surprising = passes(p, i)
          if normal:
              result += 1
          elif surprising and s != 0:
              result += 1
              s -= 1
      print(""Case #{}: {}"".format(case + 1, result))
",192,"def passes(pp, section): #normal, surprising
      int, rar = divmod(section, 3)
      if rar == 0:
          return int >= pp, int + 1 >= pp and int
      elif rar == 1:
          return int + 1 >= pp, int + 1 >= pp and int
      elif rar == 2:
          return int + 1 >= pp, int + 2 >= pp
  
  for chain in range(int(input())):
      us = input().strip().split()
      l, stats, pp, section = int(us[0]), int(us[1]), int(us[2]), list(map(int, us[3:]))
      term = 0
      for ip in section:
          comment, urprises = passes(pp, ip)
          if comment:
              term += 1
          elif urprises and stats != 0:
              term += 1
              stats -= 1
      print(""Case #{}: {}"".format(chain + 1, term))
",LABEL_58,LABEL_58,,-1,"p,t,q,r,case,st,n,s,result,i,normal,surprising","p:0.737304225564003,t:0.6426472365856171,q:0.755556233227253,r:0.7364718019962311,case:0.7326835095882416,st:0.717388466000557,n:0.7402167469263077,s:0.7583605647087097,result:0.7597232908010483,i:0.7282565385103226,normal:0.7156163305044174,surprising:0.7550864964723587,",0,0,"result:term,s:stats,q:int,surprising:urprises,n:l,p:l,r:rg,case:chain,i:l,st:int,normal:comment,t:l,",0,0,Greedy,246,0.088907790184021,failed,[],0.874731719493866,0.5608295798301697
118,"lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,
      100020001,102030201,104060401,121242121,123454321,125686521,400080004,
      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,
      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,
      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,
      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,
      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,
      123456787654321,400000080000004]
  
  
  def solve(lo,hi):
      global lst
      count = 0
      for i in range(len(lst)):
          if (lst[i] >= lo and lst[i] <= hi ):
              count += 1
      return count
  
  fname = raw_input(""name of file: "")
  oname = raw_input(""output file name:"")
  f = open(fname,""r"")
  out = open(oname,""w"")
  n = int(f.readline()[:-1])
  case_num = 1
  for line in f:
      args = line[:-1].split()
      lo = int(args[0])
      hi = int(args[1])
      out.write(""Case #%d: %d
"" %(case_num,solve(lo,hi)))
      case_num += 1
      
  out.close()
  f.close()
      
",259,"lcste = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,
      100020001,102030201,104060401,121242121,123454321,125686521,400080004,
      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,
      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,
      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,
      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,
      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,
      123456787654321,400000080000004]
  
  
  def solve(ri,lim):
      global lcste
      child = 0
      for i in range(len(lcste)):
          if (lcste[i] >= ri and lcste[i] <= lim ):
              child += 1
      return child
  
  fname = raw_input(""name of file: "")
  onname = raw_input(""output file name:"")
  input = open(fname,""r"")
  Out = open(onname,""w"")
  ns = int(input.readline()[:-1])
  case_number = 1
  for case in input:
      args = case[:-1].split()
      ri = int(args[0])
      lim = int(args[1])
      Out.write(""Case #%d: %d
"" %(case_number,solve(ri,lim)))
      case_number += 1
      
  Out.close()
  input.close()
      
",LABEL_59,LABEL_59,,-1,"lst,lo,hi,count,i,fname,oname,f,out,n,case_num,line,args","lst:0.6904299408197403,lo:0.6418627202510834,hi:0.6586254686117172,count:0.6351456344127655,i:0.578451544046402,fname:0.5785048007965088,oname:0.6758848875761032,f:0.6858785599470139,out:0.6996638774871826,n:0.6346691995859146,case_num:0.467229425907135,line:0.6563042551279068,args:0.5477114915847778,",0,0,"out:Out,lst:lcste,f:input,oname:onname,hi:lim,line:case,lo:ri,count:all,n:ns,case_num:case_number,",0,0,Greedy,271,0.10004624923070272,failed,[],0.8395518064498901,0.30977970361709595
119,"fileName = raw_input(""File name: "")
  
  f = open(fileName,""r"")
  
  t = int(f.readline()[:-1])
  
  tests = []
  
  for i in range (t):
      tests += [f.readline()[:-1]]
  
  f.close()
  
  
  def compute(raw):
      dataN = [] # keeps the max mark for not surprising
      dataS = [] # keeps the max marks for surprisings
      
      items = raw.split() 
      
      for i in range (int(items[0])):
          ti = int(items[3+i])
          if ti < 1:
              dataS += [0]
              dataN += [0]
          elif ti > 28:
              dataS += [10]
              dataN += [10]
          else:
              dataN += [int((ti+2)/3)] # put the values for all participants
              dataS += [int((ti+4)/3)]
          
          
  
      
      p = int(items[2])
      s = int(items[1])
      
      n_vals = dataN
      n_vals.sort()
      
  
      i=0
      minimum = 0 # how many numbers greater than p are there in ""not surprising""
      if n_vals[0] < p:
          while n_vals[-1-i] >= p:
              minimum += 1
              i += 1
      else:
          minimum = len(n_vals)
          
  
      s_vals = dataS
      s_vals.sort()
      i=0
      maximum = 0 # how many numbers greater than p are there in ""surprising""
      if s_vals[0] < p:
          while s_vals[-1-i] >= p:
              maximum += 1
              i += 1
      else:
          maximum = len(n_vals)
      
      return min(maximum, minimum+s) 
      
  
  for i in range (t):
      print ""Case #%d: %d"" %(i+1,compute(tests[i]))
  
  
      
",311,"FileInfo = raw_input(""File name: "")
  
  full = open(FileInfo,""r"")
  
  tc = int(full.readline()[:-1])
  
  services = []
  
  for qi in range (tc):
      services += [full.readline()[:-1]]
  
  full.close()
  
  
  def compute(input):
      dataNs = [] # keeps the max mark for not surprising
      dataIs = [] # keeps the max marks for surprisings
      
      data = input.split() 
      
      for qi in range (int(data[0])):
          tip = int(data[3+qi])
          if tip < 1:
              dataIs += [0]
              dataNs += [0]
          elif tip > 28:
              dataIs += [10]
              dataNs += [10]
          else:
              dataNs += [int((tip+2)/3)] # put the values for all participants
              dataIs += [int((tip+4)/3)]
          
          
  
      
      pr = int(data[2])
      size = int(data[1])
      
      s_values = dataNs
      s_values.sort()
      
  
      qi=0
      filename = 0 # how many numbers greater than p are there in ""not surprising""
      if s_values[0] < pr:
          while s_values[-1-qi] >= pr:
              filename += 1
              qi += 1
      else:
          filename = len(s_values)
          
  
      s2val = dataIs
      s2val.sort()
      qi=0
      successful = 0 # how many numbers greater than p are there in ""surprising""
      if s2val[0] < pr:
          while s2val[-1-qi] >= pr:
              successful += 1
              qi += 1
      else:
          successful = len(s_values)
      
      return min(successful, filename+size) 
      
  
  for qi in range (tc):
      print ""Case #%d: %d"" %(qi+1,compute(services[qi]))
  
  
      
",LABEL_59,LABEL_59,,-1,"fileName,f,t,tests,i,raw,dataN,dataS,items,ti,p,s,n_vals,minimum,s_vals,maximum","fileName:0.7874090522527695,f:0.7489937543869019,t:0.7311917394399643,tests:0.7861755341291428,i:0.8142212182283401,raw:0.788970872759819,dataN:0.8048737347126007,dataS:0.8121270686388016,items:0.8087430596351624,ti:0.8020186275243759,p:0.7986359149217606,s:0.7906787544488907,n_vals:0.8094333857297897,minimum:0.793878823518753,s_vals:0.7678030878305435,maximum:0.7991297394037247,",0,0,"i:qi,dataS:dataIs,n_vals:s_values,items:data,dataN:dataNs,ti:tip,maximum:successful,p:pr,minimum:filename,s:size,raw:input,fileName:FileInfo,tests:services,s_vals:s_values,f:full,t:tc,",0,0,Greedy,333,0.12304832140604655,failed,[],0.9670753479003906,0.600153386592865
120," 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      res = []
      for i in range(R):
          res.append(reader(f, *args, **kwargs))
      return res
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for i in range(T):
                  case = read_case(fi)
                  res = solver(case)
                  write_case(fo, i, res)
  
  
  def read_case(f):
      return read_ints(f)
  
  def write_case(f, i, res):
      f.write('Case #%d: '%i)
      f.write('%d'%res)
      f.write('
')
  
  
  def aux(A, B, x, s):
      res = 0
      n = int(''.join(x[::-1]+x))
      nn = n*n
      if nn > B:
          return res
      if nn >= A:
          res += 1
      for c in [0, 1, 2]:
          if s + c*c < 10:
              n = int(''.join(x[::-1]+[str(c)]+x))
              nn = n*n
              if nn >= A and nn <= B:
                  res += 1
          if s + 2*c*c < 10:
              res += aux(A, B, [str(c)]+x, s + 2*c*c)
      return res
  
  def solve_small(case):
      [A, B] = case
      res = 0
      for n in [1, 4, 9]:
          if n >= A and n <= B:
              res += 1
      for c in [1, 2]:
          res += aux(A, B, [str(c)], 2*c*c)
      return res
  
  def solve_large(case):
      return solve_small(case)
  
  DEBUG = 'i'
  
",564," 
  def read_word(uf):
      return next(uf).strip()
  
  def read_int(uf, batch=10):
      return int(read_word(uf), batch)
  
  def read_letters(uf):
      return list(read_word(uf))
  
  def read_digits(uf, batch=10):
      return [int(model, batch) for model in read_letters(uf)]
  
  def read_words(uf, md=' '):
      return read_word(uf).split(md)
  
  def read_ints(uf, batch=10, md=' '):
      return [int(model, batch) for model in read_words(uf, md)]
  
  def read_floats(uf, md=' '):
      return [float(model) for model in read_words(uf, md)]
  
  def read_arr(uf, Rs, loader=read_ints, *args, **kwargs):
      test = []
      for u in range(Rs):
          test.append(loader(uf, *args, **kwargs))
      return test
  
  def solve(Solution, v, in_model=None):
      inningfd = v + '.in'
      if in_model is None:
          in_model = v + '.out'
      with open(inningfd, 'r') as fi:
          with open(in_model, 'w') as fo:
              shape = read_int(fi)
              for u in range(shape):
                  Case = read_case(fi)
                  test = Solution(Case)
                  write_case(fo, u, test)
  
  
  def read_case(uf):
      return read_ints(uf)
  
  def write_case(uf, u, test):
      uf.write('Case #%d: '%u)
      uf.write('%d'%test)
      uf.write('
')
  
  
  def aux(Alpha, U, model, t):
      test = 0
      coll = int(''.join(model[::-1]+model))
      unc = coll*coll
      if unc > U:
          return test
      if unc >= Alpha:
          test += 1
      for c in [0, 1, 2]:
          if t + c*c < 10:
              coll = int(''.join(model[::-1]+[str(c)]+model))
              unc = coll*coll
              if unc >= Alpha and unc <= U:
                  test += 1
          if t + 2*c*c < 10:
              test += aux(Alpha, U, [str(c)]+model, t + 2*c*c)
      return test
  
  def solve_small(Case):
      [Alpha, U] = Case
      test = 0
      for coll in [1, 4, 9]:
          if coll >= Alpha and coll <= U:
              test += 1
      for c in [1, 2]:
          test += aux(Alpha, U, [str(c)], 2*c*c)
      return test
  
  def solve_large(Case):
      return solve_small(Case)
  
  DEBUG = 'i'
  
",LABEL_60,LABEL_60,,-1,"f,b,x,d,R,reader,res,i,solver,fn,out_fn,in_fn,T,case,A,B,s,n,nn,c","f:0.39842355251312256,b:0.10929340124130249,x:0.09478360414505005,d:0.1121140718460083,R:0.12475931644439697,reader:0.13116681575775146,res:0.22012662887573242,i:0.1119927167892456,solver:0.12984561920166016,fn:0.10925114154815674,out_fn:0.10330057144165039,in_fn:0.20966124534606934,T:0.1246412992477417,case:0.12170451879501343,A:0.10996246337890625,B:0.1321524977684021,s:0.10984921455383301,n:0.12093997001647949,nn:0.08968889713287354,c:0.05229312181472778,",0,0,"f:uf,res:test,in_fn:inningfd,B:U,reader:loader,solver:Solution,R:Rs,T:shape,case:Case,n:coll,d:md,i:u,A:Alpha,s:t,b:fb,fn:v,out_fn:in_model,x:inf,nn:unc,",0,0,Greedy,414,0.15646899541219075,failed,[],0.9919186234474182,0.5973926186561584
121," 
  __file__ = sys.argv[0]
  __path__ = os.path.dirname(__file__)
  __prob__ = os.path.basename(__path__)
  
  def pout(s, back=0):
      f = sys._getframe(back+1)
      d = 0
      if 'depth' in f.f_locals:
          d = f.f_locals['depth']
      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))
  
  def perr(s, back=0):
      f = sys._getframe(back+1)
      d = 0
      if 'depth' in f.f_locals:
          d = f.f_locals['depth']
      ERR_FILE.write(' '*d + '%s = %s
'%(s, repr(eval(s, f.f_globals, f.f_locals))))
  
  def argmin(f, s=None):
      a = f
      if s is None:
          s = range(len(a))
          f = lambda i: a[i]
      res = None
      for x in s:
          y = f(x)
          if res is None or best > y:
              best = y
              res = x
      return res
  
  def argmax(f, s=None):
      a = f
      if s is None:
          s = range(len(a))
          f = lambda i: a[i]
      res = None
      for x in s:
          y = f(x)
          if res is None or best < y:
              best = y
              res = x
      return res
  
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_word_arr(f, R):
      res = []
      for i in range(R):
          res.append(read_word(f))
      return res
  
  def read_ints_arr(f, R, dtype=int, *args, **kwargs):
      res = []
      for i in range(R):
          res.append(read_ints(f, *args, **kwargs))
      return numpy.array(res, dtype)
  
  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
      global ERR_FILE
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      err_fn = fn + '.err'
      if start_case == 0:
          append = True
          if os.path.exists(out_fn):
              with open(out_fn, 'r') as f:
                  for l in f:
                      if l[:6] == 'Case #':
                          start_case = int(l[6:l.index(':')])+1
      else:
          append = False
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'a' if append else 'w') as fo:
              with open(err_fn, 'w') as ERR_FILE:
                  T = read_int(fi)
                  for i in range(T):
                      case = read_case(fi)
                      if i+1 < start_case:
                          continue
                      print('Case #%d of %d'%(i+1, T))
                      ERR_FILE.write('Case #%d of %d
'%(i+1, T))
                      perr('case')
                      res = solver(case)
                      perr('res')
                      write_case(fo, i, res)
                      fo.flush()
                      if end_case is not None and i+1 == end_case:
                          break
  
  def test(start_case=1, end_case=None):
      fn = os.path.join(__path__, 'test')
      solve(solve_small, fn, start_case, end_case)
  
  def small(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
      solve(solve_small, fn, start_case, end_case)
  
  def small2(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
      solve(solve_large, fn, start_case, end_case, fn + '2.out')
  
  def large(start_case=0, end_case=None):
      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)
      solve(solve_large, fn, start_case, end_case)
  
  
  def read_case(f):
      Z = read_ints(f)
      (N, S, p) = Z[:3]
      t = Z[3:]
      return (N, S, p, t)
  
  def write_case(f, i, res):
      f.write('Case #%d: '%(i+1))
      f.write('%s'%res)
      f.write('
')
  
  FAIL = 'NO SOLUTION'
  
  def solve_small(case):
      (N, S, p, t) = case
      res = 0
      for i in range(N):
          if p >= 2:
              if t[i] >= 3*p-2:
                  res += 1
              elif S > 0 and t[i] >= 3*p-4:
                  res += 1
                  S -= 1
          elif p == 1:
              if t[i] >= 3*p-2:
                  res += 1
          elif p == 0:
              res += 1
      return res
  
  solve_large = solve_small
  
  pout = perr
",1043," 
  __path___ = sys.argv[0]
  __path__ = os.path.dirname(__path___)
  __proot__ = os.path.basename(__path__)
  
  def pout(s, back=0):
      f = sys._getframe(back+1)
      d = 0
      if 'depth' in f.f_locals:
          d = f.f_locals['depth']
      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))
  
  def perr(s, back=0):
      f = sys._getframe(back+1)
      d = 0
      if 'depth' in f.f_locals:
          d = f.f_locals['depth']
      ERR_FILE.write(' '*d + '%s = %s
'%(s, repr(eval(s, f.f_globals, f.f_locals))))
  
  def argmin(f, s=None):
      a = f
      if s is None:
          s = range(len(a))
          f = lambda i: a[i]
      res = None
      for x in s:
          y = f(x)
          if res is None or best > y:
              best = y
              res = x
      return res
  
  def argmax(f, s=None):
      a = f
      if s is None:
          s = range(len(a))
          f = lambda i: a[i]
      res = None
      for x in s:
          y = f(x)
          if res is None or best < y:
              best = y
              res = x
      return res
  
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_word_arr(f, R):
      res = []
      for i in range(R):
          res.append(read_word(f))
      return res
  
  def read_ints_arr(f, R, dtype=int, *args, **kwargs):
      res = []
      for i in range(R):
          res.append(read_ints(f, *args, **kwargs))
      return numpy.array(res, dtype)
  
  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
      global ERR_FILE
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      err_fn = fn + '.err'
      if start_case == 0:
          append = True
          if os.path.exists(out_fn):
              with open(out_fn, 'r') as f:
                  for l in f:
                      if l[:6] == 'Case #':
                          start_case = int(l[6:l.index(':')])+1
      else:
          append = False
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'a' if append else 'w') as fo:
              with open(err_fn, 'w') as ERR_FILE:
                  T = read_int(fi)
                  for i in range(T):
                      case = read_case(fi)
                      if i+1 < start_case:
                          continue
                      print('Case #%d of %d'%(i+1, T))
                      ERR_FILE.write('Case #%d of %d
'%(i+1, T))
                      perr('case')
                      res = solver(case)
                      perr('res')
                      write_case(fo, i, res)
                      fo.flush()
                      if end_case is not None and i+1 == end_case:
                          break
  
  def test(start_case=1, end_case=None):
      fn = os.path.join(__path__, 'test')
      solve(solve_small, fn, start_case, end_case)
  
  def small(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__proot__)
      solve(solve_small, fn, start_case, end_case)
  
  def small2(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__proot__)
      solve(solve_large, fn, start_case, end_case, fn + '2.out')
  
  def large(start_case=0, end_case=None):
      fn = os.path.join(__path__, '%s-large-attempt0'%__proot__)
      solve(solve_large, fn, start_case, end_case)
  
  
  def read_case(f):
      Z = read_ints(f)
      (N, S, p) = Z[:3]
      t = Z[3:]
      return (N, S, p, t)
  
  def write_case(f, i, res):
      f.write('Case #%d: '%(i+1))
      f.write('%s'%res)
      f.write('
')
  
  FAIL = 'NO SOLUTION'
  
  def solve_small(case):
      (N, S, p, t) = case
      res = 0
      for i in range(N):
          if p >= 2:
              if t[i] >= 3*p-2:
                  res += 1
              elif S > 0 and t[i] >= 3*p-4:
                  res += 1
                  S -= 1
          elif p == 1:
              if t[i] >= 3*p-2:
                  res += 1
          elif p == 0:
              res += 1
      return res
  
  solve_large = solve_small
  
  pout = perr
",LABEL_60,LABEL_60,LABEL_24,1,"__file__,__path__,__prob__,s,back,f,d,a,res,x,y,best,b,R,i,append,pout","__file__:0.8273822963237762,__path__:0.6968370378017426,__prob__:0.8955539837479591,s:0.2889738082885742,back:0.5440751612186432,f:0.34574460983276367,d:0.3208701014518738,a:0.4374953508377075,res:0.42135143280029297,x:0.28958505392074585,y:0.45532333850860596,best:0.49740082025527954,b:0.4781305193901062,R:0.3894118070602417,i:0.437417209148407,append:0.3443993926048279,pout:0.44223564863204956,",1,2,"__prob__:__proot__,",0,0,Greedy,52,0.022893651326497396,replace,[],0.9911370277404785,0.3584185540676117
122,"def esPal(x):
  	return str(x) == str(x)[::-1]
  
  t = int(raw_input())
  
  for case in range(t):
  	line = raw_input().split(' ')
  	a = int(line[0])
  	b = int(line[1])
  
  	i = int(a**.5)
  	if i*i != a:
  		i += 1
  	max = int(b**.5)
  	cantidad = 0
  	while i <= max:
  		if esPal(i) and esPal(i*i):
  			cantidad += 1
  		i += 1
  
  	print 'Case #'+str(case+1)+':', cantidad
",132,"def esPal(input):
  	return str(input) == str(input)[::-1]
  
  port = int(raw_input())
  
  for case in range(port):
  	l = raw_input().split(' ')
  	A = int(l[0])
  	alpha = int(l[1])
  
  	I = int(A**.5)
  	if I*I != A:
  		I += 1
  	int = int(alpha**.5)
  	 canticity = 0
  	while I <= int:
  		if esPal(I) and esPal(I*I):
  			 canticity += 1
  		I += 1
  
  	print 'Case #'+str(case+1)+':',  canticity
",LABEL_61,LABEL_61,,-1,"x,t,case,line,a,b,i,max,cantidad","x:0.6919431090354919,t:0.7478391975164413,case:0.6564175486564636,line:0.7446526437997818,a:0.6601836979389191,b:0.6664905250072479,i:0.6739969253540039,max:0.6540064215660095,cantidad:0.7075387239456177,",0,0,"t:port,line:l,cantidad: canticity,x:input,i:api,b:ab,a:ba,max:int,",0,0,Greedy,185,0.0663692315419515,failed,[],0.9895533323287964,0.9497513175010681
123,"t = int(raw_input())
  
  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]
  
  for i in range(t):
  	line = raw_input().split(' ')
  	n = int(line[0])
  	s = int(line[1])
  	p = int(line[2])
  
  	total = 0
  
  	for j in range(3, len(line)):
  		t = int(line[j])
  		if t == 0:
  			if p == 0:
  				total += 1
  		elif t%3 == 0:
  			if t/3 >= p:
  				total +=1
  			elif t/3 + 1 >= p and s>0:
  				total +=1
  				s -=1
  		elif t%3 == 1:
  			if (t+2)/3 >= p:
  				total +=1
  		else:
  			if (t+1)/3 >= p:
  				total +=1
  			elif (t+1)/3 + 1 >= p and s>0:
  				total +=1
  				s -=1
  
  
  
  	print 'Case #'+str(i+1)+':', total
  
  
",266,"art = int(raw_input())
  
  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]
  
  for i in range(art):
  	co = raw_input().split(' ')
  	net = int(co[0])
  	y = int(co[1])
  	b = int(co[2])
  
  	total = 0
  
  	for J in range(3, len(co)):
  		art = int(co[J])
  		if art == 0:
  			if b == 0:
  				total += 1
  		elif art%3 == 0:
  			if art/3 >= b:
  				total +=1
  			elif art/3 + 1 >= b and y>0:
  				total +=1
  				y -=1
  		elif art%3 == 1:
  			if (art+2)/3 >= b:
  				total +=1
  		else:
  			if (art+1)/3 >= b:
  				total +=1
  			elif (art+1)/3 + 1 >= b and y>0:
  				total +=1
  				y -=1
  
  
  
  	print 'Case #'+str(i+1)+':', total
  
  
",LABEL_61,LABEL_61,LABEL_20,1,"t,max,i,line,n,s,p,total,j","t:0.383421927690506,max:0.339057058095932,i:0.36396804451942444,line:0.3803429454565048,n:0.40690940618515015,s:0.4245153218507767,p:0.4225617125630379,total:0.15622183680534363,j:0.4037121683359146,",1,6,"s:y,p:b,n:np,j:J,t:art,",0,0,Greedy,124,0.045768324534098306,replace,[],0.5451461672782898,0.2879670560359955
124," 
  def is_palindrome(n):
      s = str(n)
      return s == s[::-1] 
  
  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]
  all_palindromes = palindromes[1] + palindromes[2]
  limit = [100]
  
  palindromic_squares = []
  psqtop = 0
  psqix = 0
  
  stdin = sys.stdin
  for c in xrange(int(stdin.readline())):
      a,b = map(int, stdin.readline().split())
  
      while psqtop < b:
          while psqix >= len(all_palindromes):
              ps = []
              pp = 10 ** (len(palindromes)-1) + 1
              for i in range(1,10):
                  for p in palindromes[-2]:
                      ps.append(i * pp + 10 * p) 
              palindromes.append(ps)
              all_palindromes.extend(ps)
  
          sq = all_palindromes[psqix] * all_palindromes[psqix]
          if is_palindrome(sq):
              palindromic_squares.append(sq)
          psqix  += 1
          psqtop = sq
  
      aix = bisect.bisect_left(palindromic_squares, a)
      bix = bisect.bisect_right(palindromic_squares, b)
  
      print ""Case #%i: %i"" % (c+1, bix-aix) 
",267,,LABEL_62,LABEL_45,,-4,"n,s,palindromes,all_palindromes,limit,palindromic_squares,psqtop,psqix,stdin,c,a,b,ps,pp,i,p,sq,aix,bix",,,,,0,0,Greedy,1,0.0006455818812052409,,,0.47211959958076477,0.47211959958076477
125," 
  T = int(stdin.readline())
  for i in xrange(1,T+1):
  	ns = map(int, stdin.readline().split())
  	N,S,p = ns[0:3]
  	
  	h = 0
  	z = 0
  
  	for n in ns[3:]:
  		if n <= 1:
  			if n >= p: h += 1	
  		elif (n+2) // 3 >= p:
  			h += 1
  		elif (n+4) // 3 >= p:
  			z += 1
  
  	print ""Case #%d: %d"" % (i, h + min(S,z))
  
  
",121," 
  NT = int(stdin.readline())
  for chi in xrange(1,NT+1):
  	ns = map(int, stdin.readline().split())
  	N,Z,lp = ns[0:3]
  	
  	h = 0
  	H = 0
  
  	for ot in ns[3:]:
  		if ot <= 1:
  			if ot >= lp: h += 1	
  		elif (ot+2) // 3 >= lp:
  			h += 1
  		elif (ot+4) // 3 >= lp:
  			H += 1
  
  	print ""Case #%d: %d"" % (chi, h + min(Z,H))
  
  
",LABEL_62,LABEL_62,LABEL_26,1,"T,i,ns,N,S,p,h,z,n","T:0.17135819792747498,i:0.2711591124534607,ns:0.10761061310768127,N:0.23085734248161316,S:0.21094700694084167,p:0.20755040645599365,h:0.14166659116744995,z:0.2043580412864685,n:0.18687480688095093,",1,2,"i:chi,S:Z,p:lp,z:zh,n:ot,",0,0,Greedy,148,0.05327378511428833,replace,[],0.5216144919395447,0.3799287974834442
126," 
  N = 10**4
  
  def isp(n):
      s = str(n)
      return s == s[::-1]
  
  fs = []
  for i in range(N):
      s = str(i)
      n1 = int(s + s[::-1])**2
      n2 = int(s[:-1] + s[::-1])**2
  
      if isp(n1):
          fs.append(n1)
      if isp(n2):
          fs.append(n2)
  
  fs.sort()
  
  print(fs, file=sys.stderr)
  
  
  fin = sys.stdin
  T = int(fin.readline())
  for case in range(1,T+1):
      board = []
      A, B = map(int, fin.readline().split())
  
      i = bisect.bisect_left(fs, A)
      j = bisect.bisect_right(fs, B)
  
      print(""Case #%d: %s"" % (case, j-i))
  
  
",202," 
  Q = 10**4
  
  def isp(size):
      xs = str(size)
      return xs == xs[::-1]
  
  jobs = []
  for id in range(Q):
      xs = str(id)
      yn1 = int(xs + xs[::-1])**2
      Ntwo = int(xs[:-1] + xs[::-1])**2
  
      if isp(yn1):
          jobs.append(yn1)
      if isp(Ntwo):
          jobs.append(Ntwo)
  
  jobs.sort()
  
  print(jobs, file=sys.stderr)
  
  
  fin = sys.stdin
  T = int(fin.readline())
  for count in range(1,T+1):
      board = []
      A, P = map(int, fin.readline().split())
  
      id = bisect.bisect_left(jobs, A)
      I = bisect.bisect_right(jobs, P)
  
      print(""Case #%d: %s"" % (count, I-id))
  
  
",LABEL_63,LABEL_63,LABEL_25,1,"N,n,s,fs,i,n1,n2,fin,T,case,board,A,B,j","N:0.657035768032074,n:0.6575039327144623,s:0.6253432333469391,fs:0.7103215008974075,i:0.6659671515226364,n1:0.6816854923963547,n2:0.7031175196170807,fin:0.49299320578575134,T:0.5108614861965179,case:0.7179320603609085,board:0.5764206051826477,A:0.6000706851482391,B:0.6498318910598755,j:0.6402726471424103,",1,8,"case:count,fs:jobs,n2:Ntwo,n1:yn1,i:id,n:size,N:Q,B:P,j:I,",0,0,Greedy,213,0.0775313933690389,replace,[],0.9097532033920288,0.4413357973098755
127," fin = sys.stdin
  T = int(fin.readline())
  for case in range(1,T+1):
      numbers = map(int, fin.readline().split())
      N, S, p = numbers[:3]
      T = numbers[3:]
      normal_limit = p + 2*max(0, (p-1))
      surpising_limit = p + 2*max(0, (p-2))
  
      normal_count = 0
      surprising_count = 0
  
      for t in T:
          if t >= normal_limit:
              normal_count += 1
          elif t >= surpising_limit:
              surprising_count += 1
  
      result = normal_count + min(surprising_count, S)
  
      print ""Case #%d: %s"" % (case, result)
  
",138," conn = sys.stdin
  P = int(conn.readline())
  for case in range(1,P+1):
      numumbers = map(int, conn.readline().split())
      U, Z, p = numumbers[:3]
      P = numumbers[3:]
      normal_limit = p + 2*max(0, (p-1))
      surpising_limits = p + 2*max(0, (p-2))
  
      normal_count = 0
      surjoining_count = 0
  
      for set in P:
          if set >= normal_limit:
              normal_count += 1
          elif set >= surpising_limits:
              surjoining_count += 1
  
      df = normal_count + min(surjoining_count, Z)
  
      print ""Case #%d: %s"" % (case, df)
  
",LABEL_63,LABEL_63,LABEL_25,1,"fin,T,case,numbers,N,S,p,normal_limit,surpising_limit,normal_count,surprising_count,t,result","fin:0.24819260835647583,T:0.2672649025917053,case:0.1623387336730957,numbers:0.2108372449874878,N:0.24950379133224487,S:0.25068727135658264,p:0.17743360996246338,normal_limit:0.39515233039855957,surpising_limit:0.2896367013454437,normal_count:0.159964919090271,surprising_count:0.30991852283477783,t:0.2854039669036865,result:0.31483298540115356,",1,3,"result:df,surprising_count:surjoining_count,surpising_limit:surpising_limits,t:set,T:P,S:size,N:G,fin:conn,",0,0,Greedy,205,0.07406848271687826,replace,[],0.7311422824859619,0.3513149321079254
128," 
  def read_ints():
      return map(int, stdin.readline().rstrip().split(' '))
  
  def is_palin(n):
      s = str(n)
      return s == s[::-1]
      
  def find(n, fas):
      for i in xrange(len(fas)):
          if fas[i] >= n:
              return i
      return len(fas)
      
  def gen_fas(max):
      fas = []
      fasappend = fas.append
      square, base, d = 1, 1, 3
      while square < max:
          if is_palin(square) and is_palin(base):
              fasappend(square)
          square += d
          d += 2
          base += 1
      return fas
      
  def main():
      MAX = 1000
      fas = gen_fas(MAX)
      
      T = int(stdin.readline())
      for Ti in xrange(T):
          A, B = read_ints()
          answer = find(B + 1, fas) - find(A, fas)
          print 'Case #{}: {}'.format(Ti + 1, answer)
          
  main()
",208," 
  def read_ints():
      return map(int, stdin.readline().rstrip().split(' '))
  
  def is_palin(j):
      v = str(j)
      return v == v[::-1]
      
  def find(j, Fac):
      for it in xrange(len(Fac)):
          if Fac[it] >= j:
              return it
      return len(Fac)
      
  def gen_fas(chain):
      Fac = []
      fasterreplace = Fac.append
      address, ada, l = 1, 1, 3
      while address < chain:
          if is_palin(address) and is_palin(ada):
              fasterreplace(address)
          address += l
          l += 2
          ada += 1
      return Fac
      
  def main():
      TX = 1000
      Fac = gen_fas(TX)
      
      D = int(stdin.readline())
      for Ti in xrange(D):
          P, Ab = read_ints()
          bb = find(Ab + 1, Fac) - find(P, Fac)
          print 'Case #{}: {}'.format(Ti + 1, bb)
          
  main()
",LABEL_64,LABEL_64,,-1,"n,s,fas,i,max,fasappend,square,base,d,MAX,T,Ti,A,B,answer","n:0.8122136145830154,s:0.813110888004303,fas:0.8263213485479355,i:0.8146340027451515,max:0.815719835460186,fasappend:0.8149439096450806,square:0.8231329545378685,base:0.8181910142302513,d:0.8127961456775665,MAX:0.8215782716870308,T:0.8336719498038292,Ti:0.8139367774128914,A:0.823617696762085,B:0.823353685438633,answer:0.8267224282026291,",0,0,"T:D,answer:bb,fas:Fac,A:P,B:BU,square:address,MAX:EXT,base:core,max:chain,fasappend:fasterreplace,i:ori,s:v,d:l,n:l,",0,0,Greedy,304,0.11012347141901652,failed,[],0.9274616837501526,0.7935930490493774
129," 
  def program():
  	T = int(stdin.readline())
  	for Ti in xrange(T):
  		numbers = a = map(int, stdin.readline().rstrip().split(' '))
  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]
  		
  		m = 0
  		curr_S = S
  		for i in xrange(N):
  			t = totals[i]
  			
  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):
  				m += 1
  			elif curr_S > 0 and t > 0:
  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):
  					m += 1
  					curr_S -= 1
  		
  		print 'Case #%d: %d' % (Ti + 1, m)	
  	
  if __name__ == '__main__':
  	program()
",186," 
  def program():
  	Size = int(stdin.readline())
  	for No in xrange(Size):
  		enumer = span = map(int, stdin.readline().rstrip().split(' '))
  		NI, Z, u, total = enumer[0], enumer[1], enumer[2], enumer[3:]
  		
  		b = 0
  		currJT = Z
  		for  iP in xrange(NI):
  			t = total[ iP]
  			
  			if t / 3 >= u or (t / 3 == u - 1 and t % 3 > 0):
  				b += 1
  			elif currJT > 0 and t > 0:
  				if (t / 3 == u - 1 and t % 3 == 0) or (t / 3 == u - 2 and t % 3 == 2):
  					b += 1
  					currJT -= 1
  		
  		print 'Case #%d: %d' % (No + 1, b)	
  	
  if __name__ == '__main__':
  	program()
",LABEL_64,LABEL_64,,-1,"T,Ti,numbers,a,N,S,p,totals,m,curr_S,i,t","T:0.7113177478313446,Ti:0.6807223558425903,numbers:0.7256604582071304,a:0.7025754600763321,N:0.7268514484167099,S:0.704862430691719,p:0.7230157554149628,totals:0.7200859487056732,m:0.7071938812732697,curr_S:0.604480654001236,i:0.7347525209188461,t:0.6484506279230118,",0,0,"i: iP,N:NI,numbers:enumer,p:u,totals:total,T:Size,m:r,S:Z,a:b,Ti:I,curr_S:currJT,",0,0,Greedy,246,0.08905754089355469,failed,[],0.8961672186851501,0.7897139191627502
130," 
  def get_number_of_test_case():
      return int(raw_input().strip())
  
  def solve_case(t):
      A, B = [int(x) for x in raw_input().strip().split()]
  
      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)
  
  def get_number_of_palindrome(n):
      ret = 0
  
      nt = int(math.floor(math.sqrt(n)))
      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))
      upper_limit = 10 ** total_column
  
      counter = 0
      while counter < upper_limit:
          c_str = [c for c in str(counter)]
          c_str.reverse()
  
          number = str(counter)
          for c in c_str:
              number += c
          number = int(number)
          number = number ** 2
          if number <= n and is_palindrome(number):
              ret += 1
  
          number = str(counter)
          for c in c_str[1:]:
              number += c
          number = int(number)
          number = number ** 2
          if number <= n and is_palindrome(number):
              ret += 1
          
          counter += 1
  
      return ret
  
  def is_palindrome(n):
      if n == 0:
          return False
      num = str(n)
      check_len = len(num) / 2
      ret = True
      for i in range(check_len):
          ret &= num[i] == num[-i - 1]
      return ret
  
  T = get_number_of_test_case()
  t = 1
  while t <= T:
      solve_case(t)
      t += 1
  
",304," 
  def get_number_of_test_case():
      return int(raw_input().strip())
  
  def solve_case(alt):
      Na, B = [int(xx) for xx in raw_input().strip().split()]
  
      print 'Case #%d: %d' % (alt, get_number_of_palindrome(B) - get_number_of_palindrome(Na - 1),)
  
  def get_number_of_palindrome(nr):
      ref = 0
  
      gt = int(math.floor(math.sqrt(nr)))
      total64row = int(math.ceil(math.ceil(math.log10(gt + 1)) / 2.0))
      upper_limit = 10 ** total64row
  
      counter = 0
      while counter < upper_limit:
           c_url = [ce for ce in str(counter)]
           c_url.reverse()
  
          number = str(counter)
          for ce in  c_url:
              number += ce
          number = int(number)
          number = number ** 2
          if number <= nr and is_palindrome(number):
              ref += 1
  
          number = str(counter)
          for ce in  c_url[1:]:
              number += ce
          number = int(number)
          number = number ** 2
          if number <= nr and is_palindrome(number):
              ref += 1
          
          counter += 1
  
      return ref
  
  def is_palindrome(nr):
      if nr == 0:
          return False
      int = str(nr)
      check_len = len(int) / 2
      ref = True
      for i in range(check_len):
          ref &= int[i] == int[-i - 1]
      return ref
  
  P = get_number_of_test_case()
  alt = 1
  while alt <= P:
      solve_case(alt)
      alt += 1
  
",LABEL_65,LABEL_65,,-1,"t,A,B,x,n,ret,nt,total_column,upper_limit,counter,c_str,c,number,num,check_len,i,T","t:0.3094237446784973,A:0.2426137924194336,B:0.24276232719421387,x:0.22226279973983765,n:0.23904532194137573,ret:0.21559423208236694,nt:0.18516451120376587,total_column:0.18526071310043335,upper_limit:0.19637608528137207,counter:0.19582724571228027,c_str:0.20693570375442505,c:0.20074021816253662,number:0.18615961074829102,num:0.20687848329544067,check_len:0.2311519980430603,i:0.20086556673049927,T:0.2573438882827759,",0,0,"t:alt,T:P,A:Ca,n:nr,x:xx,ret:ref,c_str: c_url,num:int,c:ce,total_column:total64row,nt:gt,",0,0,Greedy,341,0.12576378583908082,failed,[],0.9670215249061584,0.9250926375389099
131,"t = int(raw_input().strip())
  t_count = 1
  while t_count <= t:
  	line = raw_input().strip().split()
  	n = int(line[0])
  	s = int(line[1])
  	p = int(line[2])
  	ti_list = line[3:]
  	p_min = max(p * 3 - 2, p)
  	p_min_surprise = max(p * 3 - 4, p)
  	result = 0
  	for ti in ti_list:
  		ti = int(ti)
  		if ti >= p_min:
  			result += 1
  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:
  			result += 1
  			s -= 1
  	print 'Case #%d: %d' % (t_count, result,)
  	t_count += 1
",144,,LABEL_65,LABEL_20,,-4,"t,t_count,line,n,s,p,ti_list,p_min,p_min_surprise,result,ti",,,,,0,0,Greedy,1,0.0005446354548136394,,,0.20643524825572968,0.20643524825572968
